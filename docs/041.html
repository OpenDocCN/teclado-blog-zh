<html>
<head>
<title>Python Slices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python切片</h1>
<blockquote>原文：<a href="https://blog.teclado.com/python-slices/">https://blog.teclado.com/python-slices/</a></blockquote><div><div class="post-content">
<p>在这篇文章中，我想告诉你一些关于Python切片的事情。切片是一个强大的工具，但是如果不小心的话也很容易出错。</p><p>那么，切片到底是什么？切片是从现有序列的某个部分创建新序列的过程。这实际上是一个非常直观的概念，非常类似于切蛋糕以获得整体的一部分。</p><p>我们可以对Python中的任何<em>序列类型</em>进行切片。这包括字符串、列表、元组、字节对象和字节数组。</p><p>因为切片依赖于项在序列中的位置，所以它不能用于像集合这样不保持顺序的东西。更重要的是，它们不是由连续的非负整数索引的，这就是为什么字典也不能切片，尽管在现代Python中有可靠的排序。</p><h2 id="creating-a-slice">创建切片</h2><p>让我们定义我们的第一个切片。</p><pre><code class="language-python">slice_instance = slice(0, 2)
</code></pre>
<p>虽然<code>slice</code>在这里看起来像一个函数，但它实际上是一个类。因此，我们只是将<code>slice_instance</code>绑定到某个<code>slice</code>对象上。</p><p>如果我们打印出<code>slice_instance</code>的类型，我们可以看到这一点:</p><pre><code class="language-python">print(type(slice_instance))  # &lt;class 'slice'&gt;
</code></pre>
<p>到目前为止一切顺利。那么当我们创建slice对象时，我们传递给slice的那些数字是什么呢？</p><p>如果我们看一下slice类的<a href="https://docs.python.org/3/library/functions.html#slice">文档</a>，我们会看到slice有三个参数:</p><blockquote>切片(开始，停止[，步进])</blockquote><p>如果您不熟悉文档中的参数符号，方括号中的项目是可选的。</p><p>很好，所以我们传入了参数<code>start</code>和<code>stop</code>。我们一会儿再回来。这些<code>start</code>和<code>stop</code>值表示某个尚未指定的序列中的索引。</p><p>那么我们如何使用这个切片对象呢？好吧，我们需要一些序列来试验一下。</p><p>让我们从一个简单的列表开始:</p><pre><code class="language-python">x = [1, 2, 3, 4, 5]
</code></pre>
<p>我们可以使用下标语法获得序列的一部分:</p><pre><code class="language-python">x_slice = x[slice_instance]
print(x_slice)  # [1, 2]
</code></pre>
<p>因为我们的<code>slice_instance</code>从索引0到索引2，所以我们只得到了<code>x</code>列表的那一部分。</p><p>这里有几点需要注意:</p><ol><li><code>x_slice</code>属于列表类型。</li><li><code>x</code>的索引2处的项目不包含在<code>x_slice</code>中。</li></ol><p>这让我们想到了关于切片的第一个警告:我们为stop参数提供的索引是<strong>而不是</strong>。</p><h3 id="slicing-other-sequence-types">分割其他序列类型</h3><p>分割其他序列类型使用完全相同的语法。</p><p>我们可以定义一个切片对象，然后将其用于任何序列类型，如下所示:</p><pre><code class="language-python">s = slice(1, 4)

t = (1, 2, 3, 4, 5)  # tuple
l = [1, 2, 3, 4, 5]  # list
c = "12345"          # string

print(t[s])  # (2, 3, 4)
print(l[s])  # [2, 3, 4]
print(c[s])  # 234
</code></pre>
<p>从上面的例子中你可能已经注意到了，对一个序列进行切片会得到一个相同类型的序列。</p><p>请记住，字符串只是字符序列，因此是切片的完美候选！</p><h3 id="defining-a-slice-object-inline">内联定义切片对象</h3><p>我们可以这样做，而不是定义一个slice对象，将其绑定到一个变量，然后将该变量名作为下标语法的一部分:</p><pre><code class="language-python">t = (1, 2, 3, 4, 5)
print(t[slice(1, 4)])  # (2, 3, 4)
</code></pre>
<p>然而，还有一种更快的方法，我们将在接下来讨论。</p><h2 id="a-faster-way">更快的方法</h2><p>Python有一种替代语法，可以直接在方括号中定义切片，我们将它作为下标语法的一部分。</p><p>让我们定义与上面使用的相同的切片对象，但是使用新的语法:</p><pre><code class="language-python">t = (1, 2, 3, 4, 5)
print(t[1:4])  # (2, 3, 4)
</code></pre>
<p>您可能知道，第一个数字是我们的起始索引，然后我们提供一个冒号来分隔我们的值，第二个值是停止索引。就像之前一样，这个停止指数并不具有包容性。</p><p>这种新语法对所有序列类型都起相同的作用。</p><h3 id="leaving-some-values-empty">将一些值留空</h3><p>可能会让您感到惊讶的是，以下每一项都是有效的语法:</p><pre><code class="language-python">print(t[:4])
print(t[1:])
print(t[:])
</code></pre>
<p>那么，这些到底是什么意思呢？</p><p>当我们错过起始索引时，这意味着“从序列的开始处开始”。</p><p>当我们错过停止索引时，这意味着“在序列的末尾停止”。</p><p>在后一种情况下，最后一个元素包含在新的切片中。</p><p>把这些放在一起，我们就能猜出最后一个例子的意思:“把整个序列给我”。当你错过了开始和结束的指标，你得到了一切。</p><h2 id="using-step-values">使用步长值</h2><p>在这篇文章的开始，我提到我们也可以在创建切片对象时提供一个可选的步长值。这允许我们通过提供大于<code>1</code>的步长来跳过值。</p><p>例如:</p><pre><code class="language-python">t = (1, 2, 3, 4, 5)
print(t[1:4:2])  # (2, 4)
</code></pre>
<p>我们从索引<code>1</code>处的项目开始，然后直接进入索引<code>3</code>处的项目。</p><h3 id="negative-step-values">负阶跃值</h3><p>步长值不需要为正，这实际上是一个非常有用的属性。当一个步长值为负时，我们像往常一样从起始索引开始，但是然后沿着序列反向移动。</p><p>例如，我们可能希望从索引<code>4</code>开始，在索引<code>2</code>停止，并以<code>-1</code>的步长移动。</p><pre><code class="language-python">t = (1, 2, 3, 4, 5)
print(t[4:2:-1]  # (5, 4)
</code></pre>
<p>注意，结果以与原始元组相反的顺序返回。这是因为首先遇到的是元组末尾的值，我们一直向元组的开头前进。</p><p>使用扩展切片，我们仍然可以使用下面的语法获得一个完整的列表:<code>[::]</code>。看起来有点晦涩难懂，但它只是表示从序列的开头开始，在结尾停止，使用默认的步长值:<code>1</code>。</p><p>结合负阶跃值。我们可以使用这样的语法来检查一个序列是否是一个<a href="https://en.wikipedia.org/wiki/Palindrome">回文</a>，例如:</p><pre><code class="language-python">def palindrome_check(word):
	if word == word[::-1]:  # check against full sequence in reverse order
		return True
	return False

print(palindrome_check("kayak"))  # True
print(palindrome_check("lemon"))  # False
</code></pre>
<h3 id="a-warning-about-negative-step-values">关于负步长值的警告</h3><p>关于切片的一个问题是，很容易得到一个空切片，尤其是当负值出现时。</p><p>例如，我们可以尝试对一个旧切片使用负阶跃:</p><pre><code class="language-python">t = (1, 2, 3, 4, 5)
print(t[1:4:-1])  # ()  &lt;- Empty tuple
</code></pre>
<p>但是上面的例子将返回一个空的元组。这是因为不可能按照<code>-1</code>的步骤从索引<code>1</code>到达索引<code>4</code>。应该写的是<code>t[4:1:-1]</code>，从比我们结束的地方更高的索引开始，它应该打印<code>(5, 4, 3)</code>。</p><h2 id="negative-indices">负指数</h2><p>除了提供负的步长值，我们还可以为索引提供负数。</p><p>当使用负索引时，我们从序列的末尾开始倒计数。在我们上面的元组<code>t</code>中，索引<code>-1</code>与索引<code>4</code>相同。换句话说，元组中的最后一项。</p><p><code>t</code>中索引<code>0</code>处的项目也在索引<code>-5</code>处。因此，我们可以这样写一个切片:</p><pre><code class="language-python">t = (1, 2, 3, 4, 5)
print(t[-1:-5:-1])  # (5, 4, 3, 2)
</code></pre>
<p>我选择这个例子有一个特殊的原因，因为它强调了使用切片时容易陷入的另一个陷阱。当使用负指数时，止损值仍然是<strong>而不是</strong>。为了包含索引<code>0</code>处的项目，我们必须编写:</p><pre><code class="language-python">t[-1:-6:-1]
</code></pre>
<h2 id="recap">概述</h2><ul><li>切片可用于从另一个序列的某个部分创建序列。</li><li>只有<em>序列类型</em>可以切片，因为切片依赖于非负索引索引的项目。</li><li>我们可以定义一个slice对象，创建一个<code>slice</code>类的实例，它有三个参数:起始索引、停止索引和可选的步长值。请记住，给定序列的停止索引处的项目是包含在切片中的<strong>而不是</strong>。</li><li>我们可以创建一个特定序列的切片，方法是将一个切片对象直接传递到该序列后面的一对方括号中，例如<code>some_sequence[slice(1, 2)]</code>。我们还可以在这些方括号中使用特殊的slice语法，这样就不需要使用来显式创建一个slice对象，例如<code>some_sequence[1:2]</code>。</li><li>索引值和步长值都可以是负值，但是在使用负值时我们必须小心，因为很容易得到一个不包含任何内容的切片。否定步骤的一个用例是快速反转一个序列，如下所示:<code>some_sequence[::-1]</code>。</li></ul><p>我希望你学到了新的东西，如果你想进一步提升你的Python技能，你可能想试试我们的<a href="https://www.udemy.com/the-complete-python-course/?couponCode=BLOGGER">完整Python课程</a>。</p><p>请务必查看下周的帖子，我们将在那里更深入地讨论切片技术。</p>
</div>
</div>    
</body>
</html>