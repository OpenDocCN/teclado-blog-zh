<html>
<head>
<title>Day 23: Generators and Generator Expressions | Teclado</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>第23天:发电机和发电机表达式</h1>
<blockquote>原文：<a href="https://blog.teclado.com/python-30-day-23-generators-yield/">https://blog.teclado.com/python-30-day-23-generators-yield/</a></blockquote><div><article class="pb-12 prose prose-p:font-copy col-start-2 dark:prose-invert">
                    
                    <p>欢迎来到Python 系列<a href="https://blog.teclado.com/30-days-of-python/"> 30天的第23天！今天我们将会看到一些使用生成器和生成器表达式来创建我们自己的迭代器的方法。</a></p>
<p>我们还将看到一个叫做<code>iter</code>的重要函数，它为我们传递给它的任何可迭代对象返回一个迭代器。这将让我们确认我们在昨天的帖子中讨论的许多理论，并且我们也将能够使用它来更深入地理解<code>for</code>循环。</p>
<p>这篇文章将在我们昨天的文章的<a href="/30-days-of-python/python-30-day-22-iterators">中讨论的基础上建立大量内容，所以如果你还没有阅读它，我建议你在进一步阅读之前先看一看。</a></p>
<h2><code>iter</code>功能</h2>
<p>Python有一个名为<code>iter</code>的内置函数，为我们作为参数提供的iterable返回一个迭代器。</p>
<p>例如，让我们看一个简单的数字列表，如下所示:</p>
<div class="codehilite"><pre><span/><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</code></pre></div>

<p>如果我们将这个数字列表传递给<code>iter</code>，我们将得到这个列表的迭代器。</p>
<div class="codehilite"><pre><span/><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">numbers_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">numbers_iter</span><span class="p">)</span>  <span class="c1"># &lt;list_iterator object at 0x7f57d138af70&gt;</span>
</code></pre></div>

<p>在这种情况下，我们得到一个<code>list_iterator</code>对象，它将允许我们访问<code>numbers</code>中的值。不同的类型有它们自己的迭代器，这些迭代器知道如何从那些可迭代的对象中给我们条目。毕竟，从字典中获取元素与从列表中获取项目有些不同。</p>
<p>我们可以像使用任何其他迭代器一样使用这个<code>list_iterator</code>对象。比如我们可以传给<code>next</code>。</p>
<div class="codehilite"><pre><span/><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">numbers_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">numbers_iter</span><span class="p">))</span>  <span class="c1"># 1</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">numbers_iter</span><span class="p">))</span>  <span class="c1"># 2</span>
</code></pre></div>

<p>一个有趣的问题是，当我们在<code>list_iterator</code>上调用<code>iter</code>时会发生什么？</p>
<p>这是完全合法的，因为<code>iter</code>只需要一个iterable，而所有迭代器都是iterable。这也产生了一个有趣的效果。</p>
<div class="codehilite"><pre><span/><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">numbers_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">numbers_iter</span> <span class="ow">is</span> <span class="nb">iter</span><span class="p">(</span><span class="n">numbers_iter</span><span class="p">))</span>  <span class="c1"># True</span>
</code></pre></div>

<p>我们发现将<code>numbers_iter</code>传递给<code>iter</code>函数会导致<code>iter</code>返回完全相同的迭代器。乍一看，这似乎很奇怪，但却很有意义。</p>
<p>昨天我们讨论了迭代器，通过它我们可以访问iterable中的条目。当我们想要迭代一个iterable时，我们需要一个知道如何获取这些值的迭代器。</p>
<p>如果我们请求<em>迭代器</em>给我们一个访问这些值的方法，它会主动提供，因为它已经能够做我们想要的事情了。</p>
<h2>用<code>iter</code>复制<code>for</code>循环</h2>
<p>我们可以用<code>iter</code>函数做的一件很酷的事情是复制Python的<code>for</code>循环的行为。这将让我们一窥<code>for</code>循环在幕后真正做了什么。</p>
<p>让我们在这个例子中再次使用我们的数字列表。</p>
<div class="codehilite"><pre><span/><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">numbers_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
</code></pre></div>

<p>我们有一个迭代器，这是重要的第一步，但是我们还需要一些其他工具来完成这项工作。首先，我们需要一个<code>while</code>循环，因为我们想要无限次地循环。其次，我们需要一个<code>try</code>语句，这样我们就可以发现一个<code>StopIteration</code>异常。</p>
<div class="codehilite"><pre><span/><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">numbers_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>

<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">number</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">numbers_iter</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
</code></pre></div>

<p>就这样，我们用<code>while</code>写了一个<code>for</code>循环。</p>
<p>我们在<code>try</code>中定义了循环变量<code>number</code>，在<code>else</code>子句中定义了循环体。一旦我们用完了所有的数字，循环就会终止，就像我们看到的<code>for</code>循环一样。</p>
<p>这实际上非常接近实际的<code>for</code>循环在引擎盖下的工作方式。它为我们想要迭代的对象请求一个迭代器，并调用<code>next</code>从迭代器中检索值。当出现<code>StopIteration</code>时，Python通过中断循环来处理该错误。</p>
<p>这不是你应该在你的产品代码中做的事情，但是这是一个有趣的幕后窥视，帮助我们更好地理解我们从第一周开始使用的结构。</p>
<h2>发电机</h2>
<p>让我们暂时抛开<code>iter</code>，转到使用<em>生成器</em>创建我们自己的迭代器的话题上来。</p>
<p>在Python中创建定制迭代器的方法有很多，但大多数都超出了本系列的范围。不过，这并不是很大的限制，我们可以使用生成器做大量非常复杂的事情。</p>
<p>生成器的语法对我们来说会非常熟悉，因为生成器实际上只是一个函数。生成器与常规函数的唯一区别是一个叫做<code>yield</code>的特殊关键字。</p>
<p>在我们深入这个新的<code>yield</code>关键字之前，让我们看一个简单的生成器例子。</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">first_hundred</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">number</span>
</code></pre></div>

<p>这里我定义了一个生成器，这只是一个特殊的函数，我把它叫做<code>first_hundred</code>。</p>
<p>我们可以从函数体中看出，它与数字<code>1</code>到<code>100</code>有关，我们大概可以推断它会给我们前一百个整数，从<code>1</code>开始。</p>
<p>让我们调用我们的函数，看看会发生什么。</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">first_hundred</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">number</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">first_hundred</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</code></pre></div>

<p>如果您运行这段代码，我们肯定不会得到任何类似于打印到控制台上的数字<code>1</code>到<code>100</code>的东西。我们得到这个<code>generator</code>物体:</p>
<div class="codehilite"><pre><span/><code><span class="o">&lt;</span><span class="n">generator</span> <span class="nb">object</span> <span class="n">first_hundred</span> <span class="n">at</span> <span class="mh">0x7faaa563fc80</span><span class="o">&gt;</span>
</code></pre></div>

<p>这实际上被称为<em>生成器迭代器</em>，当我们调用任何包含<code>yield</code>关键字的函数时，都会返回这个迭代器。</p>
<p>顾名思义，这是一个迭代器，我们可以像使用其他迭代器一样使用它。</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">first_hundred</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">number</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">first_hundred</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>  <span class="c1"># 1</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>  <span class="c1"># 2</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>  <span class="c1"># 3</span>
</code></pre></div>

<h3>重要的</h3>
<p>当我们调用一个生成器时，它会返回一个新的生成器迭代器。这些生成器迭代器中的每一个都是独立的迭代器，所以要小心不要这样做:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">first_hundred</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">number</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">first_hundred</span><span class="p">()))</span>  <span class="c1"># 1</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">first_hundred</span><span class="p">()))</span>  <span class="c1"># 1</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">first_hundred</span><span class="p">()))</span>  <span class="c1"># 1</span>
</code></pre></div>

<p>对<code>first_hundred</code>的每次调用都给了我们一个新的迭代器，所以我们只能从每个迭代器中获得第一个值。你也没有在任何地方分配迭代器，所以我们不可能在同一个迭代器上再次调用<code>next</code>。</p>
<h2><code>yield</code>关键字</h2>
<p>既然我们已经看到了一个运行中的生成器，是时候讨论一下这个<code>yield</code>关键字在做什么了。</p>
<p>我们已经知道，它向Python发出了我们正在定义一个生成器的信号，但它似乎也在实际提供我们想要的来自生成的生成器迭代器的值方面有一些作用。</p>
<p><code>yield</code>实际上做的是在函数体的执行中创建一个暂停。当我们调用<code>next</code>并传入我们的生成器迭代器时，函数体中的代码将一直运行，直到我们点击了那个<code>yield</code>关键字。</p>
<p>关键字<code>yield</code>之后的值是我们在暂停函数体执行之前实际想要提供的。这样，我们可以认为<code>yield</code>是一个非终结性的<code>return</code>语句。</p>
<p>我们可以通过给<code>first_hundred</code>添加几个<code>print</code>调用来看到这一切。</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">first_hundred</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"First value requested</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Starting new iteration"</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">number</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Ending this iteration</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">first_hundred</span><span class="p">()</span>
</code></pre></div>

<p>此时，不会打印任何内容。生成器迭代器已经创建，但是我们实际上还没有尝试访问任何值。现在让我们将<code>g</code>传递到<code>next</code>几次。</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">first_hundred</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"First value requested</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Starting new iteration"</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">number</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Ending this iteration</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">first_hundred</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
</code></pre></div>

<p>现在我们的输出看起来像这样:</p>
<div class="codehilite"><pre><span/><code><span class="n">First</span> <span class="n">value</span> <span class="n">requested</span>

<span class="n">Starting</span> <span class="n">new</span> <span class="n">iteration</span>
<span class="mi">1</span>
<span class="n">Ending</span> <span class="n">this</span> <span class="n">iteration</span>

<span class="n">Starting</span> <span class="n">new</span> <span class="n">iteration</span>
<span class="mi">2</span>
</code></pre></div>

<p>首先我们得到<code>"First value requested\n"</code>字符串，然后我们进入<code>for</code>循环。此时，我们从<code>range</code>对象获得一个值，假设为<code>number</code>，并打印出<code>"Starting new iteration"</code>字符串。</p>
<p>然后我们遇到暂停函数体执行的关键字<code>yield</code>，我们的生成器迭代器抛出<code>1</code>，这是<code>number</code>的当前值。这个值是通过调用<code>next</code>返回的，我们将它打印到控制台。</p>
<p>然后我们再次调用<code>next</code>，并从我们停止的地方继续。这意味着我们打印了<code>"Ending this iteration\n"</code>字符串，然后我们进入了<code>for</code>循环的新一轮迭代。</p>
<p>我们在循环开始时再次调用<code>print</code>函数，然后再次点击<code>yield</code>。我们给出这个数字，这是<code>next</code>再次返回的。然后像以前一样，将它打印到控制台。</p>
<p>对于第二次迭代，你会注意到我们没有打印<code>"Ending this iteration\n"</code>字符串，因为<code>yield</code>在我们到达那个点之前暂停了执行。</p>
<p>如果我们再次调用<code>next</code>，我们将在开始循环的第三次迭代之前，首先打印这个字符串。</p>
<h3>注意</h3>
<p><code>yield</code>实际上是一个非常复杂的关键字，它能做的远不止我们使用它的目的。然而，我们不打算在本系列中讨论这种额外的行为，因为它只在更高级的代码中有应用。</p>
<p>我提到这一点只是为了让您知道，一旦您在Python职业生涯中走得更远，还有更多的东西要学。</p>
<h2>生成器表达式</h2>
<p>除了通过函数创建生成器迭代器，我们还可以使用<em>生成器表达式</em>。</p>
<p>生成器表达式语法对我们来说也非常熟悉，因为它与我们在<a href="/30-days-of-python/python-30-day-15-comprehensions/"> day 15 </a>中所说的理解语法完全相同。唯一的区别是我们使用常规括号，而不是方括号或花括号。</p>
<p>我们可以像理解一样使用它们，但是它们具有迭代器的所有优点，这些优点是<code>map</code>和<code>filter</code>提供的。如果您想获得这些好处，但不喜欢<code>map</code>和<code>filter</code>的语法，生成器表达式正适合您。</p>
<p>例如，让我们创建一个简单的生成器表达式，它对一个<code>range</code>中的每个数字求平方。</p>
<div class="codehilite"><pre><span/><code><span class="n">squares</span> <span class="o">=</span> <span class="p">(</span><span class="n">number</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
</code></pre></div>

<p>由于<code>squares</code>指的是迭代器，直接打印出来并不会给我们带来太多有用的东西，但是它至少确认了我们正在使用生成器迭代器。</p>
<div class="codehilite"><pre><span/><code><span class="o">&lt;</span><span class="n">generator</span> <span class="nb">object</span> <span class="o">&lt;</span><span class="n">genexpr</span><span class="o">&gt;</span> <span class="n">at</span> <span class="mh">0x7f33225a0c80</span><span class="o">&gt;</span>
</code></pre></div>

<p>如果我们想要得到值，我们可以将它传递给一个<code>for</code>循环，我们可以析构它，或者我们可以使用<code>next</code>来执行手动迭代。</p>
<div class="codehilite"><pre><span/><code><span class="n">squares</span> <span class="o">=</span> <span class="p">(</span><span class="n">number</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>

<span class="k">for</span> <span class="n">square</span> <span class="ow">in</span> <span class="n">squares</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>

<span class="n">squares</span> <span class="o">=</span> <span class="p">(</span><span class="n">number</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">squares</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">", "</span><span class="p">)</span>

<span class="n">squares</span> <span class="o">=</span> <span class="p">(</span><span class="n">number</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">squares</span><span class="p">))</span>  <span class="c1"># 1</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">squares</span><span class="p">))</span>  <span class="c1"># 4</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">squares</span><span class="p">))</span>  <span class="c1"># 9</span>
</code></pre></div>

<p>请记住，当我们迭代迭代器时，<code>squares</code>中的值会被消耗掉，所以如果您想不止一次地迭代它，您需要重新定义<code>squares</code>。</p>
<h3>风格注释</h3>
<p>关于生成器表达式的一个好处是，当我们在函数或方法中使用生成器表达式作为唯一参数时，我们可以放弃圆括号。</p>
<p>这是完全合法的语法，例如:</p>
<div class="codehilite"><pre><span/><code><span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">number</span> <span class="o">**</span> <span class="mi">2</span>  <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span>  <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">11</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>  <span class="c1"># 385</span>
</code></pre></div>

<p>这有助于我们减少只会妨碍可读性的嵌套括号。</p>
<h2>练习</h2>
<p>1)编写一个生成器，生成指定范围内的素数。你可以从第8天的<a href="/30-days-of-python/python-30-day-8-while-loops/">开始，利用你的解决方案进行练习3。</a></p>
<p>2)下面我们有一个使用<code>map</code>处理列表中名字的例子。使用生成器表达式重写这段代码。</p>
<div class="codehilite"><pre><span/><code><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">" rick"</span><span class="p">,</span> <span class="s2">" MORTY  "</span><span class="p">,</span> <span class="s2">"beth "</span><span class="p">,</span> <span class="s2">"Summer"</span><span class="p">,</span> <span class="s2">"jerRy    "</span><span class="p">]</span>
<span class="n">names</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">title</span><span class="p">(),</span> <span class="n">names</span><span class="p">)</span>
</code></pre></div>

<p>3)编写一个小程序，为德州扑克游戏发牌。交易顺序如下:</p>
<ul>
<li>这副牌洗好了。</li>
<li>每个玩家按顺序拿到一张牌。</li>
<li>第二张卡交给每个玩家。</li>
</ul>
<p>接下来是交易中更复杂的部分。</p>
<ul>
<li>首先，该副牌的顶牌被丢弃。这被称为烧伤。</li>
<li>然后将三张牌放在桌子中央，这被称为<em>翻牌</em>。</li>
<li>另一张牌被烧掉了，这意味着我们从牌堆的顶部再弃一张牌。</li>
<li>我们在中心增加了另一张牌，叫做<em>转</em>。</li>
<li>我们再烧一张卡。</li>
<li>最后，还有<em>河</em>，第五张也是最后一张牌被添加到中间。</li>
</ul>
<p>该程序的预期输出如下所示:</p>
<div class="codehilite"><pre><span/><code><span class="n">How</span> <span class="n">many</span> <span class="n">players</span> <span class="n">are</span> <span class="n">there</span><span class="err">?</span> <span class="mi">2</span>

<span class="n">Player</span> <span class="mi">1</span> <span class="n">was</span> <span class="n">dealt</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">hearts</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">clubs</span><span class="p">)</span>
<span class="n">Player</span> <span class="mi">2</span> <span class="n">was</span> <span class="n">dealt</span><span class="p">:</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">clubs</span><span class="p">),</span> <span class="p">(</span><span class="n">jack</span><span class="p">,</span> <span class="n">diamonds</span><span class="p">)</span>

<span class="n">The</span> <span class="n">flop</span><span class="p">:</span> <span class="p">(</span><span class="n">jack</span><span class="p">,</span> <span class="n">clubs</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">diamonds</span><span class="p">),</span> <span class="p">(</span><span class="n">king</span><span class="p">,</span> <span class="n">spades</span><span class="p">)</span>
<span class="n">The</span> <span class="n">turn</span><span class="p">:</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">hearts</span><span class="p">)</span>
<span class="n">The</span> <span class="n">river</span><span class="p">:</span> <span class="p">(</span><span class="n">ace</span><span class="p">,</span> <span class="n">hearts</span><span class="p">)</span>
</code></pre></div>

<p>正如示例所示，程序应该接受可变数量的玩家。至少要有2个玩家，不要超过10个。</p>
<p>在翻牌圈、转牌圈和河牌圈之后，通常会有一轮下注，所以如果你想延长这个练习，你可以让玩家选择在每一点暂停。</p>
<p>提示:我们可以使用<code>random.shuffle</code>方法洗牌。这会原地打乱序列，这意味着它会修改原始序列。然后，我们可以使用<code>iter</code>从该序列创建一个迭代器，使我们一次检索一张卡片变得容易。</p>
<p>你可以在这里找到<code>random.shuffle</code> <a href="https://docs.python.org/3/library/random.html#random.shuffle">的文档。</a></p> 
                </article>
            
            </div>    
</body>
</html>