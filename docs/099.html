<html>
<head>
<title>How to add Menus to Tkinter applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何向Tkinter应用程序添加菜单</h1>
<blockquote>原文：<a href="https://blog.teclado.com/how-to-add-menu-to-tkinter-app/">https://blog.teclado.com/how-to-add-menu-to-tkinter-app/</a></blockquote><div><div class="post-content">
<p>在这篇文章中，我们将学习如何利用Tkinter的<code>Menu</code>小部件在我们的GUI应用程序中创建不同类型的菜单。</p><p>在这篇文章中，我们将使用一个非常简单的应用程序。它不显示任何东西，在我们添加菜单之前，它也不会真正做任何事情。Tkinter的<code>Menu</code>小部件是完全独立的单元，除了根窗口之外，不依赖于我们应用中的任何东西。</p><p>为了简单起见，我们的起始代码应该是这样的:</p><pre><code class="language-python">import tkinter as tk

root = tk.Tk()

root.mainloop()
</code></pre>
<p>我们甚至不需要导入<code>ttk</code>，因为<code>Menu</code>部件不是主题部件。我们非常激动人心的Tkinter应用程序应该是这样的:</p><figure class="kg-card kg-image-card"><img src="../Images/57926bf96b06d8d0f25ea9f8edea82d1.png" class="kg-image" alt="" loading="lazy" data-original-src="https://blog.teclado.com/content/images/2019/12/Screenshot-from-2019-12-22-18-45-23.png"/></figure><p>Tkinter将尝试使窗口与您的操作系统相匹配，所以如果您的窗口看起来有点不同，请不要担心。</p><p>向我们的应用程序添加一个<code>Menu</code>小部件就像添加任何其他元素一样。我们将把新的<code>Menu</code>小部件分配给<code>menubar</code>变量，并且我们将把<code>root</code>作为<code>Menu</code>父对象传入。</p><pre><code class="language-python">menubar = tk.Menu(root)
</code></pre>
<p>我们还需要添加另一行来告诉根窗口这个<code>menubar</code>是窗口的菜单:</p><pre><code class="language-pyhon">root.config(menu=menubar)
</code></pre>
<p>如果您在此时运行应用程序，您不太可能看到太多的不同。这是因为我们的菜单没有任何内容，所以它的高度已经崩溃到接近零。</p><p>那么，我们如何向菜单中添加项目呢？我们有几个选项，但我们将从添加触发命令的简单按钮开始。</p><p>我们可以通过调用我们创建的<code>Menu</code>小部件实例上的<code>add_command</code>方法来添加一个按钮。</p><p>当调用这个方法时，我们将传递两个配置:一个<code>label</code>和一个<code>command</code>。我们可以设置各种其他值，但大多数只是以某种方式控制按钮的外观。例如，我们也可以设置<code>state</code>来禁用按钮。</p><p>传递给<code>command</code>参数的值决定了当用户点击按钮时会发生什么，而<code>label</code>决定了选项将如何在菜单中显示。如果你愿意，你也可以用<code>image</code>来代替。</p><p>以下是几个简单的按钮示例:</p><pre><code class="language-python">from tkinter import ttk

root = tk.Tk()

menubar = tk.Menu(root)
menubar.add_command(label="Say Hello", command=lambda: print("Hello"))
menubar.add_command(label="Say Goodbye", command=lambda: print("Goodbye"))

root.config(menu=menubar)

root.mainloop()
</code></pre>
<p>注意，我们在这里必须使用lambda函数，因为我们将参数传递给了<code>print</code>。如果我们编写类似于<code>command=print("Hello")</code>的代码，函数将在<code>add_command</code>执行期间运行，并且<code>print("Hello")</code>的返回值将作为<code>command</code>参数的值传入。一般不是我们想要的。</p><p>这样，我们的应用程序现在有了一个工作菜单！</p><figure class="kg-card kg-image-card"><img src="../Images/dccafbc444ac3c003de22c60a0802754.png" class="kg-image" alt="" loading="lazy" data-original-src="https://blog.teclado.com/content/images/2019/12/Screenshot-from-2019-12-22-19-17-58.png"/></figure><p>如果我们点击<code>Say Hello</code>按钮，我们将<code>Hello</code>打印到控制台，<code>Say Goodbye</code>打印<code>Goodbye</code>。没有什么疯狂的，但我们可以使用相同的原则来运行任何我们想要的操作。</p><p>例如，我们可以用一个使用<code>root.destroy</code>关闭应用程序的<code>Quit</code>按钮来代替<code>Say Goodbye</code>。</p><pre><code class="language-python">import tkinter as tk
from tkinter import ttk

root = tk.Tk()

menubar = tk.Menu(root)
menubar.add_command(label="Say Hello", command=lambda: print("Hello"))
menubar.add_command(label="Quit", command=root.destroy)

root.config(menu=menubar)


root.mainloop()
</code></pre>
<p>在这种情况下不需要lambda，因为我们不想向<code>destroy</code>方法传递任何参数。</p><p>当我们的程序变得更加复杂时，我们经常希望能够将应用程序菜单组织成各种子菜单，以便于导航。主菜单有许多标题，每个标题触发一个不同的下拉菜单。</p><p>为了在Tkinter中做到这一点，我们需要为每个子菜单创建一个不同的<code>Menu</code>小部件，并为菜单栏本身再创建一个。</p><p>让我们首先创建一个名为<code>salutations</code>的新菜单，它将容纳我们的<code>Say Hello</code>和<code>Say Goodbye</code>按钮。</p><pre><code>salutations = tk.Menu(menubar)
salutations.add_command(label="Say Hello", command=lambda: print("Hello"))
salutations.add_command(label="Say Goodbye", command=lambda: print("Goodbye"))</code></pre><p>注意这个<code>Menu</code>小部件的父部件不是<code>root</code>:它是主<code>menubar</code>小部件。</p><p>我们现在可以使用<code>add_cascade</code>方法将这个新的子菜单添加到<code>menubar</code>中，如下所示:</p><pre><code class="language-python">menubar.add_cascade(label="Salutations", menu=salutations)
</code></pre>
<p>我们再次设置了一个<code>label</code>，它将决定这个子菜单的标题。<code>menu</code>参数接受一个<code>Menu</code>小部件，它将作为与该标签相关联的子菜单。</p><p>总的来说，代码看起来像这样:</p><pre><code class="language-python">import tkinter as tk
from tkinter import ttk

root = tk.Tk()

menubar = tk.Menu(root)

salutations = tk.Menu(menubar)
salutations.add_command(label="Say Hello", command=lambda: print("Hello"))
salutations.add_command(label="Say Goodbye", command=lambda: print("Goodbye"))

menubar.add_cascade(label="Salutations", menu=salutations)

root.config(menu=menubar)

root.mainloop()
</code></pre>
<p>我们的应用现在可以做到这一点:</p><figure class="kg-card kg-image-card"><img src="../Images/b69e4a48e443a26cc4f2639e0a9764ea.png" class="kg-image" alt="" loading="lazy" data-original-src="https://blog.teclado.com/content/images/2019/12/Screenshot-from-2019-12-22-20-28-24.png"/></figure><p>你可能没有预料到的一件事是<code>Say Hello</code>上面的虚线。这是什么意思？为什么会在那里？</p><p>这条虚线代表穿孔，表示菜单可以撕掉。这在现代应用中并不常见，但它允许我们这样做:</p><figure class="kg-card kg-image-card"><img src="../Images/244c79d8a7aeddc992b7cf9f70a84507.png" class="kg-image" alt="" loading="lazy" data-original-src="https://blog.teclado.com/content/images/2019/12/Screenshot-from-2019-12-22-20-32-26.png"/></figure><p>如果你想让你的用户能够分离菜单并在屏幕上移动它们，你很幸运，因为这是默认行为！如果您不希望这样，那么我们需要通过向我们的<code>Menu</code>小部件传递一些额外的配置来关闭它。幸运的是这非常简单，我们只需要添加一个附加的关键字参数。</p><p>官方文档使用<code>tearoff=0</code>，但是<code>tearoff=False</code>也可以，我认为它更有意义，所以我在这里使用它:</p><pre><code class="language-python">import tkinter as tk
from tkinter import ttk

root = tk.Tk()

menubar = tk.Menu(root)

salutations = tk.Menu(menubar, tearoff=False)
salutations.add_command(label="Say Hello", command=lambda: print("Hello"))
salutations.add_command(label="Say Goodbye", command=lambda: print("Goodbye"))

menubar.add_cascade(label="Salutations", menu=salutations)

root.config(menu=menubar)

root.mainloop()
</code></pre>
<p>再见，撕下的菜单:</p><figure class="kg-card kg-image-card"><img src="../Images/711a1bcfe48e26e661a4467931ec7e00.png" class="kg-image" alt="" loading="lazy" data-original-src="https://blog.teclado.com/content/images/2019/12/Screenshot-from-2019-12-22-20-37-14.png"/></figure><p>除了按钮和子菜单，我们还有一些其他的东西可以添加到菜单中。</p><p>下面是一个菜单，其中包含一些附加选项:</p><pre><code class="language-python">option_1 = tk.StringVar()
option_2 = tk.StringVar()
radio_option = tk.StringVar()

options = tk.Menu(menubar, tearoff=False)
options.add_checkbutton(label="Option 1", variable=option_1, command=lambda: print(option_1.get()))
options.add_checkbutton(label="Option 2", variable=option_2, command=lambda: print(option_2.get()))
options.add_separator()
options.add_radiobutton(label="Radio 1", variable=radio_option, value="Radio Option 1")
options.add_radiobutton(label="Radio 2", variable=radio_option, value="Radio Option 2")
options.add_radiobutton(label="Radio 3", variable=radio_option, value="Radio Option 3")

menubar.add_cascade(label="Options", menu=options)
</code></pre>
<p>首先，我们有一个<code>checkbutton</code>，它的工作方式非常类似于主<code>Checkbutton</code>小部件。我们可以指定一个变量来保存当前的选中状态；我们可以为选中和未选中状态设置值；我们可以设置一个命令，在每次点击<code>checkbutton</code>时触发。在我们的例子中，它从变量中检索新的选中状态。</p><p>接下来我们有<code>add_separator</code>方法，它向菜单添加一行来帮助区分选项组。您可以使用它，无需任何额外的配置。</p><p>最后，我们在菜单里有一些<code>radiobutton</code>项目。同样，这些功能非常类似于主<code>Radiobutton</code>小部件。在上面的菜单中，我们刚刚设置了一个变量来存储哪个选项被切换，并且我们为每个按钮设置了一个值。</p><p>您可以在下面看到此菜单的示例:</p><figure class="kg-card kg-image-card"><img src="../Images/87bc12413ce8e9f4b065d1fc8819be76.png" class="kg-image" alt="" loading="lazy" data-original-src="https://blog.teclado.com/content/images/2019/12/Screenshot-from-2019-12-22-20-53-02.png"/></figure><h2 id="the-add-method"><code>add</code>法</h2><p>除了这些专门的方法，如<code>add_checkbutton</code>、<code>add_cascade</code>和<code>add_command</code>，还有一个通用的<code>add</code>方法。</p><p>我们可以使用<code>add</code>来复制任何其他方法:我们只需要传入要作为字符串添加的项的类型。这可以是位置参数，也可以是使用键<code>itemType</code>的关键字参数:</p><pre><code class="language-python">salutations.add(itemType="command", label="Say Hello", command=lambda: print("Hello"))
salutations.add("command", label="Say Goodbye", command=lambda: print("Goodbye"))
</code></pre>
<p>使用您喜欢的版本。</p><h2 id="wrapping-up">包扎</h2><p>这就是关于Tkinter <code>Menu</code> widgets的这篇文章。我希望你学到了一些新的东西，如果你热衷于深入挖掘Tkinter，一定要看看我们的<a href="https://www.udemy.com/course/desktop-gui-python-tkinter/"> GUI开发课程</a>！</p>
</div>
</div>    
</body>
</html>