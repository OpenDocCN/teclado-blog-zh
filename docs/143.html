<html>
<head>
<title>Day 17: Flexible Functions with *args and **kwargs | Teclado</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>第17天:带有*args和**kwargs | Teclado的灵活函数</h1>
<blockquote>原文：<a href="https://blog.teclado.com/python-30-day-17-args-kwargs/">https://blog.teclado.com/python-30-day-17-args-kwargs/</a></blockquote><div><article class="pb-12 prose prose-p:font-copy col-start-2 dark:prose-invert">
                    
                    <p>欢迎来到<a href="https://blog.teclado.com/30-days-of-python/"> 30天Python </a>系列的第17天！今天我们将讨论如何使用<code>*</code>和<code>**</code>操作符来创建真正灵活的函数，可以接受任意数量的参数。</p>
<h2>问题是</h2>
<p>你们中的一些人可能已经注意到，一些内置函数接受可变数量的参数。举个例子，我们来看看好老<code>print</code>。</p>
<p><code>print</code>实际上可以接受任意数量的位置参数，默认情况下它会将它们并排打印出来:</p>
<div class="codehilite"><pre><span/><code><span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># 1 2 3 4 5</span>
</code></pre></div>

<p>放在这些值之间的字符由另一个名为<code>sep</code>的参数控制，该参数的默认值为<code>" "</code>。这就是为什么我们在每个项目之间有一个空格。</p>
<p>我们可以这样明确地写:</p>
<div class="codehilite"><pre><span/><code><span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">" "</span><span class="p">)</span>  <span class="c1"># 1 2 3 4 5</span>
</code></pre></div>

<p>如果你感兴趣的话，我们有<a href="https://blog.teclado.com/python-a-closer-look-at-print/">另一篇文章</a>，它对<code>print</code>有更详细的描述。</p>
<p>虽然这种行为看起来相对简单，但这不是我们现在可以复制的。我们必须为每个参数提供一个参数，反过来，每个参数也必须有一个对应的参数。这意味着我们需要事先知道我们要接受多少值。</p>
<p>那么，我们如何做类似于<code>print</code>的事情，我们可以接受用户提供的尽可能多的参数？</p>
<h2>接受任意数量的位置参数</h2>
<p>让我们从位置论点开始，因为这是我们在<code>print</code>中观察到的行为。</p>
<p>我们接受任意数量的位置参数的方法是定义一种特殊的参数，它的名字前面有一个<code>*</code>。非常明确地说，这个<code>*</code>实际上是一个操作符，而不是参数名的一部分。</p>
<p>一般来说我们称这个特殊参数为<code>args</code>，是arguments的简称。</p>
<p>当我们包含一个<code>*</code>参数时，Python将在我们调用函数时收集任何未赋值的位置参数，并将它们全部放入一个元组中。这个元组被分配给我们的<code>*</code>参数。</p>
<p>让我们看一个例子，这样我们就可以看到这一点。</p>
<p>我们将定义一个名为<code>mul</code>的函数，它将接受任意两个数字作为参数(有两个参数)，并将它们相乘。然后我们将使用<code>*args</code>重新定义它。</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div>

<p>这里我们可以这样调用函数，传递两个位置参数。记住这些是位置变量，因为在给参数赋值时，变量的位置很重要。</p>


<p>由于<code>5</code>在第一个位置，它被分配给<code>x</code>参数。</p>
<p>现在我们将使用<code>*args</code>来定义函数。该参数将收集任何没有分配给任何其他对象的位置参数，并将它们转换成一个值元组。现在我们必须这样做:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">mul</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></div>

<p>很少创建像上面这样的函数，因为<code>*args</code>的目的是接受任意数量的参数。因为我们正在访问<code>args[0]</code>和<code>args[1]</code>，这意味着我们真的想要<em>两个</em>参数。所以在那里用<code>*args</code>并不是正确的选择。</p>
<p>但是看看另一个函数，它接受任意数量的朋友名字并问候他们:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">multigreet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Hello, </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">!"</span><span class="p">)</span>

<span class="n">multigreet</span><span class="p">(</span><span class="s2">"Rolf"</span><span class="p">,</span> <span class="s2">"Bob"</span><span class="p">,</span> <span class="s2">"Anne"</span><span class="p">)</span>
</code></pre></div>

<p>试着自己调用这个函数，传递尽可能多的名字作为参数。</p>
<p>需要注意的一点是，当我们在循环中引用我们的参数时，我们使用名称<code>args</code>，而不是<code>*args</code>。永远记住这个<code>*</code>是一个运算符。</p>
<h3>风格注释</h3>
<p>正如我之前提到的，当我们想要收集多余的位置参数时，使用参数名<code>args</code>是一个惯例；然而，这并不总是正确的选择。</p>
<p>当参数可以是任何东西时，编写<code>*args</code>非常有用，但是在上面的函数中，我们非常清楚值代表什么:值应该都是名称。</p>
<p>在<code>multigreet</code>的情况下，因此用<code>*names</code>代替更合适，就像这样:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">multigreet</span><span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Hello, </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">!"</span><span class="p">)</span>
</code></pre></div>

<p>有更好的名字就不要用<code>*args</code>。请记住，变量名是帮助提高可读性的极好工具，所以请尽可能使用最具描述性的名称。</p>
<h2>参数顺序同<code>*args</code></h2>
<p>当我们使用像<code>*args</code>这样的参数时，我们必须非常清楚参数的顺序。这是因为我们在<code>*args</code>之后定义的任何参数都不能接受位置参数。</p>
<p>这有些道理。如果我们用我们的<code>*args</code>参数收集所有多余的位置参数，那么当我们到达它后面的参数时，什么都没有了。我们剩下的只有关键字参数。</p>
<p>例如，如果我们将我们的<code>multigreet</code>函数更改为下面的代码，并尝试调用它，</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">multigreet</span><span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Hello, </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">!"</span><span class="p">)</span>

<span class="n">multigreet</span><span class="p">(</span><span class="s2">"Jose"</span><span class="p">,</span> <span class="s2">"Phil"</span><span class="p">)</span>
</code></pre></div>

<p>我们得到一个<code>TypeError</code>。</p>
<div class="codehilite"><pre><span/><code><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"main.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">6</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">multigreet</span><span class="p">(</span><span class="s2">"Jose"</span><span class="p">,</span> <span class="s2">"Phil"</span><span class="p">)</span>
<span class="ne">TypeError</span><span class="p">:</span> <span class="n">multigreet</span><span class="p">()</span> <span class="n">missing</span> <span class="mi">1</span> <span class="n">required</span> <span class="n">keyword</span><span class="o">-</span><span class="n">only</span> <span class="n">argument</span><span class="p">:</span> <span class="s1">'other'</span>
</code></pre></div>

<p>在这种情况下，我们得到一个非常明确的信息。我们缺少了一个仅包含关键字的参数。</p>
<p>如果我们将<code>other</code>参数放在第一位，这个异常就会消失。Python非常乐意按顺序分配位置参数，然后为我们的<code>*names</code>参数收集剩下的内容。</p>
<p>在<code>*</code>参数后放置参数也非常有用，因为我们可以强迫用户对某些参数使用关键字参数。这对于我们不希望用户意外更改的内容，或者我们希望建立默认设置的内容非常有用。</p>
<p><code>print</code>实际上利用了仅接受关键字参数的<code>sep</code>和<code>end</code>。</p>
<h2>接受任意数量的关键字参数</h2>
<p>我们已经讨论了位置参数，现在是时候讨论如何处理任意数量的关键字参数了。如果你想要一个内置函数的例子，我们可以看看<code>dict</code>。</p>
<p>我们已经看到了一些调用<code>dict</code>的不同方法，但是我们还没有看到的一种方法是使用<code>dict</code>和关键字参数创建一个字典。</p>
<p>例如，我们可以这样写:</p>
<div class="codehilite"><pre><span/><code><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">"Phil"</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">29</span><span class="p">,</span> <span class="n">city</span><span class="o">=</span><span class="s2">"Budapest"</span><span class="p">,</span> <span class="n">nationality</span><span class="o">=</span><span class="s2">"British"</span><span class="p">)</span>
</code></pre></div>

<p>在这里，关键字变成了键，我们与每个关键字匹配的值变成了与这些键相关联的值。因此，上面的代码与下面的代码相同:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span>
    <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"Phil"</span><span class="p">,</span>
    <span class="s2">"age"</span><span class="p">:</span> <span class="mi">29</span><span class="p">,</span>
    <span class="s2">"city"</span><span class="p">:</span> <span class="s2">"Budapest"</span><span class="p">,</span>
    <span class="s2">"nationality"</span><span class="p">:</span> <span class="s2">"British"</span>
<span class="p">}</span>
</code></pre></div>

<p>不知道我们想要用多少键和值来创建我们的字典，所以它必须是灵活的，并且接受任意数量的关键字参数。</p>
<p>我们可以用另一个特殊的参数实现同样的事情，这次是在它的名字前面加上<code>**</code>。这个参数的常规名称是<code>**kwargs</code>，这是关键字参数的缩写。</p>
<p>看一下这个例子，它以一种很好的格式打印出关键字参数:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">pretty_print</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">pretty_print</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">"The Matrix"</span><span class="p">,</span> <span class="n">director</span><span class="o">=</span><span class="s2">"Wachowski"</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="mi">1999</span><span class="p">)</span>

<span class="c1"># title: The Matrix</span>
<span class="c1"># director: Wachowski</span>
<span class="c1"># year: 1999</span>
</code></pre></div>

<p>注意<code>**kwargs</code>收集所有未赋值的关键字参数，并用它们创建一个字典，然后可以在函数中使用。这就是为什么我们可以访问那里的<code>.items()</code>，因为<code>kwargs</code>是一本字典。</p>
<p>如果我们为一个给定的函数定义了<code>*args</code>和<code>**kwargs</code>，<code>**kwargs</code>必须排在第二位。如果顺序颠倒了，Python认为这是无效的语法。</p>
<p>实际上，<code>**kwargs</code>必须是您定义的最后一个参数，因为它必须跟在<code>*args</code>以及任何其他关键字参数之后。毕竟，它会收集所有剩余的关键字参数，所以它后面的任何参数都不会被赋值。</p>
<h3>风格注释</h3>
<p>就像用<code>*args</code>一样，我们在使用<code>**kwargs</code>的时候也不应该被约定俗成所束缚。如果我们知道预期的数据，并且我们可以用另一个名称更有效地描述它，那么您肯定应该这样做。</p>
<p>这种约定存在于定义函数时参数完全未知的情况下。</p>
<h2><code>*</code>和<code>**</code>的其他用途</h2>
<p><code>*</code>和<code>**</code>操作符非常通用，因为我们不仅可以用它们将值收集到一个集合中，我们还可以用它们来做相反的事情:将一个iterable解包为单个值。</p>
<p>我们已经在第9天看到了解包(也称为析构)，但是我们总是在给固定数量的变量赋值的上下文中这样做。在这些情况下，我们只需将iterable提供的值与相同数量的变量进行匹配，剩下的由Python处理。</p>
<p>然而，有时这种方法并不总是可行的。例如，如果我们想要析构一个iterable，这样我们就可以将许多值传递给<code>*args</code>？</p>
<p>答案是我们在作为参数传递的iterable前面加了一个<code>*</code>。</p>
<p>例如，假设我想获取这个数字列表，并在一行中打印这些数字，在每个数字之间使用竖线(<code>|</code>)字符。我们可以这样做:</p>
<div class="codehilite"><pre><span/><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">numbers</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">" | "</span><span class="p">)</span>
</code></pre></div>

<p>如果我们运行这段代码，我们会得到以下输出:</p>


<p>如果我们想析构一个字典，我们可以做同样的事情，但是记住默认情况下，当我们迭代一个字典时，Python会给我们键。因此，在使用<code>*</code>时，你经常需要使用<code>values</code>或<code>items</code>方法。</p>
<p>例如，此函数打印一部电影的详细信息:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">print_movie</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="n">movie</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"title"</span><span class="p">:</span> <span class="s2">"The Matrix"</span><span class="p">,</span>
    <span class="s2">"director"</span><span class="p">:</span> <span class="s2">"Wachowski"</span><span class="p">,</span>
    <span class="s2">"year"</span><span class="p">:</span> <span class="mi">1999</span>
<span class="p">}</span>

<span class="n">print_movie</span><span class="p">(</span><span class="o">*</span><span class="n">movie</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

<span class="c1"># The Matrix</span>
<span class="c1"># Wachowski</span>
<span class="c1"># 1999</span>
</code></pre></div>

<p>这个函数实际上是打印它接收到的参数，每行一个。例如，如果我们传入<code>movie.keys()</code>,它将打印键:</p>
<div class="codehilite"><pre><span/><code><span class="n">print_movie</span><span class="p">(</span><span class="o">*</span><span class="n">movie</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<span class="c1"># title</span>
<span class="c1"># director</span>
<span class="c1"># year</span>
</code></pre></div>

<p>没那么有用！</p>
<p>我们还可以使用<code>**</code>将字典转换成一系列关键字参数。</p>
<p>将上面的函数与<code>**kwargs</code>和字典析构一起使用，我们得到:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">print_movie</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">movie</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"title"</span><span class="p">:</span> <span class="s2">"The Matrix"</span><span class="p">,</span>
    <span class="s2">"director"</span><span class="p">:</span> <span class="s2">"Wachowski"</span><span class="p">,</span>
    <span class="s2">"year"</span><span class="p">:</span> <span class="mi">1999</span>
<span class="p">}</span>

<span class="n">print_movie</span><span class="p">(</span><span class="o">**</span><span class="n">movie</span><span class="p">)</span>

<span class="c1"># title: The Matrix</span>
<span class="c1"># director: Wachowski</span>
<span class="c1"># year: 1999</span>
</code></pre></div>

<p>这里，当我们调用函数时，它把字典变成关键字参数。这些被传递给<code>print_movie</code>,<code>**kwargs</code>参数将它们收集回一个字典中。</p>
<p>你也可以这样做:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">print_movie</span><span class="p">(</span><span class="n">movie_details</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">movie_details</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">movie</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"title"</span><span class="p">:</span> <span class="s2">"The Matrix"</span><span class="p">,</span>
    <span class="s2">"director"</span><span class="p">:</span> <span class="s2">"Wachowski"</span><span class="p">,</span>
    <span class="s2">"year"</span><span class="p">:</span> <span class="mi">1999</span>
<span class="p">}</span>

<span class="n">print_movie</span><span class="p">(</span><span class="n">movie</span><span class="p">)</span>

<span class="c1"># title: The Matrix</span>
<span class="c1"># director: Wachowski</span>
<span class="c1"># year: 1999</span>
</code></pre></div>

<p>这是有效的，但是在收集未赋值的关键字参数时,<code>**kwargs</code>可以给我们更多的灵活性，而不仅仅是那些来自字典的参数。</p>
<p>例如，我们可以这样做:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">print_movie</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">movie</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"title"</span><span class="p">:</span> <span class="s2">"The Matrix"</span><span class="p">,</span>
    <span class="s2">"director"</span><span class="p">:</span> <span class="s2">"Wachowski"</span><span class="p">,</span>
    <span class="s2">"year"</span><span class="p">:</span> <span class="mi">1999</span>
<span class="p">}</span>

<span class="n">print_movie</span><span class="p">(</span><span class="n">studio</span><span class="o">=</span><span class="s2">"Warner Bros"</span><span class="p">,</span> <span class="o">**</span><span class="n">movie</span><span class="p">)</span>

<span class="c1"># studio: Warner Bros</span>
<span class="c1"># title: The Matrix</span>
<span class="c1"># director: Wachowski</span>
<span class="c1"># year: 1999</span>
</code></pre></div>

<p>在那里，我们使用了<code>**kwargs</code>来收集<code>studio</code>参数以及所有的<code>movie</code>参数！这不是我们只用一个参数就能轻易做到的。</p>
<p>像这样的技术还有很多其他用途，包括合并字典，以及在使用<code>format</code>时节省我们大量的打字时间。</p>
<p>例如，让我们回头看一个来自<a href="/30-days-of-python/python-30-day-14-project-regular/"> day 14 project </a>的例子，我们需要从字典列表中打印一些关于我们的书籍的输出。</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">show_books</span><span class="p">(</span><span class="n">books</span><span class="p">):</span>
    <span class="c1"># Adds an empty line before the output</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">book</span> <span class="ow">in</span> <span class="n">books</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">book</span><span class="p">[</span><span class="s1">'title'</span><span class="p">]</span><span class="si">}</span><span class="s2">, by </span><span class="si">{</span><span class="n">book</span><span class="p">[</span><span class="s1">'author'</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">book</span><span class="p">[</span><span class="s1">'year'</span><span class="p">]</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">()</span>
</code></pre></div>

<p>我们可以使用带有命名占位符的<code>format</code>方法，而不是在这里使用f字符串。然后我们可以将<code>**book</code>传递给<code>format</code>。</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">show_books</span><span class="p">(</span><span class="n">books</span><span class="p">):</span>
    <span class="c1"># Adds an empty line before the output</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">book</span> <span class="ow">in</span> <span class="n">books</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="si">{title}</span><span class="s2">, by </span><span class="si">{author}</span><span class="s2"> (</span><span class="si">{year}</span><span class="s2">)"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">book</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">()</span>
</code></pre></div>

<p>这将为每本书创建一系列关键字参数，如下所示:</p>
<div class="codehilite"><pre><span/><code><span class="n">title</span><span class="o">=</span><span class="s2">"1Q84"</span><span class="p">,</span> <span class="n">author</span><span class="o">=</span><span class="s2">"Haruki Murakami"</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="s2">"2004"</span>
</code></pre></div>

<p>这种方法的好处之一是我们可以在其他地方定义模板，这也意味着我们可以在代码的多个地方引用它。</p>
<div class="codehilite"><pre><span/><code><span class="n">book_template</span> <span class="o">=</span> <span class="s2">"</span><span class="si">{title}</span><span class="s2">, by </span><span class="si">{author}</span><span class="s2"> (</span><span class="si">{year}</span><span class="s2">)"</span>

<span class="k">def</span> <span class="nf">show_books</span><span class="p">(</span><span class="n">books</span><span class="p">):</span>
    <span class="c1"># Adds an empty line before the output</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">book</span> <span class="ow">in</span> <span class="n">books</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">book_template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">book</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">()</span>
</code></pre></div>

<p>您需要在字典中访问的键越多，它也会变得越来越有效。</p>
<h2>练习</h2>
<p>1)创建一个函数，该函数接受任意数量的数字作为位置参数，并打印这些数字的和。记住，我们可以使用<code>sum</code>函数将iterable中的值相加。</p>
<p>2)创建一个函数，它接受任意数量的位置和关键字参数，并将它们打印回给用户。您的输出应该指出哪些值是作为位置参数提供的，哪些是作为关键字参数提供的。</p>
<p>3)使用<code>format</code>方法和<code>**</code>拆包打印以下字典。</p>
<div class="codehilite"><pre><span/><code> <span class="n">country</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"Germany"</span><span class="p">,</span>
    <span class="s2">"population"</span><span class="p">:</span> <span class="s2">"83 million"</span><span class="p">,</span>
    <span class="s2">"capital"</span><span class="p">:</span> <span class="s2">"Berlin"</span><span class="p">,</span>
    <span class="s2">"currency"</span><span class="p">:</span> <span class="s2">"Euro"</span>
 <span class="p">}</span>
</code></pre></div>

<p>4)使用<code>*</code>拆包和<code>range</code>，打印数字<code>1</code>到<code>20</code>，用逗号分隔。在这个练习中，你必须为<code>print</code>函数的<code>sep</code>参数提供一个参数。</p>
<p>5)修改练习<code>4</code>中的代码，使每个数字打印在不同的行上。您只能使用一次<code>print</code>通话。</p>
<h2>额外资源</h2>
<p>我们有一个关于析构的<a href="https://blog.teclado.com/destructuring-in-python/">专用帖子，在那里我们讨论<code>*</code>的另一个用途，这次是在给变量赋值时收集值。</a></p> 
                </article>
            
            </div>    
</body>
</html>