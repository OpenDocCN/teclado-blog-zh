# Python 切片第 2 部分:深度切割

> 原文：<https://blog.teclado.com/python-slices-part-2/>

在这篇文章中，我们将对 Python 中的片段进行更深入的探究。如果您需要复习基础知识，请务必查看我们之前关于主题的[帖子！](https://blog.teclado.com/python-slices/)

事不宜迟，让我们直入主题吧。

## 切片分配

在上一篇文章中，我们谈了很多关于获取序列的一部分，但是实际上我们可以用片段做更多的事情。

我们可以做的一件有趣的事情是用新值替换序列的一部分。

```
numbers = [1, 3, 3]
numbers[1:2] = [2]

print(numbers)  # [1, 2, 3] 
```

这里我们取了`numbers`的一部分，它只包括索引 1 处的值。记住切片的停止指数是**不包括**。

然后我们用这个切片作为赋值的左边。当我们打印`numbers`时，我们可以看到它现在显示`[1, 2, 3]`,表明索引 1 处的`3`已经被替换。

值得注意的一件有趣的事情是，我们分配了另一个 iterable，而不仅仅是整数`2`。我们实际上可以在这里使用元组甚至集合来代替列表:

```
numbers[1:2] = (2,)  # Don't forget the comma!
numbers[1:2] = {2} 
```

然而，给一个整数赋值会引发一个`TypeError`。

```
TypeError: can only assign an iterable 
```

### 分配多个值

因为我们必须指定一些可迭代的类型，所以我们可以一次指定多个值。这完全正确:

```
numbers = [1, 3, 5]
numbers[1:3] = [2, 3]

print(numbers)  # [1, 2, 3] 
```

然而，可能会让您感到惊讶的是，我们可以为我们的切片分配一个不同长度的 iterable。

```
numbers = [1, 3, 5]
numbers[1:3] = [2, 3, 4, 5]

print(numbers) # [1, 2, 3, 4, 5] 
```

实际上，iterable 包含多少项并没有什么区别:我们甚至可以将一个空列表分配给某个片，而不会出现问题。在我们的切片中定义的索引项被简单地删除。

```
numbers[1:3] = [] 
```

### 零长度切片

我们还可以用其他方式利用不平均分配。例如，我们可以取一个空的切片，用它在某个序列的中间插入值。

```
numbers = [1, 5]
numbers[1:1] = [2, 3, 4]

print(numbers)  # [1, 2, 3, 4, 5] 
```

记住像`[1:1]`这样的切片是完全有效的，但是完全是空的。它从索引 1 开始，到索引 1 结束，但是停止值不包含在内，所以索引 1 处的值不是切片的一部分。

因此，像这样的切片允许我们在给定的索引处插入值，而不删除序列中的任何值。

### 扩展切片和赋值

在上一篇文章中，我们讨论了使用步长值的扩展切片。我们仍然可以在这种类型的片上执行赋值，但是有一个警告。不幸的是，如果我们指定除了缺省值`1`之外的任何步长值，我们就不能使用上面提到的非对称赋值。这包括一个`-1`的步骤。

因此，当我们使用扩展切片语法时，我们需要小心匹配我们想要替换的值的数量。

```
numbers = [1, 3, 3, 5, 5]
numbers[1:4:2] = [2, 4]

print(numbers)  # [1, 2, 3, 4, 5] 
```

上面的例子工作得很好，因为我们将`2`分配给索引 1，将`4`分配给索引 3。一切都吻合。

```
numbers = [1, 3, 3, 5, 5]
numbers[1:3:2] = [2, 4]

print(numbers)  # ValueError 
```

另一方面，第二个例子产生了一个`ValueError`:

```
ValueError: attempt to assign sequence of size 2 to extended slice 
```

## 切片对象和 **`__getitem__`**

当我们第一次开始谈论切片时，我们从介绍切片对象和`slice(1, 2)`语法开始。在继续使用我们在上面的例子中使用的简写之前，我们用了一会儿。

实际上，我们已经看到了获取某个序列片段的多种方法:

```
numbers = [1, 2, 3]
new_slice = slice(1, 3)

a = numbers[new_slice]
b = numbers[slice(1, 3)]
c = numbers[1:3] 
```

这些在功能上完全相同。如果我们打印`a`、`b`或`c`中的任何一个，我们会将`[2, 3]`打印到控制台。

然而，这种方括号语法只是为了方便。实际情况是这样的:

```
d = numbers.__getitem__(slice(1, 3))

print(d)  # [2, 3] 
```

看起来有点神秘的`__getitem__`是 Python 的许多特殊方法之一，通常被称为“dunder”(双下划线)方法。

有趣的是，我们可以在自己的类中使用这些特殊的方法，这意味着我们也可以为自己的自定义类型提供切片支持。

实际上接受的不仅仅是切片。我们还可以向`__getitem__`传递一个单一的索引，这正是我们做类似下面这样的事情时所发生的:`numbers[0]`。

```
numbers = [1, 2, 3, 4, 5]

print(numbers[2])  # 3
print(numbers.__getitem__(2))  # 3 
```

`__getitem__`也有一个对应的名称为`__setitem__`，当我们进行片赋值时，或者当我们试图用单个索引的下标符号替换给定索引处的值时，就会调用这个名称:

```
numbers = [1, 2, 3, "hello", 5]
numbers[3] = 4  # numbers.__setitem__(3, 4)

print(numbers)  # [1, 2, 3, 4, 5] 
```

特殊方法是一个很大且相对高级的主题，所以如果您在这一点上有点困惑，请不要担心。特殊方法将在未来的博客文章中得到适当的特殊对待，所以如果你有兴趣了解更多，请留下来！

## 概述

*   除了使用切片从序列中获取一定范围的值，我们还可以在赋值操作中使用切片替换序列中的值。
*   当使用 slice 赋值时，我们必须使用 iterable 类型。这可以是从列表和元组到集合的任何东西。
*   切片分配可以是不对称的:切片的长度可以不同于我们想要分配的 iterable 对象的长度。
*   我们可以通过在相同的索引处指定开始和停止值来定义零长度的切片。我们可以使用一个空切片在给定的索引处插入任意数量的值。
*   当使用扩展切片时，除了`1`之外的任何步长值都会对切片赋值施加一些警告。当使用不同的步长时，我们分配的项目数必须与切片中的项目数相匹配。
*   我们用于切片的下标符号实际上是对`__getitem__`和`__setitem__`特殊方法的简写。这非常有用，因为这意味着我们可以为自己的自定义类型定义切片行为。

我希望你学到了新的东西，如果你想进一步提升你的 Python 技能，你可能想看看我们的[完整 Python 课程](https://www.udemy.com/the-complete-python-course/?couponCode=BLOGGER)。