# Python 中的析构

> 原文：<https://blog.teclado.com/destructuring-in-python/>

在本周的帖子中，我们将会看到一个非常有趣和通用的工具，叫做析构。析构(也称为解包)是我们获取一个集合，比如一个列表或一个元组，并将其分解为单个值。这非常有用，因为它使我们能够做像析构赋值这样的事情，我们可以从一个集合中一次给几个变量赋值。

## 标准析构赋值

像许多编程语言一样，Python 允许我们在一行中一次分配多个变量。我们只需要在赋值两边提供相同数量的值。例如:

```py
x, y = 5, 11 
```

这里我们将值`5`赋给`x`，将`11`赋给`y`。值的赋值完全基于顺序，所以如果我们改变变量的顺序，或者我们打算赋值的值的顺序，我们将得到不同的结果。

这是如何工作的非常简单，但是不太明显的是这是一个析构的例子。如果我这样写呢？

```py
x, y = (5, 11) 
```

很多新的 Python 程序员没有意识到的一件事是，括号和元组没有任何关系。事实上，是逗号告诉 Python 某个东西是一个元组:在很多情况下，我们只是为了可读性而添加了括号。在某些情况下，为了将元组从它周围的语法中分离出来，括号实际上是必要的，例如当我们将元组放在列表中时。然而，在这种情况下，括号仍然不是元组语法的一部分。给一个数字加括号并不会把它变成一个元组。

记住所有这些，我们实际上在上面的例子中结束了对一个元组的析构，将元组`(5, 11)`拆分成它的组成值，这样我们就可以将这些值绑定到两个变量名。

这里我们不仅仅局限于元组。例如，我们也可以析构一个列表，甚至一个集合。然而，你不太可能想要对一个集合执行一个析构赋值，因为顺序没有保证，因此我们最终得到的是我们并不真正知道其值的变量。

如果我们试图用比我们提供的变量更多或更少的值来析构一个集合，我们最终会得到一个`ValueError`。

```py
ValueError: not enough values to unpack (expected 4, got 3) 
```

## 在`for`循环中析构

几个月前，我们在`enumerate`上写了一个[片段 post](https://blog.teclado.com/python-enumerate/) ，这是编写好的 Pythonic 循环的重要组成部分。如果你不熟悉的话，`enumerate`的语法是这样的:

```py
example_list = ["A", "B", "C"]

for counter, letter in enumerate(example_list):
	print(counter, letter)

# 0 A
# 1 B
# 2 C 
```

`enumerate`将 iterable 集合作为参数，并返回一个 enumerate 对象，该对象包含集合中每一项的元组。每个元组包含一个计数器值，该值随着每次迭代而递增，同时还包含所提供集合中的一个值。

正如你在上面的例子中看到的，我们在创建我们的`for`循环时提供了两个变量名:`counter`和`letter`。这实际上是一个非常常见的析构例子。对于枚举对象中的每个元组，第一个值被赋给`counter`，第二个值被赋给`letter`。

同样，变量名没有任何魔力，赋值完全基于值的顺序。如果我们要交换`counter`和`letter`的位置，我们最终会得到一些令人困惑的变量名。

我们可以用任意多的值来进行这种类型的破坏，这并不局限于`enumerate`函数。例如，我们可以这样做:

```py
people = [
	("Bob", 42, "Mechanic"),
	("James", 24, "Artist"),
	("Harry", 32, "Lecturer")
]

for name, age, profession in people:
	print(f"Name: {name}, Age: {age}, Profession: {profession}") 
```

这里我们将`people`列表中的每个元组分开，分别给`name`、`age`和`profession`赋值。

这比下面的代码好得多，在下面的代码中，我们依赖于索引而不是好的描述性名称:

```py
for person in people:
	print(f"Name: {person[0]}, Age: {person[1]}, Profession: {person[2]}") 
```

核心 Python 开发者之一 Raymond Hettinger 在他的一次演讲中说了一些让我印象深刻的话。他说，在 Python 中，基本上不应该通过索引来引用项目:几乎总是有更好的方法。

析构就是一个很好的例子。

## 忽略值

那么，如果我们有一个值的集合，但我们不想给它们赋值，我们该怎么办呢？我们可以用一个`_`来代替变量名。

例如，如果我们从上面的`people`列表中取出一个元组，并且我们只关心姓名和职业，我们可以做以下事情:

```py
person = ("Bob", 42, "Mechanic")
name, _, profession = person

print(name, profession)  # Bob Mechanic 
```

这在循环内部也同样适用，并且当我们不关心值的任何 T2 时也可以使用。一个例子可能是使用`range`来确保一组迭代次数。

```py
for _ in range(10):
	<do something> 
```

## 使用`*`收集值

在某些情况下，我们可能希望隔离集合中的一两个值，然后将其他项放在一起。我们在列表循环中的[帖子中展示了一个类似这样的例子。](https://blog.teclado.com/coding-interview-problems-rotating-a-list/)

在 Python 中，当执行析构赋值时，我们可以使用`*`操作符来收集剩余的值。例如，我们可能有一个数字列表，我们希望获取第一个数字，然后将剩余的数字赋给第二个变量:

```py
head, *tail = [1, 2, 3, 4, 5]

print(head)  # 1
print(tail)  # [2, 3, 4, 5] 
```

在这里，第一个值(`1`)被分配给`head`，而其余的数字则存放在一个名为`tail`的新列表中。

我们也可以反过来这样做，创建一个除了最后一个值以外的所有内容的新列表，并将最后一个值赋给它自己的变量。

```py
*head, tail = [1, 2, 3, 4, 5]

print(head)  # [1, 2, 3, 4]
print(tail)  # 5 
```

这很有意思，但是除非我们需要保存原始列表，否则我们已经有了类似这样的`pop`方法。然而，我们可以用这个语法做些别的事情。我们可以给*分配任意数量的*变量，然后收集剩余的变量。我们可能会抓取第一个和最后一个项目，然后收集中间的项目，例如:

```py
head, *middle, tail = [1, 2, 3, 4, 5]

print(head)    # 1
print(middle)  # [2, 3, 4]
print(tail)    # 5 
```

或者，我们可能希望获取前三个项目，然后将其余项目捆绑在一起:

```py
first, second, third, *rest = [1, 2, 3, 4, 5] 
```

有无数的可能性。

## 包扎

我希望你能从这篇关于 Python 析构的短文中学到一些新东西！

这实际上并不是故事的结尾，因为还有使用`*`和`**`打包和解包集合的方法，但是我认为这些内容应该有一个自己的帖子来公正地处理这个主题。

如果你正在学习 Python，并且对这类内容感兴趣，一定要在 [Twitter](https://twitter.com/TecladoCode) 上关注我们，或者注册我们的邮件列表，以获得所有最新内容。如果你感兴趣，在这一页的底部有一个表格。

我们也刚刚对我们的[完整 Python 课程](https://go.tecla.do/complete-python-sale)进行了一次大的更新，所以如果你有兴趣达到 Python 的高级水平，可以去看看。我们有一个 30 天的退款保证，所以你真的没有什么损失，尝试一下。我们很希望你能来！