<html>
<head>
<title>Build a blog platform with Flask: writing and showing posts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Flask构建博客平台:写文章和展示文章</h1>
<blockquote>原文：<a href="https://blog.teclado.com/build-own-blog-platform-flask-python-part-1/">https://blog.teclado.com/build-own-blog-platform-flask-python-part-1/</a></blockquote><div><div class="post-content">
<p>在这个系列中，我们将使用Flask和PostgreSQL来构建一个博客平台。我们将添加用户和身份验证、评论、标记，并使用AWS处理我们的应用程序的部署。</p>
<p>我正在为我的学生写这一系列的博客文章，他们正在学习Flask和web开发，并且想继续一个更全面的项目。</p>
<p>如果您对Flask、Python或web开发完全陌生，这可能不适合您！</p>
<p>在本帖中，我们将从以下内容开始:</p>
<ul>
<li>设置Flask应用程序</li>
<li>设置数据库</li>
<li>创建帖子</li>
<li>显示帖子</li>
</ul>
<p>为此，我们将使用:</p>
<ul>
<li>计算机编程语言</li>
<li>一种数据库系统</li>
<li>HTML(还没有CSS！)</li>
<li>和一些Python库:<ul>
<li>烧瓶(和金贾)</li>
<li>SQLModel</li>
</ul>
</li>
</ul>
<h2 id="installtherequireddependenciesforthispost">安装此帖子所需的依赖项</h2>
<p>在整个应用程序中，我们将使用几个不同的库，但在本文中，我们只需要安装两个:</p>
<pre><code>pip install flask
pip install sqlmodel
</code></pre>
<h2 id="setupaflaskappusingthefactorypattern">使用工厂模式设置烧瓶应用程序</h2>
<p>Flask中的工厂模式允许我们推迟创建<code>Flask</code>对象，直到我们调用创建它的函数。</p>
<p>这很有帮助，因为我们可以很容易地自己调用函数来创建<code>Flask</code>对象，并且我们可以在这样做的时候传递配置参数。当我们开始测试应用程序时，这将派上用场，因为在我们的测试中，我们可能希望将不同的配置传递给应用程序，而不是在生产中。</p>
<p>这是我们创建Flask应用程序的方式:</p>
<pre><code class="language-py">from flask import Flask


def create_app():
    app = Flask(__name__)

    return app
</code></pre>
<p>我们只需在终端输入<code>flask run</code>就可以运行这个应用程序。Flask命令行界面将看到一个名为<code>create_app</code>的函数存在，将运行它来获取我们的Flask应用程序。它只适用于这个函数名，因为这是Flask应用程序的约定。</p>
<h2 id="createaflaskblueprintforourpostroutes">为我们的邮政路线创建一个烧瓶蓝图</h2>
<p>随着应用程序开始增长，就像我们的应用程序一样，将路线定义分成多个文件是有意义的。我们经常使用蓝图来帮助解决这个问题。</p>
<p>让我们创建一个<code>routes/post.py</code>文件。在里面，我们将定义我们的蓝图:</p>
<pre><code class="language-py">from flask import Blueprint, request

post_pages = Blueprint("posts", __name__)


@post_pages.get("/post/&lt;string:title&gt;")
def display_post(title: str):
    return "Display post page."


@post_pages.route("/post/", methods=["GET", "POST"])
def create_post():
    if request.method == "POST":
        pass
    return "Create post page."
</code></pre>
<p>为了定义我们的蓝图，我们传递了两个参数:</p>
<ul>
<li><code>name</code>，它由<code>url_for</code>函数使用，因此我们可以获得端点。稍后将详细介绍。</li>
<li><code>import_name</code>，通常是<code>__name__</code>，用来告诉Flask蓝图相对于应用程序根路径的位置。</li>
</ul>
<p>我们可以传递许多其他参数，但是其他参数的默认值是我们想要的。</p>
<p>我们定义了两条路由或端点:</p>
<ul>
<li><code>/post/</code>，我们将使用它来:<ul>
<li>显示用户可以提交以创建帖子的表单</li>
<li>当用户提交表单时，接受表单数据，并在我们的数据库中创建帖子</li>
</ul>
</li>
<li><code>/post/&lt;string:title&gt;</code>，接收帖子标题并显示帖子页面</li>
</ul>
<p>目前，两个端点都做得很少:只是显示一个字符串，告诉我们访问了什么路由。</p>
<p>请注意，<code>/post/</code>路由中有一些逻辑，如果<code>request.method == "POST"</code>发生错误，它会做一些事情。我们将使用请求方法来决定要做什么:如果是POST，我们将获取表单数据，如果是get，我们将显示表单页面。</p>
<h2 id="registertheblueprintwithourflaskapp">用我们的Flask应用程序注册蓝图</h2>
<p>如果我们现在运行Flask应用程序，它仍然不能做任何事情。那是因为蓝图和app没有链接。</p>
<p>我们需要注册蓝图，以便Flask应用程序可以访问它的路线，并且我们可以从我们的浏览器向它们发出请求。</p>
<p>为此，我们只需在应用程序中导入蓝图，并注册它:</p>
<pre><code class="language-diff">from flask import Flask
+from routes.post import post_pages


def create_app():
    app = Flask(__name__)
+   app.register_blueprint(post_pages)

    return app
</code></pre>
<p>现在，如果我们用<code>flask run</code>运行应用程序，端点将会工作！</p>
<h2 id="createtheformtemplatetoaddnewposts">创建表单模板以添加新帖子</h2>
<p>用Flask和Jinja创建表单有很多方法，从自己用普通的HTML编码，到使用Jinja宏，甚至像Flask-WTF这样的库。</p>
<p>当您的应用程序变得有点大或者您需要表单的安全性时，我推荐使用Flask-WTF。因为这个应用程序中提交的表单不是很重要，所以我们可以不要它。</p>
<p>我将只使用HTML对表单进行编码。</p>
<p>我已经创建了一个<code>templates</code>文件夹，在里面我将放置<code>new_post.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;New Post&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form method="POST"&gt;
    &lt;label for="title"&gt;Title:&lt;/label&gt;
    &lt;input type="text" name="title" id="title" /&gt;

    &lt;label for="content"&gt;Content: &lt;/label&gt;
    &lt;textarea name="content" id="content"&gt;&lt;/textarea&gt;
    
    &lt;input type="submit" value="Create post" /&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>我暂时保持简单。稍后当我们想给表单添加样式时，我们需要做一些改变。</p>
<p>这里的很多HTML都是样板文件。在<code>body</code>中，我们有一个<code>form</code>元素，它使用一个<code>POST</code>请求将数据发送到当前页面。</p>
<p>在表单中，我们有两个字段:<code>title</code>文本和<code>content</code>文本区域。</p>
<p>所有这些意味着当我们使用浏览器访问<code>/post/</code>时，我们将显示这个表单。当我们提交表单时，这两个字段的内容将作为一个<code>POST</code>请求提交给<code>/post/</code>端点。</p>
<p>在提交表单数据时会用到每个字段的<code>name</code>属性，所以提交结果会是这样的:<code>title=TITLE_TEXT&amp;content=CONTENT_TEXT</code>。</p>
<p>让我们转到Flask端点，处理呈现模板和获取表单数据:</p>
<pre><code class="language-py">
from flask import Blueprint, render_template, redirect, url_for, request # New imports added

...

@post_pages.route("/post/", methods=["GET", "POST"])
def create_post():
    if request.method == "POST":
        title = request.form.get("title")
        content = request.form.get("content")
        # TODO: We can create the post in our database here
        return redirect(url_for(".display_post", title=title))
    return render_template("new_post.html")
</code></pre>
<p>我留下了一个“TODO”注释，因为我们仍然需要处理那里的数据库交互。现在，我们获取表单内容并重定向到另一个端点，将接收到的标题作为参数传递。</p>
<p>作为对<code>url_for</code>的一个参数，我们传递了<code>".display_post"</code>，这将计算当前蓝图中<code>display_post</code>函数<em>的URL(这就是<code>.</code>的意思)。</em></p>
<h2 id="displaypostsusingajinjatemplate">使用Jinja模板显示帖子</h2>
<p>虽然我们在<code>new_post.html</code>文件中使用了一个“模板”,但我们实际上并没有在那里编写任何Jinja代码。从技术上讲，它并不是一个真正的模板。这只是我们发送给客户的一个HTML文件。</p>
<p>让我们使用Jinja来显示帖子。我将创建一个<code>templates/post.html</code>文件:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;{{ title }}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;article&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
    &lt;p&gt;{{ content }}&lt;/p&gt;
  &lt;/article&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>再说一次，就目前而言，这很简单。只是一个带有标题(<code>h1</code>)和内容(<code>p</code>)的<code>article</code>元素。稍后，当我们使用markdown时，我们将从Flask获取HTML格式的文章内容，并将它直接插入到模板中。</p>
<p>在我们的Flask应用程序中，我们所要做的就是获取文章标题和内容，并将其传递给我们的<code>render_template</code>调用:</p>
<pre><code class="language-py">@post_pages.get("/post/&lt;string:title&gt;")
def display_post(title):
    content = "..." # How do we get the content?
    return render_template("post.html", title=title, content=content)
</code></pre>
<p>在这个端点中，我们有文章标题，所以我们可以将它传递给模板。不过，我们还无法访问帖子内容。</p>
<p>在我们能够访问帖子内容(以及关于帖子的任何其他信息，如发布日期)之前，我们需要一个数据库。</p>
<p>顺便提一下，语法<code>@post_pages.get(...)</code>是Flask 2.0中的新内容。如果你以前没看过，看看<a href="https://github.com/pallets/flask/pull/3907">这个链接</a>！</p>
<h2 id="createasqlmodelmodeltodefinethedatabasetable">创建一个SQLModel模型来定义数据库表</h2>
<p>我们将使用SQLModel库，它本身使用SQLAlchemy和Pydantic。有了这个库，我们可以定义一个类作为数据库表定义。</p>
<p>我将制作<code>models/post.py</code>，并编写以下代码:</p>
<pre><code class="language-py">from typing import Optional
from datetime import datetime
from sqlmodel import Field, SQLModel


class Post(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    title: str
    content: str
    publish_date: datetime = Field(default_factory=datetime.today)
</code></pre>
<p>这告诉SQLAlchemy创建一个有4列的<code>post</code>表:</p>
<ul>
<li><code>id</code>，将是主键，自动生成。</li>
<li><code>title</code>，一个非空的，长度不限的<code>VARCHAR</code>。</li>
<li><code>content</code>，一个非空的，长度不限的<code>VARCHAR</code>。</li>
<li><code>publish_date</code>，一个<code>DATETIME</code>，当我们在Python中创建一个<code>Post</code>对象时，它将获得<code>datetime.today()</code>的值。</li>
</ul>
<p>这样我们就定义了我们的表，我们将得到一个为我们填充的发布日期。不错！</p>
<p>让我们在蓝图中使用这个模型。非常简单！</p>
<h3 id="connecttothedatabaseusingsqlmodel">使用SQLModel连接到数据库</h3>
<p>让我们从SQLModel运行<code>create_engine</code>来实际连接到数据库，并给我们一些我们可以用来与之交互的东西。</p>
<p>我们来看一下<code>app.py</code>:</p>
<pre><code class="language-diff">+from sqlmodel import SQLModel, create_engine
+from models.post import Post

def create_app():
    app = Flask(__name__)
+   app.engine = create_engine("sqlite:///database.db")
</code></pre>
<p>现在我们已经得到了，我们必须使用<code>app.engine</code>来创建我们的表。我发现的最好方法是在处理任何请求之前确保该表存在。在注册蓝图之前，我将添加以下内容:</p>
<pre><code class="language-py">@app.before_first_request
def create_db():
    SQLModel.metadata.create_all(app.engine)
</code></pre>
<p>重要的是，在之前<em>，我们已经导入了<code>Post</code>模型。否则SQLModel不知道要创建什么表。</em></p>
<h3 id="usesqlmodeltoaddpoststothedatabase">使用SQLModel向数据库添加帖子</h3>
<p>现在我们已经得到了这些，我们可以转到我们的蓝图，利用那里的<code>engine</code>变量，以及SQLModel的<code>Session</code>，与数据库进行交互。</p>
<p>我们需要一些新的进口商品:</p>
<pre><code class="language-py">from flask import current_app  # Add this to the existing flask imports
from sqlmodel import Session, select
from models.post import Post
</code></pre>
<p>让我们从添加帖子开始:</p>
<pre><code class="language-py">@post_pages.route("/post/", methods=["GET", "POST"])
def create_post():
    if request.method == "POST":
        title = request.form.get("title")
        content = request.form.get("content")
        with Session(current_app.engine) as session:
            session.add(Post(title=title, content=content))
            session.commit()
        return redirect(url_for("display_post", title=title))
    return render_template("new_post.html")
</code></pre>
<p>这里的新代码是:</p>
<pre><code class="language-py">with Session(current_app.engine) as session:
    session.add(Post(title=title, content=content))
    session.commit()
</code></pre>
<p>我们首先创建一个会话，给它我们想要使用的引擎。</p>
<p>然后，数据库会话允许我们调用多个数据库交互。这里我们只做一个:<code>session.add()</code>。我们可以做得更多，当我们做<code>session.commit()</code>时，他们都会跑。</p>
<p>这意味着，如果我们想一次添加大量数据，速度会更快，因为我们不必每次都保存到数据库磁盘。它只在提交时发生。</p>
<p>注意，我们添加到<code>session</code>中的不是一些SQL代码，而是一个<code>Post</code>模型对象。SQLModel会负责将其转换成适当的SQL查询！</p>
<h3 id="retrievepostsfromthedatabaseusingsqlmodel">使用SQLModel从数据库中检索帖子</h3>
<p>我们可以在我们的<code>display_post</code>端点中做类似的事情，使用SQLModel的<code>select</code>函数从数据库中获取数据:</p>
<pre><code class="language-py">@post_pages.get("/post/&lt;string:title&gt;")
def display_post(title):
    with Session(current_app.engine) as session:
        statement = select(Post).where(Post.title == title)
        post = session.exec(statement).first()
        return render_template("post.html", title=title, content=post.content)
</code></pre>
<p>这里，我们再次创建一个会话，然后用它来获取与所提供的标题相匹配的文章。</p>
<p><code>statement</code>保存SQL查询，但是直到我们用<code>session.exec()</code>执行它，它才真正运行。</p>
<p>在结果集中运行<code>.first()</code>,只返回第一行。在这里，我们期望只有一个职位匹配提供的标题。</p>
<p>我将<code>render_template</code>调用放在上下文管理器中，因为如果任何事情失败，我们将没有任何数据可以显示。如果数据库连接出现任何问题，我们可以将它封装在一些错误处理中并显示一个不同的模板。</p>
<h2 id="nextsteps">后续步骤</h2>
<p>我们在这个帖子里做了很多！我们有:</p>
<ul>
<li>设置我们的应用程序。</li>
<li>使用SQLModel设置我们的SQLite数据库。</li>
<li>创建了我们的第一个非风格模板。</li>
<li>增加了创建和显示文章的蓝图。</li>
</ul>
<p>在本系列的下一篇文章中，我们将处理用户认证，这样我们就可以注册用户，因为我们需要这个系统的<em>作者</em>和<em>评论</em>部分。</p>
<p>如果你喜欢这篇文章，并且想学习更多关于使用Python进行web开发的知识，考虑加入我们的<a href="https://go.tecla.do/web-dev-course-sale"> Web开发者训练营，使用Flask和Python </a>。这是一个完整的视频课程，指导您构建多个项目！</p>

</div>
</div>    
</body>
</html>