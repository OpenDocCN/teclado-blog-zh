<html>
<head>
<title>Introduction to unit testing with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python单元测试简介</h1>
<blockquote>原文：<a href="https://blog.teclado.com/introduction-to-unit-testing-with-python/">https://blog.teclado.com/introduction-to-unit-testing-with-python/</a></blockquote><div><div class="post-content">
<p>测试是软件开发的重要部分。主要目的有两个:</p><ol><li>好的测试明确地描述了他们测试的东西是做什么的；和</li><li>好的测试确保他们测试的东西随着时间的推移符合描述。</li></ol><p>例如，假设你有一个函数，你想确保它按照你认为应该的方式工作。类似于这个反转列表的函数(<a href="https://blog.teclado.com/coding-interview-problems-reversing-a-list-python/">来自我们之前的一篇博文</a>):</p><pre><code class="language-python">def reverse_list(original: List):
	return original[::-1]
</code></pre>
<p>尽管这是一个简单的函数，但您可能会对它提出许多问题:</p><ul><li>它是否反转一个非零元素数的列表？</li><li>它是否反转了包含不同类型元素的列表？</li><li>它对空列表有效吗？</li><li>它是处理字符串和其他序列，还是只处理列表？</li><li>它是就地修改列表还是给你一个新的列表？</li><li>它对有重复条目的列表有效吗？</li></ul><p>你可能已经知道了所有这些问题的答案(或者你可以通过启动一个REPL并进行测试来轻松找到答案)。但是请记住，测试的目的是描述，并使代码能够适应变化。</p><p>如果后来有人来修改这个函数，这些问题的答案可能会改变。您需要知道这种情况是否会发生，因为对其中一些的更改可能会破坏您的整个代码！</p><p>我现在要注意的是，在编写测试时考虑更多的问题是非常常见的。我们将为所有的问题编写测试！</p><h2 id="writing-python-tests-with-unittest">用unittest编写Python测试</h2><p>让我们从编写第一个测试开始。通常我的第一个测试会是一个肯定的测试，这意味着“这个函数做了我期望它做的事情吗？”。</p><pre><code class="language-python">from unittest import TestCase
from typing import List

def reverse_list(original: List) -&gt; List:
	return original[::-1]

class ReverseListTest(TestCase):
	def test_reverses_nonempty_list(self):
		original = [3, 7, 1, 10]
		expected = [1, 3, 7, 10]
		self.assertEqual(reverse_list(original), expected)
</code></pre>
<p>我们已经编写了第一个测试！</p><p>尽可能编写简单的测试很重要。通常在我的测试中，我定义我正在测试的东西的参数(变量<code>original</code>),结果<code>expected</code>，然后我比较两者。</p><h2 id="running-tests-with-unittest">使用unittest运行测试</h2><p>默认情况下，当使用unittest时，您的文件应该被称为<code>test_*.py</code>。现在，比方说把你的文件叫做<code>test_reverse.py</code>。</p><p>默认情况下，测试方法的命名也应该遵循这种命名模式。注意，我的测试方法叫做<code>test_reverses_nonempty_list</code>。</p><p>保存文件后，您可以通过以下方式运行它:</p><ul><li>如果使用PyCharm，右击并按“用unittest运行测试...”。</li><li>如果使用终端，输入<code>python -m unittest test_reverse.py</code>。</li></ul><pre><code>python -m unittest test_reverse.py
.
----------------------------------------------------------------------
Ran 1 test in 0.000s
</code></pre>
<p>你看到的是你的测试成功了！</p><h2 id="answering-questions-with-tests">用测试回答问题</h2><p>让我们通过更多的测试来回答我们的其他问题:</p><ul><li>它是否反转了包含不同类型元素的列表？</li><li>它对空列表有效吗？</li><li>它是处理字符串和其他序列，还是只处理列表？</li><li>它是就地修改列表还是给你一个新的列表？</li><li>它对有重复条目的列表有效吗？</li></ul><h3 id="does-it-reverse-a-list-with-different-types-of-elements">它是否反转了包含不同类型元素的列表？</h3><p>这个问题的答案似乎无关紧要。你可能会想:“我永远不会这么做，所以我为什么要在乎呢？”。</p><p>如果你<em>永远不会</em>去做这件事，也许你想要的是不要意外地做这件事。我们的函数应该检查元素是否都是相同的类型吗？由您决定应该在您的代码库中发生什么。出于这个例子的目的，让我们这样做，我们不能有混合类型。</p><pre><code class="language-python">from unittest import TestCase
from typing import List

def has_mixed_types(list_: List):
    first = type(list_[0])
    return any(not isinstance(t, first) for t in list_)

def reverse_list(original: List) -&gt; List:
	if has_mixed_types(original):
		raise ValueError("The list to be reversed should have homogeneous types.")
	return original[::-1]

class ReverseListTest(TestCase):
	def test_reverses_nonempty_list(self):
		original = [3, 7, 1, 10]
		expected = [10, 1, 7, 3]
		self.assertEqual(reverse_list(original), expected)

	def test_reverses_varying_elements_raises(self):
		original = [3, 7, "a"]
		with self.assertRaises(ValueError):
			reverse_list(original)
</code></pre>
<p>请注意，您不需要显式测试“当元素都是相同类型时，它不会引发错误”，因为这是从我们的第一次测试通过后推断出来的。</p><h3 id="does-it-work-with-an-empty-list">它对空列表有效吗？</h3><p>这个问题是你可能要决定是否支持的另一个问题。</p><p>如果你想在用户试图撤销一个空列表时通知他们，你可以在原始列表的长度为0时引发一个错误。现在，我们允许它。</p><p>这个测试之所以在这里，是因为如果将来我们决定在一个空列表被传递时引发一个错误，这个测试应该会失败。然后我们会回来修复它，高兴地知道我们的函数以我们期望的方式工作。</p><pre><code class="language-python">def test_reverses_empty_list(self):
	original = []
	expected = []
	self.assertEqual(reverse_list(original), expected)
</code></pre>
<h3 id="does-it-work-with-strings-and-other-sequences-or-only-lists">它是处理字符串和其他序列，还是只处理列表？</h3><p>写这个帖子的时候想到的这个问题！</p><p>使用切片反转将对字符串和其他序列以及列表起作用。也许这是你想允许的事情——但目前是不允许的。</p><p>因为我们的类型提示将<code>List</code>指定为参数，所以如果开发人员正在使用类型提示工具，那么应该传递列表或者向他们发出警告(这是应该的！).</p><p>如果你想允许其他序列，你可以从<code>typing</code>模块中使用<code>Sequence</code>而不是<code>List</code>。</p><h3 id="does-it-modify-the-list-in-place-or-does-it-give-you-a-new-list">它是就地修改列表还是给你一个新的列表？</h3><p>这是很重要的一条！如果你调用一个函数，而你不确定它是否会修改链表或者给你一个新的，你肯定会遇到问题。</p><p>使用切片的列表反转会给你一个新的列表，但是如果你使用不同的反转方法，它可以在适当的位置修改。</p><p>这就是为什么编写测试是重要的:如果有人后来修改了函数，如果新函数修改了列表，我们应该有一个失败的测试。</p><pre><code class="language-python">def test_reversal_gives_new_list(self):
	original = [3, 5, 7]
	expected = [3, 5, 7]
	reverse_list(original)
	self.assertEqual(original, expected)
</code></pre>
<p>通过检查<code>original</code>和<code>expected</code>是否相同，我们知道<code>original</code>被<code>reverse_list()</code>保持不变。</p><h3 id="does-it-work-for-lists-with-duplicate-entries">它对有重复条目的列表有效吗？</h3><p>当列表有重复条目时，一些反转列表的方法可能不太适用，因此值得为此添加另一个测试——只要确保即使有重复的元素，反转也能得到预期的值。</p><pre><code class="language-python">def test_reversal_with_duplicates(self):
	original = [3, 4, 3, 3, 9]
	expected = [9, 3, 3, 4, 3]
	self.assertEqual(reverse_list(original), expected)
</code></pre>
<h2 id="more-questions">更多问题</h2><p>当你写代码和使用<code>reverse_list</code>函数时，你可能会遇到更多你想要回答的问题。</p><p>也许你会写一个与这个函数相关的bug，或者也许你只是碰巧想到一些你想确定的事情。</p><p>多写测试！测试就像活的文档，它们帮助您确信您的代码按照您认为的方式工作，即使代码在发展和变化。</p><h2 id="wrapping-up">包扎</h2><p>最终完整的代码可以在这里看到<a href="https://gist.github.com/jslvtr/de28a530f00e7486b51efa3c17f44276">。</a></p><p>感谢您的阅读。我希望你在这篇文章中学到了一些东西！</p><p>有什么问题吗？给我们发微博。考虑加入我们的<a href="https://www.udemy.com/the-complete-python-course/?couponCode=BLOGGER">完整Python课程</a>以了解更多Python的优点，或者我们的<a href="https://www.udemy.com/automated-software-testing-with-python/?couponCode=BLOGGER">Python自动化软件测试</a>课程以更深入地关注测试Python和web应用程序。</p><p>如果你想要这些课程的折扣代码，请注册我们下面的邮件列表。每个月我们都与我们的用户分享折扣代码！</p><p>周一见，另一个Python片段！</p>
</div>
</div>    
</body>
</html>