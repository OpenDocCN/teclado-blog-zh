<html>
<head>
<title>Time complexity and BigO Notation explained (with Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>时间复杂度和BigO符号解释(用Python)</h1>
<blockquote>原文：<a href="https://blog.teclado.com/time-complexity-big-o-notation-python/">https://blog.teclado.com/time-complexity-big-o-notation-python/</a></blockquote><div><div class="post-content">
<p>时间复杂度告诉我们，相对于输入的大小，一个算法执行需要多长时间。这是理解算法相对性能的一种快捷方式。</p>
<p>下图让我们快速了解了本文将要涉及的时间复杂性:</p>
<p><img src="../Images/dbd330d14358db514b4a06e2254f180e.png" alt="A line chart showing complexities ranging from linear to exponential" loading="lazy" data-original-src="https://res.cloudinary.com/teclado/image/upload/f_auto,q_auto/v1661546878/blog/burak-uren-big-o/Big_o_nkhu8x.png"/></p>
<p>目录:</p>
<ol>
<li><a href="#1whatistimecomplexity"> <strong>什么是时间复杂度？</strong>T3】</a></li>
<li><a href="#2whatisbigo"> <strong>什么是BigO？</strong>T3】</a></li>
<li><a href="#3o1constanttime"> <strong> O(1)常数时间</strong> </a></li>
<li><a href="#4olognlogarithmictime"> <strong> O(logn)对数时间</strong> </a></li>
<li><a href="#5onlineartime"> <strong> O(n)线性时间</strong> </a></li>
<li><a href="#6on2polynomialtime"><strong>【o(n^2】二次时间</strong> </a></li>
<li><a href="#7o2nexponentialtime"><strong>【o(2^n】指数时间</strong> </a></li>
</ol>
<p>在这篇文章中，我将谈论时间复杂性，什么是BigO以及BigO如何帮助我们改进我们的算法。</p>
<p>那么让我们从什么是时间复杂度开始。</p>
<h2 id="1whatistimecomplexity">1.什么是时间复杂性</h2>
<p>时间复杂度是一个算法执行需要多少时间。但是我们不会计算一个算法执行的确切时间。相反，我们将计算输入大小对算法执行时间的影响。</p>
<h2 id="2whatisbigo">2.BigO是什么？</h2>
<blockquote>
<p>“BigO符号是一种数学符号，它描述了当自变量趋向特定值或无穷大时函数的极限行为。”-维基百科</p>
</blockquote>
<p>例如，我们有代表恒定时间的<code>O(1)</code>，这意味着我们的算法的执行时间不随输入大小而改变。</p>
<p>既然我们已经了解了时间复杂度和BigO的含义，那么让我们看看我们有什么样的BigO符号以及它们的含义。</p>
<h2 id="3o1constanttime">3.O(1)常数时间</h2>
<p>一种时间复杂度不随输入大小变化的算法。就这么简单！</p>
<p>例如，从列表中获取第一个元素。输入大小不影响该算法，因为无论输入大小如何，第一个元素总是第一个。</p>
<pre><code class="language-python">def get_first(data):
    return data[0]
    
data = [1, 2, 3, 4]
get_first(data)
</code></pre>
<h2 id="4olognlogarithmictime">4.O(logn)对数时间</h2>
<p>下面是“什么是对数”的快速参考:<a href="https://byjus.com/maths/logarithms/">https://byjus.com/maths/logarithms/</a>。对数算法每次运行时都会将列表或其他数据结构分割成较小的部分。</p>
<p>具有<code>O(logn)</code>时间复杂度的算法的最好例子是“二分搜索法”。二分搜索法必须在一个排序列表上执行。</p>
<p>我们来看看实现。</p>
<pre><code class="language-python"># Iterative Binary Search Function
# It returns the index of x in the given list if present,
# else returns -1
def binary_search(lst, x):
    low = 0
    high = len(lst) - 1
    mid = 0

    while low &lt;= high:

        mid = (high + low) // 2

        # If x is greater, ignore the left half
        if lst[mid] &lt; x:
            low = mid + 1

            # If x is smaller, ignore the right half
            elif lst[mid] &gt; x:
            high = mid - 1

            # means x is present in mid
            else:
                return mid

        # If we reach here, then the element was not present
        return -1


# Test list
lst = [ 2, 3, 4, 10, 40 ]
x = 10

# Function call
result = binary_search(lst, x)

if result != -1:
    print("Element is present at index", str(result))
else:
    print("Element is not present in list")

</code></pre>
<p>让我用英语解释一下这个算法是怎么回事。</p>
<ol>
<li>转到列表中间。</li>
<li>查看该元素是否是我们正在搜索的。</li>
<li>如果不是，那么检查我们正在寻找的元素是否大于中间的元素。</li>
<li>如果是，那么忽略now之后这个列表的右边，否则忽略now之后这个列表的左边。</li>
<li>对于剩下的列表，重复步骤1到4。</li>
</ol>
<p><img src="../Images/a05b70cf9b31a0ad7a3e10c6720fe4c8.png" alt="This GIF explains binary search and linear(sequential) search at the same time by animating the process of the searchs" loading="lazy" data-original-src="https://res.cloudinary.com/teclado/image/upload/v1662312686/blog/burak-uren-big-o/Binary_search_s1ho14.gif"/></p>
<p><em>与线性(顺序)搜索相比</em></p>
<h2 id="5onlineartime">5.O(n)线性时间</h2>
<p>在线性时间算法中，输入中的每个元素都被访问一次。随着输入大小的增加，我们算法的运行时间也随着输入的大小而增加。</p>
<p>线性搜索是线性复杂度算法的一个例子。</p>
<p>下面是实现过程:</p>
<pre><code class="language-python">#Define the linear search function
def search(lst, x):
    
    for i in range(len(lst)):
 
        if lst[i] == x:
            return i
 
    return -1

#Let's give it a try
lst = ["a","b","c","find me","d"]

print(search(lst, "find me"))

&gt;&gt;3
</code></pre>
<h2 id="6on2polynomialtime">6.O(n^2)多项式时间</h2>
<p>可以访问每个元素一次的算法是线性算法，<code>O(n)</code>。通常这是通过一个遍历列表中每个元素的循环来实现的。</p>
<p>但是如果你有嵌套循环，就像这个例子？</p>
<pre><code class="language-python">lst = [1, 3, 5]
for x in lst:
    for y in lst:
        pass
</code></pre>
<p>如果这是一个<code>O(n)</code>算法，我们将总共执行3次迭代，因为列表有3个元素。但是对于嵌套循环，我们最终执行9次迭代。这就是为什么时间复杂度是多项式，<code>O(n^2)</code>，因为<code>3^2 = 9</code>。</p>
<p>冒泡排序就是一个很好的例子:</p>
<pre><code class="language-python">def bubbleSort(lst):
    n = len(lst)
    
    # Traverse through all list elements
    for i in range(n):
    
        # Last i elements are already in place
        for j in range(0, n-i-1):
    
            # traverse the list from 0 to n-i-1
            # Swap if the element found is greater
            # than the next element
            if lst[j] &gt; lst[j+1] :
                lst[j], lst[j+1] = lst[j+1], lst[j]

# Driver code to test above
lst = [64, 34, 25, 12, 22, 11, 90]

bubbleSort(lst)
</code></pre>
<p>冒泡排序算法取第一个数字，如果顺序不对，就与相邻的数字交换。它对每个数字都这样做，直到所有的数字都按正确的顺序排列——从而排序。</p>
<p><img src="../Images/729be0ba52405b6ef836a5acf9da8e87.png" alt="This GIF explains by animating the process of the search" loading="lazy" data-original-src="https://res.cloudinary.com/teclado/image/upload/v1661546879/blog/burak-uren-big-o/bubble-sort_oi0wti.gif"/></p>
<h2 id="7o2nexponentialtime">7.O(2^n)指数时间</h2>
<p>这绝对是最差的一个因为它是最慢的！</p>
<p>指数时间是<code>2^n</code>，所以运行时间随着输入的大小呈指数增长。</p>
<p>假设我们有一个仅由数字组成的密码(所以有10个数字，从0到9)。我们想要破解一个长度为n的密码，所以我们将使用<code>10^n</code>来暴力破解每个组合。</p>
<p>例如，假设我们想要创建一个长度为15个字符的密码！所有组合的数量将等于<code>10^15 = 1.000.000.000.000.000</code>！</p>
<p>指数时间算法的一个例子是斐波那契数的递归计算:</p>
<pre><code class="language-python">def fibonacci(n):
    if n &lt;= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
</code></pre>
<p>所以，很明显我们不想使用一个有<code>O(2^n)</code>权利的算法？我们能做什么来处理这个问题？我举个例子解释一下。</p>
<p>假设我们要计算<code>10^4</code>。我们需要这样做:</p>
<blockquote>
<p>10 * 10 * 10 * 10 = 10^2 * 10^2</p>
</blockquote>
<p>如你所见，我们必须计算两次<code>10^2</code>。为什么不计算一次，再用同样的结果呢？这种方法叫做<code>Dynamic Programming</code>。这里有一篇<a href="https://skerritt.blog/dynamic-programming/">文章</a>来了解更多！</p>
<p>不要忘记，了解时间复杂性可以让我们建立更好的算法。我们可以使用我们的知识来改进算法，因为我们知道什么导致更差或更好的时间复杂度。</p>
<p>如果你想可视化我们讨论过的算法，你可以访问<a href="https://visualgo.net/en/"> visualgo </a>！</p>
<p>在这张图中，您可以看到我们讨论过的时间复杂性。</p>
<p><img src="../Images/dbd330d14358db514b4a06e2254f180e.png" alt="This image shows all the complexities in one graph that we covered" loading="lazy" data-original-src="https://res.cloudinary.com/teclado/image/upload/f_auto,q_auto/v1661546878/blog/burak-uren-big-o/Big_o_nkhu8x.png"/></p>
<p>感谢您的阅读，希望对您有所帮助！</p>
<p>如果你想看我的其他文章和关于Python和后端开发的帖子，可以看看我的<a href="https://twitter.com/burak_uren101"> Twitter </a>和<a href="https://medium.com/@burakuren101">博客</a>。</p>
<p>额外阅读:</p>


</div>
</div>    
</body>
</html>