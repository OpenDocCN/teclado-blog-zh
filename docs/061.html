<html>
<head>
<title>Simple JWT Authentication with Flask-JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Flask-JWT的简单JWT认证</h1>
<blockquote>原文：<a href="https://blog.teclado.com/simple-jwt-authentication-with-flask-jwt/">https://blog.teclado.com/simple-jwt-authentication-with-flask-jwt/</a></blockquote><div><div class="post-content">
<p>通常在Flask应用程序中，我们希望添加登录/注销功能。根据您创建的应用程序的类型，您可以使用会话或令牌。</p><ul><li>会话最适合使用Flask提供网页服务的应用程序——即大量使用<code>render_template</code>。</li><li>令牌最适合API，其中Flask应用程序接受数据并将其返回给另一个应用程序(如移动应用程序或web应用程序)。</li></ul><p>在这篇文章中，我们将学习如何为你的Flask应用添加基于令牌的认证。但是首先...</p><h2 id="what-is-a-jwt">什么是JWT？</h2><p>JWT代表JSON Web Token，它是一段编码了一些信息的文本。</p><p>在Flask应用中进行身份验证时存储的信息通常是我们可以用来识别为其生成JWT的用户的信息。</p><p>流程是这样的:</p><ol><li>用户提供他们的用户名和密码</li><li>我们在Flask应用程序中验证它们是正确的</li><li>我们生成一个包含用户ID的JWT。</li><li>我们把它发送给用户。</li><li>每当用户向我们的应用程序发出请求时，他们必须将我们之前生成的JWT发送给我们。通过这样做，我们可以验证JWT是有效的——然后我们将知道向我们发送JWT的用户是我们为其生成的用户。</li></ol><p>最后一点很重要。当我们收到已知有效的JWT时，我们知道我们是为特定用户生成的。我们可以使用存储在JWT中的信息来检查这一点。</p><p>因为我们知道用户向我们发送了他们登录时我们生成的JWT，所以我们可以将它视为“登录用户”。</p><p>任何没有向我们发送有效JWT的用户，我们将被视为“注销”用户。</p><h2 id="authentication-with-flask-jwt">使用Flask-JWT进行认证</h2><p>用Flask认证有两个主要的库:Flask-JWT和Flask-JWT-扩展。</p><p>弗拉斯克-JWT稍微简单一点，而弗拉斯克-JWT-扩展的稍微强大一点。学习一个将使学习另一个变得非常简单。</p><p>在这篇文章中，我们将使用弗拉斯克-JWT。</p><h3 id="installing-and-linking-with-our-app">安装并链接我们的应用程序</h3><p>要安装Flask-JWT，请激活您的虚拟环境，然后执行以下操作:</p><pre><code>pip install flask-jwt
</code></pre><p>然后，在定义你的应用程序的文件中，你需要导入弗拉斯克-JWT并创建<code>JWT</code>对象。您还需要将<code>app.secret_key</code>定义为用于签署JWT，这样您就知道是您的应用程序创建了它，而不是其他任何人:</p><pre><code class="language-python">from flask import Flask
from flask_jwt import JWT
from security import authenticate, identity

app = Flask(__name__)
app.secret_key = "jose"  # Make this long, random, and secret in a real app!
jwt = JWT(app, authenticate, identity)

if __name__ == "__main__":
	app.run()
</code></pre>
<p>我们还有一个针对<code>authenticate</code>和<code>identity</code>的导入。Flask-JWT需要这两个函数来知道如何处理传入的JWT，以及我们希望在传出的JWT中存储什么数据。</p><p>一旦我们创建了<code>JWT</code>对象，Flask-JWT就向我们的应用程序注册了一个端点<code>/auth</code>。</p><p>这意味着该代码中的简单应用程序已经有了一个用户可以访问的端点。默认情况下，用户应该能够向<code>/auth</code>端点发送带有一些JSON有效负载的POST请求:</p><pre><code>{
  "username": "their_username",
  "password": "their_plaintext_password"
}
</code></pre><h2 id="what-is-authenticate">什么是<code>authenticate</code>？</h2><p><code>authenticate</code>功能用于认证用户。这意味着，当用户向我们提供他们的用户名和密码时，我们希望将哪些数据放入JWT。请记住，我们放入JWT的数据将在用户每次发送请求时返回给我们。</p><p>流程是这样的:</p><ol><li>用户使用他们的用户名和密码作为JSON有效负载向新的<code>/auth</code>端点发出POST请求。</li><li>使用该用户名和密码调用<code>authenticate</code>函数。弗拉斯克-JWT在我们创建<code>JWT</code>对象时设置了这个。</li></ol><p>通常在<code>authenticate</code>函数中，我检查用户的用户名和密码的有效性，然后告诉弗拉斯克-JWT将用户的<code>id</code>存储在JWT中。</p><p>大概是这样的:</p><pre><code class="language-python">from werkzeug.security import safe_str_cmp
from models.user import UserModel


def authenticate(username, password):
    user = UserModel.find_by_username(username)
    if user and safe_str_cmp(user.password, password):
        return user
</code></pre>
<p>我的<code>authenticate</code>函数接受一个<code>username</code>和<code>password</code>。然后，它进入数据库，找到与该用户名匹配的用户，并检查密码是否正确。</p><p>如果是，则返回用户。</p><p>这是否意味着用户存储在JWT？</p><p>第二个Flask-JWT将获取<code>user</code>对象的<code>id</code>属性，并将那个对象的<em>存储在JWT中。</em></p><p>如果您的<code>user</code>对象没有<code>id</code>属性，您将得到一个错误。</p><p>您可以通过设置应用程序配置属性来更改存储在JWT中的属性。在我们的<a href="https://blog.teclado.com/learn-python-advanced-configuration-of-flask-jwt/"> Flask-JWT配置博客文章</a>中了解更多信息。</p><h3 id="what-is-identity">什么是<code>identity</code>？</h3><p>当我们接收到一个JWT时，就会用到<code>identity</code>函数。</p><p>在我们的任何端点(除了<code>/auth</code>端点)，用户可以向我们发送一个JWT以及他们的数据。为此，他们会在请求中添加一个标题:</p><pre><code>Authorization: JWT &lt;JWT_VALUE_HERE&gt;
</code></pre><p>当这种情况发生时，弗拉斯克-JWT公司将接管JWT并从中获取数据。存储在JWT中的数据被称为“有效载荷”，因此我们的<code>identity</code>函数接受该有效载荷作为参数:</p><pre><code class="language-python">def identity(payload):
    user_id = payload['identity']
    return UserModel.find_by_id(user_id)
</code></pre>
<p><code>payload['identity']</code>包含用户的<code>id</code>属性，这是我们在创建它时保存到JWT中的。<code>payload</code>还包含其他内容，比如令牌何时创建、何时到期等等。更多信息，请阅读本文的<a href="https://scotch.io/tutorials/the-anatomy-of-a-json-web-token">“有效载荷”部分。</a></p><p>因为<code>payload['identity']</code>是用户的<code>id</code>——我们用它在数据库中找到用户并返回它。</p><p><strong>重要的</strong>:除非我们用<code>@jwt_required()</code>装饰器装饰端点，否则不会调用<code>identity</code>函数，如下所示:</p><pre><code class="language-python">from flask_jwt import jwt_required, current_identity

@app.route('/protected')
@jwt_required()
def protected():
    return '%s' % current_identity
</code></pre>
<p>在任何用<code>@jwt_required()</code>修饰的端点内，我们可以访问<code>current_identity</code>代理——它将为我们提供<code>identity</code>函数在这个特定请求中收到的JWT返回的任何内容。</p><h3 id="testing-and-error-messages">测试和错误消息</h3><p>这里有一个简单的应用程序，取自官方文档，你可以用它来测试你的Flask-JWT请求。</p><p>我建议用弗拉斯克-JWT测试不同的场景，看看它能给你带来什么。例如，如果发生以下情况会怎么样:</p><ul><li>您发送了无效的用户名或密码；</li><li>您发送了无效或不完整的JWT；</li><li>在负载中id为的数据库中找不到您的用户；</li></ul><h2 id="flask-jwt-extended">烧瓶-JWT-扩展</h2><p>烧瓶-JWT-扩展非常类似于烧瓶-JWT，但有更多的配置选项和一些更多的功能。例如，它允许令牌刷新。</p><p>在你熟悉了Flask-JWT之后——如果你需要那些高级功能——阅读我们在Flask-JWT-Extended上的博客文章,了解更多！</p><hr/><p>我希望这篇文章对你有用，你也学到了一些东西！</p><p>如果你想要一套更好、更容易理解的视频教程来指导你创建Flask应用程序和REST API，请查看我们的<a href="https://go.tecla.do/rest-apis-sale">REST API with Flask and Python</a>课程。它包含了您轻松开发简单、专业的REST APIs所需的一切。</p><p>如果您注册了我们下面的邮件列表，这是获得折扣代码的最佳方式——我们每个月都会与我们的订户分享它们！</p>
</div>
</div>    
</body>
</html>