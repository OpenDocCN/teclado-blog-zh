<html>
<head>
<title>Working with Python virtual environments: the complete guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Python虚拟环境:完整指南</h1>
<blockquote>原文：<a href="https://blog.teclado.com/python-virtual-environments-complete-guide/">https://blog.teclado.com/python-virtual-environments-complete-guide/</a></blockquote><div><div class="post-content">
<p>我们开发的大多数Python项目都会有依赖关系:别人写的代码我们安装使用，这样我们自己就不用重新写了。</p><figure class="kg-card kg-embed-card"><iframe src="https://www.youtube.com/embed/KxvKCSwlUv8?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">VIDEO</iframe></figure><p>例如，<code>requests</code>库是一个流行的第三方依赖项，用于发出HTTP请求。<code>flask</code>库用于创建web应用程序。</p><p>有成千上万的图书馆做各种各样的事情，有成千上万的人在这些图书馆工作。</p><p>我们安装并使用库，这样我们就不必重写那些人自己写的所有代码了！</p><p>随着新的、更好的做事方法的发现和实现，库会随着时间而变化。</p><p>因此，当我们为我们的一个项目安装一个库时，它将是一个特定的版本。几个月或几年后，如果再次尝试安装它，它很可能是一个具有不同功能的不同版本。</p><p>因此，当我们更新一个库时，我们的代码可能不再工作，因为我们使用这个库的方式已经改变了。</p><p>虚拟环境的存在是为了让我们能够将一个项目的依赖性与另一个项目的依赖性分开。这样，他们可以拥有同一个库的不同版本。当我们在不同的时间开始项目时，这种情况经常发生。</p><h1 id="what-is-a-virtual-environment">什么是虚拟环境？</h1><p>虚拟环境有两个关键部分:</p><ul><li>Python的特定版本，例如Python 3.9。</li><li>您已安装的第三方库的文件夹。</li></ul><p>我们创建的每个虚拟环境都可以用不同的Python版本来创建。这让我们可以非常容易地处理使用不同Python版本的项目。同样，因为每个虚拟环境都有自己的第三方库文件夹，所以它们可以有不同的库，也可以有相同或不同版本的相同库。</p><h1 id="how-does-python-import-libraries">Python如何导入库？</h1><p>当我们运行一个Python文件时，我们可以访问<strong>导入路径</strong>，或者<em>，当我们试图导入东西</em>时，Python会在那里查找。</p><p>我们可以通过运行以下代码来查看导入路径:</p><pre><code class="language-python">import sys

print(sys.path)
</code></pre><p>如果您运行这个程序，您可能会得到如下所示的结果:</p><pre><code class="language-python">["/Users/youruser/Documents/projects/myproject", "/Applications/Python/Python39/bin", "Applications/Python/Python39/lib", "Applications/Python/Python39"]
</code></pre><p>这意味着，如果我们尝试<code>import something</code>，Python将在输出列表的第一条路径上寻找<code>something.py</code>。</p><p>如果找到它，它将导入它。如果没有找到，它将移动到列表的第二个路径。然后是第三个，依此类推，直到找到为止。</p><p>如果没有找到，Python会抛出一个<code>ImportError</code>消息，告诉你你试图导入的东西不存在。</p><p>现在，我们马上就会了解到，这将与虚拟环境相关！</p><h1 id="how-to-create-new-virtual-environments">如何创建新的虚拟环境</h1><p>使用最新的Python版本创建新的虚拟环境就像在控制台上运行以下命令一样简单:</p><pre><code class="language-bash">python -m venv venvName
</code></pre><p>这将在当前文件夹中创建一个名为<code>venvName</code>的新虚拟环境。</p><p>请记住，如果您安装了多个版本的Python，您可能必须执行<code>python3.9 -m venv venvName</code>或类似的操作，这取决于您的Python版本。</p><h1 id="what-happens-when-you-activate-a-virtual-environment">激活虚拟环境会发生什么？</h1><p>现在您已经创建了虚拟环境，我们可以激活它了！</p><p>您可以使用以下命令激活虚拟环境(在Mac或Linux上):</p><pre><code class="language-bash">source venvName/bin/activate
</code></pre><p>如果您将Windows与WSL或Git Bash一起使用:</p><pre><code>source venvName/Scripts/activate
</code></pre><p>或者，如果您将Windows与cmd.exe或PowerShell配合使用:</p><pre><code>.\\venvName\\Scripts\\activate.bat
</code></pre><p>当我们激活虚拟环境时，会发生两件主要的事情:</p><ul><li>我们可以在控制台中使用<code>python</code>和<code>pip</code>命令，它们使用虚拟环境中的Python。当我们在激活虚拟环境的情况下使用<code>pip</code>时，新的库将被安装在虚拟环境中。</li><li>当我们使用<code>python</code>命令运行Python时，会修改<code>sys.path</code>值，以便在虚拟环境的第三方库文件夹中查找任何导入。因此，我们在虚拟环境中安装的任何东西都将可用，但我们在其他虚拟环境中安装的东西将不可用。</li></ul><p>在首先激活虚拟环境之后，通过再次运行打印<code>sys.path</code>的代码，可以很容易地验证这一点。你会发现有点不一样！</p><h1 id="virtualenv-vs-venv-vs-pipenv">Virtualenv与venv和Pipenv</h1><p>有一些不同的软件包用于处理虚拟环境，比如<code>virtualenv</code>、<code>venv</code>或<code>Pipenv</code>。它们都有点不同，而且各有利弊。</p><p>我推荐你使用<code>venv</code>，因为它是新的Python版本附带的，非常容易使用。</p><p><code>virtualenv</code>包是我们必须在旧Python版本中安装的旧包。它不再有必要，也不会做任何<code>venv</code>不会做的事情。</p><p><code>Pipenv</code>包做的比<code>venv</code>多一点，但是它应该有自己的博客来解释所有的区别。我觉得目前不值得用。</p><h1 id="saving-dependencies-in-a-text-file">在文本文件中保存依赖关系</h1><p>将依赖项保存到文本文件中会很有用，这样当您与其他人共享您的代码时，他们就知道要运行您的项目需要安装什么。</p><p>当我们使用<code>venv</code>时，通常将依赖项的名称保存到一个名为<code>requirements.txt</code>的文件中。</p><p>例如，我的一个项目有一个<code>requirements.txt</code>文件:</p><pre><code>requests
flask
gunicorn
pymongo[srv]
</code></pre><p>这有4个依赖项，每行一个。如果我下载了全部代码，并想安装<code>requirements.txt</code>中详述的依赖项的最新版本，我只需这样做:</p><pre><code class="language-bash">python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
</code></pre><p>把虚拟环境命名为<code>.venv</code>很常见，所以我一般都是这么做的！</p><h1 id="including-version-numbers">包括版本号</h1><p>任何<code>requirements.txt</code>文件也可以包含版本号，因此当您从该文件安装依赖项时，您将获得详细的确切版本。</p><p>这可能是有用的，因为正如我在开始时提到的，库会随着时间而变化，您的代码可能无法与最新版本一起工作。</p><p>通常，我们会写下开发代码时使用的版本。更新任何依赖项的版本号应该是一个有意识的决定，因为有时我们需要对代码进行更改，以适应库的更改。</p><p>以下是如何在您的<code>requirements.txt</code>文件中包含版本号:</p><pre><code>requests==1.0.0
flask&gt;=1.1.2
gunicorn==20.0.4
pymongo[srv]==3.11
</code></pre><p>这有几种写法。如上所示:</p><ul><li><code>==</code>表示“完全安装此版本”。</li><li><code>&gt;=</code>表示“安装最新版本，必须高于以下版本”。</li></ul><h1 id="handling-major-version-changes">处理主要版本变更</h1><p>通常情况下，图书馆在更改“主要版本”时会进行重大更改。</p><p>在库版本控制中，“主要版本”是第一个数字，因此这两个版本具有相同的主要版本:</p><p>但是它们在不同的次要版本(中间数字)和补丁版本(最后数字)上。</p><p>通常，我们希望安装最新版本的库，同时保留主版本。这样，如果我们将来安装依赖项，我们将安装与过去相同的主版本，但我们将获得库在其次版本和补丁版本中所做的任何小的改进。</p><p>值得重复的是，通常库不会给小版本和补丁版本添加重大更改，这就是为什么这是一件常见的事情。然而，一个库可能会在任何版本中崩溃，所以这完全是关于权衡和风险的！</p><p>要安装库的最新次要/修补版本，我们可以这样做:</p><pre><code>flask&gt;=1.1.2,&lt;2.0
</code></pre><h1 id="conclusion">结论</h1><p>这就是这篇文章的全部内容！我希望这有助于学习更多关于虚拟环境的知识，它们是如何工作的，以及如何在你的项目中使用它们！</p><p>如果你想学习更多关于Python的知识，考虑注册我们的<a href="https://go.tecla.do/complete-python-sale">完整Python课程</a>，它将带你从初学者到高级Python知识(包括web抓取、异步开发等等！).</p><p>感谢阅读，我们下次再见！</p><h2 id="references">参考</h2>
</div>
</div>    
</body>
</html>