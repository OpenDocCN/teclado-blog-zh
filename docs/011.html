<html>
<head>
<title>The @property decorator in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python中的@property装饰器</h1>
<blockquote>原文：<a href="https://blog.teclado.com/property-decorator-in-python/">https://blog.teclado.com/property-decorator-in-python/</a></blockquote><div><div class="post-content">
<p>Python的特性很多，学的时候很容易不知所措。今天我们将重点学习其中的一个特性:装饰器。</p>
<p>我们将解释什么是属性，为什么您可能想要使用它们，以及它们在Python的类结构中的位置。</p>
<p>当学习编程时，在你学会基础知识之后，通常会有一个陡峭的学习曲线。教程和现实项目差距很大！装饰器是你很少在教程中看到的特性之一，但有时会非常有用。</p>
<h2 id="whatarepropertieswhataremethods">什么是属性？什么是方法？</h2>
<p>在讨论编程语言时，像<code>property</code>和<code>method</code>这样的术语经常被抛来抛去。放慢速度来定义Python中每个术语的实际含义是很有用的。</p>
<p>一个<strong>属性</strong>是一个特定于类对象的变量。如果你对什么是“对象”不熟悉，请查看<a href="https://blog.teclado.com/introduction-to-object-oriented-programming-in-python/">这篇文章</a>进行快速回顾。例如，如果您有一个名为<code>Human</code>的类，那么属性将是该类的每个对象上存在的任何变量。您可以使用<code>self</code>关键字来创建属性。“属性”只是我们给属于一个类的变量起的名字。这里有一个使用<code>Human</code>类的例子:</p>
<pre><code class="language-python">class Human:
    def __init__(self, age):
        self.age = age
</code></pre>
<p><code>self.age</code>指的是现在在<code>Human</code>类的对象上的属性。我们可以设置许多属性，这取决于我们需要类对象拥有什么。例如，我们可以将<code>self.hair_color</code>或<code>self.eye_color</code>设置为<code>Human</code>类的对象的属性。</p>
<p>一个<strong>方法</strong>是属于一个类的函数。例如，在名为<code>Human</code>的类中，方法可以是存在于该类中的任何函数。这里有一个例子，使用我们的<code>Human</code>类:</p>
<pre><code class="language-python">class Human:
    def __init__(self, age):
        self.age = age

    def get_age(self):
        return self.age
</code></pre>
<p><code>get_age</code>函数被称为“类Human上的一个方法”。重要:方法总是接收参数<code>self</code>作为它们的第一个参数。这是因为方法总是连接到一个类。在这种情况下，<code>get_age</code>就是所谓的“实例方法”，并且将总是接收被调用的对象作为第一个参数。要了解每种方法的更多信息，请查看<a href="https://blog.teclado.com/python-methods-instance-static-class/">这篇文章</a>。</p>
<p>属性是一种特殊类型的属性。它是一个分配了两个方法的属性:一个“getter”和一个“setter”。让我们看一些代码来进一步解释:</p>
<pre><code class="language-python">class Human:
    def __init__(self, age):
        self.age = age

    def get_age(self):
        return self.age

    def set_age(self, new_age):
        self.age = new_age

    age = property(get_age, set_age)
</code></pre>
<p>如你所见，我们使用了很多相同的代码。我们包含了一个名为<code>set_age</code>的新“setter”函数，然后我们将<code>age</code>变量标识为该类的一个属性，getter为<code>get_age</code>，setter为<code>set_age</code>。这就是<code>property()</code>函数正在做的事情:它为第一个参数获取一个getter，为第二个参数获取一个setter，并在该类上创建一个<strong>属性</strong>变量，该变量存储在您指定的名称中。</p>
<p>类的属性很有用，因为它们允许我们在获取或设置属性时对属性进行一些动态处理。例如，如果您的类有属性<code>age</code>，但是您想确保年龄值总是以月为单位给出，您可以通过将<code>age</code>属性设为属性来确保这一点。看看这段代码，明白我的意思:</p>
<pre><code class="language-python">class Human:
    def __init__(self, age):
        self.age = age

    def get_age_in_months(self):
        return self.age * 12

    def set_age(self, new_age):
        self.age = new_age

    age = property(get_age_in_months, set_age)
</code></pre>
<h2 id="decorators">装修工</h2>
<p>为了进一步简化创建属性的过程，我们将使用<code>@property</code>装饰器。如果你从未用过/见过装修工，跟随我们的<a href="https://blog.teclado.com/decorators-in-python/">迷你课程</a>快速上手。</p>
<p><code>@property</code>装饰器是使用我们之前使用的<code>property()</code>函数的快捷方式。最重要的是，它使代码更加简洁。此外，<code>@property</code>装饰器在类初始化时首先执行，所以在它成为属性之前没有机会意外地使用它。让我们深入研究一下这段代码:</p>
<pre><code class="language-python">class Human:
    def __init__(self, age):
        self.age = age

    @property
    def age(self):
        return self._age

    @property 
    def months(self):
        return self._age * 12

    @age.setter
    def age(self, new_age):
        self._age = new_age
</code></pre>
<p>这里，我们在getter和setter函数上使用了decorators，我们现在已经将它重命名为属性的名称。让我们具体看一下每一个。</p>
<p>getter方法<code>age</code>是应用了<code>@property</code>装饰器的方法。我们可以用它来格式化和改变每次属性被引用时getter输出的内容。</p>
<p>但是由于<code>age</code>是一个函数，我们仍然需要在某个地方存储人的年龄值。这就是<code>_age</code>属性发挥作用的地方。</p>
<p>当初始化类<code>Human</code>的对象时，<code>__init__</code>方法将运行。这将在<code>self</code>对象上设置<code>age</code>属性。因为我们为<code>age</code>属性编写了一个自定义设置器，自定义设置器将会运行。</p>
<p>在自定义设置器中，我们获取传入的<code>age</code>值，并在<code>self</code>对象上设置<code>_age</code>属性。此时，使用setter，我们可以更好地控制如何设置<code>_age</code>属性。</p>
<p>当<code>__init__</code>方法结束运行时，对象将有:</p>
<ul>
<li>一个<code>_age</code>属性，包含创建对象时传入的值。</li>
<li>一项<code>age</code>财产:<ul>
<li>当被访问时调用<code>@property</code>方法</li>
<li>更改时使用<code>@age.setter</code>方法</li>
</ul>
</li>
<li>一个可以被访问但其值不能被改变的<code>months</code>属性(因为它没有设置器)。</li>
</ul>
<p>为了说明我的意思，考虑下面的代码:</p>
<pre><code class="language-python">jeff = Human(26)

print('I am ')
print(jeff.age)
print(' years old.')

</code></pre>
<p>你觉得这会印出什么？</p>
<p>这将输出以下内容:</p>
<pre><code>I am 
26
years old.
</code></pre>
<p>用<code>@property</code>装饰器来装饰getter函数允许我们改变属性将如何提供给任何调用它的人。例如，我可以通过创建另一个属性<code>months</code>来使用代码返回年龄所对应的月数:</p>
<pre><code class="language-python">@property
def months(self):
        return self._age * 12
</code></pre>
<p>现在，每当调用变量<code>jeff.months</code>时，它都会返回:</p>
<pre><code>312
</code></pre>
<p>让我们来看看二传手。现在我们已经使用<code>@property</code>装饰器定义了一个属性，我们可以使用<code>@[property_name].setter</code>为它编写一个setter。记住在你的类中用实际的属性名替换<code>property_name</code>。让我们看看在<code>Human</code>类中我们是如何做到这一点的:</p>
<pre><code class="language-python">class Human:
    def __init__(self, age):
        self.age = age

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, new_age):
        self._age = new_age
</code></pre>
<p>属性<code>age</code>上的setter是用<code>@age.setter</code> decorator修饰的，这允许我们修改如何设置这个属性。例如，我们可以这样将某人的年龄限制为整数:</p>
<pre><code class="language-python">@age.setter
def age(self, new_age):
    if not isinstance(new_age, int):
    raise TypeError("Age must be an integer.")
    self._age = new_age
</code></pre>
<p>现在，如果我们尝试运行以下代码:</p>
<pre><code class="language-python">print(jeff.age)

jeff.age = 44.5

print(jeff.age)

jeff.age = 50

print(jeff.age)
</code></pre>
<p>以下是输出结果:</p>
<pre><code>26
Traceback (most recent call last):
  File "main.py", line 3, in &lt;module&gt;
TypeError: Age must be an integer.
</code></pre>
<p>因此，您可以看到我们的自定义setter函数将阻止除整数之外的任何内容被设置到<code>age</code>属性上。因为我们引发了一个TypeError，所以每当我们试图在age属性上设置一个非整数值时，程序就会停止运行。错误信息和回溯一起显示，告诉我们<em>在</em>哪里发生了错误。</p>
<h2 id="conclusion">结论</h2>
<p>简而言之，这就是室内装潢师！总之，这是一种非常强大的方法，可以更好地控制属性在类中的设置和格式化。通过使用自定义getters，您可以修改属性的显示方式。通过使用自定义设置器，您可以控制允许如何设置每个属性。</p>
<p>如果你想学习更多关于Python的知识，可以考虑参加我们的<a href="https://go.tecla.do/complete-python-sale">完整Python课程</a>，它将带你从初级到高级(包括OOP、web开发、异步开发等等！).我们有30天的退款保证，所以你试一试也不会有什么损失。我们很希望你能来！</p>
<p><small>照片由<a href="https://unsplash.com/@safarslife?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">萨法·萨法罗夫</a>在<a href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a>T5拍摄</small></p>
</div>
</div>    
</body>
</html>