<html>
<head>
<title>Day 9: Unpacking, Enumeration, and the zip Function | Teclado</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>第9天:解包、枚举和zip函数| Teclado</h1>
<blockquote>原文：<a href="https://blog.teclado.com/python-30-day-9-enumerate-zip/">https://blog.teclado.com/python-30-day-9-enumerate-zip/</a></blockquote><div><article class="pb-12 prose prose-p:font-copy col-start-2 dark:prose-invert">
                    
                    <p>欢迎来到<a href="https://blog.teclado.com/30-days-of-python/"> 30天Python </a>系列的第9天！今天我们来看看一个非常有用的迭代技术，叫做解包。我们还将探索几个新的函数:<code>enumerate</code>和<code>zip</code>。</p>
<p>如果你错过了昨天的帖子，我们讨论了一个非常重要的结构，叫做<code>while</code>循环，所以如果你不熟悉的话，我建议你看一下。</p>
<h2>拆包</h2>
<p>解包通常用于一次执行几个赋值，从一些iterable中提取单个值。这个过程也称为析构。</p>
<p>我们来看一个非常简单的案例。可能我有一个电影记录，是一个元组，里面有电影片名，导演名字，上映年份。我想做的是将这个元组的值赋给三个变量:<code>title</code>、<code>director</code>和<code>year</code>。</p>
<p>以我们目前的知识，我们必须做这样的事情:</p>
<div class="codehilite"><pre><span/><code><span class="n">movie</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"12 Angry Men"</span><span class="p">,</span> <span class="s2">"Sidney Lumet"</span><span class="p">,</span> <span class="mi">1957</span><span class="p">)</span>

<span class="n">title</span> <span class="o">=</span> <span class="n">movie</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">director</span> <span class="o">=</span> <span class="n">movie</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">year</span> <span class="o">=</span> <span class="n">movie</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</code></pre></div>

<p>不过这有点乏味，谢天谢地还有更好的方法。不用写单独的赋值和访问索引，我们可以简单地这样写:</p>
<div class="codehilite"><pre><span/><code><span class="n">movie</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"12 Angry Men"</span><span class="p">,</span> <span class="s2">"Sidney Lumet"</span><span class="p">,</span> <span class="mi">1957</span><span class="p">)</span>

<span class="n">title</span><span class="p">,</span> <span class="n">director</span><span class="p">,</span> <span class="n">year</span> <span class="o">=</span> <span class="n">movie</span>
</code></pre></div>

<p>这里发生的事情是Python看到我们有三个名字要分配，我们分配给它的元组有三个元素。因此，它从元组中抓取一个项目，一次一个，并按顺序将这些值分配给名称。</p>
<p>名称的数量必须与iterable中元素的数量相匹配，否则我们将会得到如下异常:</p>
<div class="codehilite"><pre><span/><code><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"main.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">3</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">title</span><span class="p">,</span> <span class="n">director</span><span class="p">,</span> <span class="n">year</span> <span class="o">=</span> <span class="n">movie</span>
<span class="ne">ValueError</span><span class="p">:</span> <span class="ow">not</span> <span class="n">enough</span> <span class="n">values</span> <span class="n">to</span> <span class="n">unpack</span> <span class="p">(</span><span class="n">expected</span> <span class="mi">3</span><span class="p">,</span> <span class="n">got</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div>

<p>这里我们不仅限于元组:我们可以使用列表或任何其他可迭代类型。这是非常有用的，我们可以在循环中使用这种技术达到很好的效果，正如我们将要看到的！</p>
<h2>在for循环中解包</h2>
<p>让我们回到我们的电影库示例，其中我们有一个包含几个电影元组的列表:</p>
<div class="codehilite"><pre><span/><code><span class="n">movies</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span>
        <span class="s2">"Eternal Sunshine of the Spotless Mind"</span><span class="p">,</span>
        <span class="s2">"Michel Gondry"</span><span class="p">,</span>
        <span class="mi">2004</span>
    <span class="p">),</span>
    <span class="p">(</span>
        <span class="s2">"Memento"</span><span class="p">,</span>
        <span class="s2">"Christopher Nolan"</span><span class="p">,</span>
        <span class="mi">2000</span>
    <span class="p">),</span>
    <span class="p">(</span>
        <span class="s2">"Requiem for a Dream"</span><span class="p">,</span>
        <span class="s2">"Darren Aronofsky"</span><span class="p">,</span>
        <span class="mi">2000</span>
    <span class="p">)</span>
<span class="p">]</span>
</code></pre></div>

<p>当我们第一次看for循环时，我们有一个例子，我们以一种很好的方式为用户打印这些元组的值，这样他们就可以看到他们所有的电影。</p>
<p>该循环如下所示:</p>
<div class="codehilite"><pre><span/><code><span class="n">movies</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span>
        <span class="s2">"Eternal Sunshine of the Spotless Mind"</span><span class="p">,</span>
        <span class="s2">"Michel Gondry"</span><span class="p">,</span>
        <span class="mi">2004</span>
    <span class="p">),</span>
    <span class="p">(</span>
        <span class="s2">"Memento"</span><span class="p">,</span>
        <span class="s2">"Christopher Nolan"</span><span class="p">,</span>
        <span class="mi">2000</span>
    <span class="p">),</span>
    <span class="p">(</span>
        <span class="s2">"Requiem for a Dream"</span><span class="p">,</span>
        <span class="s2">"Darren Aronofsky"</span><span class="p">,</span>
        <span class="mi">2000</span>
    <span class="p">)</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">movie</span> <span class="ow">in</span> <span class="n">movies</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">movie</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">movie</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">), by </span><span class="si">{</span><span class="n">movie</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>

<p>这个循环工作完全正常，但是有一点不好的是，这些值真的不透明。什么是<code>movie[0]</code>？我们真的得回去看看电影列表，把这个弄清楚。如果我们能在这里使用好听的、描述性的名字，那就更好了。</p>
<p>我们来想想迭代<code>movies</code>的时候是怎么回事。对于每次迭代，<code>movies</code>将会给我们一个元组，我们将会把这个值赋给<code>movie</code>。</p>
<p>如果我们仔细想想，这和这样做很相似:</p>
<div class="codehilite"><pre><span/><code><span class="n">movie</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"Memento"</span><span class="p">,</span> <span class="s2">"Christopher Nolan"</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
</code></pre></div>

<p>我们有一个名字，<code>movie</code>，我们给它分配一个元组。在这种情况下，我们有来自<code>movies</code>列表的第二个元组。</p>
<p>然而，我们刚刚看到了一个这样的元组被解包成三个变量的例子，如下所示:</p>
<div class="codehilite"><pre><span/><code><span class="n">title</span><span class="p">,</span> <span class="n">director</span><span class="p">,</span> <span class="n">year</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"Memento"</span><span class="p">,</span> <span class="s2">"Christopher Nolan"</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
</code></pre></div>

<p>事实证明，我们可以在for循环中做完全相同的事情:</p>
<div class="codehilite"><pre><span/><code><span class="n">movies</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span>
        <span class="s2">"Eternal Sunshine of the Spotless Mind"</span><span class="p">,</span>
        <span class="s2">"Michel Gondry"</span><span class="p">,</span>
        <span class="mi">2004</span>
    <span class="p">),</span>
    <span class="p">(</span>
        <span class="s2">"Memento"</span><span class="p">,</span>
        <span class="s2">"Christopher Nolan"</span><span class="p">,</span>
        <span class="mi">2000</span>
    <span class="p">),</span>
    <span class="p">(</span>
        <span class="s2">"Requiem for a Dream"</span><span class="p">,</span>
        <span class="s2">"Darren Aronofsky"</span><span class="p">,</span>
        <span class="mi">2000</span>
    <span class="p">)</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">title</span><span class="p">,</span> <span class="n">director</span><span class="p">,</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">movies</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">), by </span><span class="si">{</span><span class="n">director</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>

<p>对于循环的每次迭代，<code>movies</code>给我们一个元组。Python看到元组中有三个值，我们定义了三个名称。因此，它获取元组中的第一项，并将其分配给名称<code>title</code>；它获取第二个项目并将其分配给<code>director</code>；它获取第三个值并将其分配给<code>year</code>。</p>
<p>通过在这里使用解包，我们使得我们的<code>print</code>调用更具可读性，因为我们有清晰的描述性名称，而不是引用索引。</p>
<p>如果你想了解更多关于这项技术的知识，我们有一个<a href="https://blog.teclado.com/destructuring-in-python/">博客帖子，里面有更详细的内容</a>。</p>
<h2>列举</h2>
<p>解包的一个常见应用是使用名为<code>enumerate</code>的函数。</p>
<p>在我们看函数本身之前，我想给我们的打印循环添加一个功能。和电影信息一样，我希望每一行都以一个数字开始，它代表电影的顺序。</p>
<p>换句话说，我想要这样的输出:</p>
<div class="codehilite"><pre><span/><code><span class="mf">1.</span> <span class="n">Eternal</span> <span class="n">Sunshine</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Spotless</span> <span class="n">Mind</span> <span class="p">(</span><span class="mi">2004</span><span class="p">),</span> <span class="n">by</span> <span class="n">Michel</span> <span class="n">Gondry</span>
<span class="mf">2.</span> <span class="n">Memento</span> <span class="p">(</span><span class="mi">2000</span><span class="p">),</span> <span class="n">by</span> <span class="n">Christopher</span> <span class="n">Nolan</span>
<span class="mf">3.</span> <span class="n">Requiem</span> <span class="k">for</span> <span class="n">a</span> <span class="n">Dream</span> <span class="p">(</span><span class="mi">2000</span><span class="p">),</span> <span class="n">by</span> <span class="n">Darren</span> <span class="n">Aronofsky</span>
</code></pre></div>

<p>我们该怎么做呢？</p>
<p>通过某种方式，我们需要生成某种计数器。下面是我经常看到的解决这个问题的一个非常常见的方法:</p>
<div class="codehilite"><pre><span/><code><span class="n">movies</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span>
        <span class="s2">"Eternal Sunshine of the Spotless Mind"</span><span class="p">,</span>
        <span class="s2">"Michel Gondry"</span><span class="p">,</span>
        <span class="mi">2004</span>
    <span class="p">),</span>
    <span class="p">(</span>
        <span class="s2">"Memento"</span><span class="p">,</span>
        <span class="s2">"Christopher Nolan"</span><span class="p">,</span>
        <span class="mi">2000</span>
    <span class="p">),</span>
    <span class="p">(</span>
        <span class="s2">"Requiem for a Dream"</span><span class="p">,</span>
        <span class="s2">"Darren Aronofsky"</span><span class="p">,</span>
        <span class="mi">2000</span>
    <span class="p">)</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">movies</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">movies</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">movies</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">), by </span><span class="si">{</span><span class="n">movies</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>

<p>非常明确地说，虽然这种解决方案很常见，但它不是一个好的解决方案。这显然很难读懂，我们已经失去了所有伟大的名字。</p>
<p>为了完整起见，让我们来谈谈这是如何工作的，因为我保证你会在某个时候看到这样的解决方案。</p>
<p>首先，我们调用这个名为<code>len</code>的函数来查找<code>movies</code>列表中有多少部电影。在我们的例子中，有<code>3</code>电影，所以<code>len(movies)</code>将评估到<code>3</code>。</p>
<p>这个值<code>3</code>然后被传递到<code>range</code>中。正如我们在第6天看到的，如果我们向<code>range</code>传递一个值，它会给出从<code>0</code>到(但不包括)我们传入的数字的一系列值。我们的<code>range</code>因此看起来是这样的:</p>


<p><code>range</code>是一个可迭代的，它给我们的第一个值是<code>0</code>，我们将其命名为<code>index</code>。然后我们使用这个值在<code>movies</code>中查找电影元组。</p>
<p>记住<code>movies[0]</code>会给我们列表中的第一部电影，<code>movies[1]</code>给我们第二个值，以此类推。</p>
<p>当我们遍历<code>range</code>值时，数字会增加，最终我们会依次查看每部电影。对于每个电影元组，我们使用另一个订阅表达式(方括号语法)访问我们想要的数据，就像我们以前做的那样。</p>
<p><code>index</code>也是我们的柜台。对于第一次迭代，它是<code>0</code>，所以我们只需要给它加上<code>1</code>就可以得到印在我们第一部电影旁边的数字<code>1</code>。然后它每次增加<code>1</code>，在打印输出开始时给我们一个递增的计数器。</p>
<p>好吧，这不是一个很好的解决方案，但是有什么更好的方法呢？好吧，我们可以在循环之外定义一个计数器，然后我们可以在每次迭代中递增计数器:</p>
<div class="codehilite"><pre><span/><code><span class="n">movies</span> <span class="o">=</span> <span class="p">[</span> <span class="o">...</span> <span class="p">]</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">title</span><span class="p">,</span> <span class="n">director</span><span class="p">,</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">movies</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">), by </span><span class="si">{</span><span class="n">director</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>

<p>我们以前没有见过这种<code>+=</code>语法，但是<code>counter += 1</code>是这样写的简写:</p>


<p>这是一个更好的解决方案，但我们现在有这本书保持不变，我真的不喜欢这样。在我看来，更好的解决方案是使用<code>enumerate</code>。</p>
<p><code>enumerate</code>是一个内置函数，它在iterable中的值旁边生成一个计数器。我们最终得到的是一系列元组，其中每个元组中的第一项是计数器，第二个值是iterable中的原始项。</p>
<p>我们先来看一个简单的例子。我只想创建一个名字列表旁边的计数器。我们可以这样做:</p>
<div class="codehilite"><pre><span/><code><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Harry"</span><span class="p">,</span> <span class="s2">"Rachel"</span><span class="p">,</span> <span class="s2">"Brian"</span><span class="p">]</span>

<span class="k">for</span> <span class="n">counter</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>

<p>在这种情况下,<code>enumerate</code>包含的是这样的一系列元组:</p>
<div class="codehilite"><pre><span/><code><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">"Harry"</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">"Rachel"</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">"Brian"</span><span class="p">)</span>
</code></pre></div>

<p>我们的输出看起来像这样:</p>
<div class="codehilite"><pre><span/><code><span class="mf">0.</span> <span class="n">Harry</span>
<span class="mf">1.</span> <span class="n">Rachel</span>
<span class="mf">2.</span> <span class="n">Brian</span>
</code></pre></div>

<p>这并不是我想要的，因为我想要值从<code>1</code>开始。这很容易解决，因为我们可以在调用<code>enumerate</code>时为计数器设置一个初始值:</p>
<div class="codehilite"><pre><span/><code><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Harry"</span><span class="p">,</span> <span class="s2">"Rachel"</span><span class="p">,</span> <span class="s2">"Brian"</span><span class="p">]</span>

<span class="k">for</span> <span class="n">counter</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>

<p>现在我们得到了我们想要的输出:</p>
<div class="codehilite"><pre><span/><code><span class="mf">1.</span> <span class="n">Harry</span>
<span class="mf">2.</span> <span class="n">Rachel</span>
<span class="mf">3.</span> <span class="n">Brian</span>
</code></pre></div>

<p>让我们回到最初的电影例子。这里的事情不太容易，因为我们的每个项目本身就是一个元组。我们可以这样做:</p>
<div class="codehilite"><pre><span/><code><span class="n">movies</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span>
        <span class="s2">"Eternal Sunshine of the Spotless Mind"</span><span class="p">,</span>
        <span class="s2">"Michel Gondry"</span><span class="p">,</span>
        <span class="mi">2004</span>
    <span class="p">),</span>
    <span class="p">(</span>
        <span class="s2">"Memento"</span><span class="p">,</span>
        <span class="s2">"Christopher Nolan"</span><span class="p">,</span>
        <span class="mi">2000</span>
    <span class="p">),</span>
    <span class="p">(</span>
        <span class="s2">"Requiem for a Dream"</span><span class="p">,</span>
        <span class="s2">"Darren Aronofsky"</span><span class="p">,</span>
        <span class="mi">2000</span>
    <span class="p">)</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">counter</span><span class="p">,</span> <span class="n">movie</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">movies</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">movie</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">movie</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">), by </span><span class="si">{</span><span class="n">movie</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>

<p>这里<code>enumerate</code>的结果是这样的:</p>
<div class="codehilite"><pre><span/><code><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s2">"Eternal Sunshine of the Spotless Mind"</span><span class="p">,</span> <span class="s2">"Michel Gondry"</span><span class="p">,</span> <span class="mi">2004</span><span class="p">)),</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="s2">"Memento"</span><span class="p">,</span> <span class="s2">"Christopher Nolan"</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)),</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="s2">"Requiem for a Dream"</span><span class="p">,</span> <span class="s2">"Darren Aronofsky"</span><span class="p">,</span> <span class="mi">2000</span><span class="p">))</span>
</code></pre></div>

<p>所以<code>counter</code>取第一个位置的每个数字的值(<code>1</code>、<code>2</code>和<code>3</code>)。而<code>movie</code>在第二个位置取每个元组的值(比如<code>("Memento", "Christopher Nolan", 2000)</code>)。</p>
<p>然而，我仍然希望能够将这个电影元组解包到我们之前拥有的这些描述性变量名称中。但是我们如何解开像这样的东西:</p>
<div class="codehilite"><pre><span/><code><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="s2">"Memento"</span><span class="p">,</span> <span class="s2">"Christopher Nolan"</span><span class="p">,</span> <span class="mi">2000</span><span class="p">))</span>
</code></pre></div>

<p>我们所要做的就是匹配我们要打开的东西的结构。这里我们有一个两个元素的元组，其中第二项是一个三个元素的元组。所以我们可以像这样解开上面的结构:</p>
<div class="codehilite"><pre><span/><code><span class="n">counter</span><span class="p">,</span> <span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">director</span><span class="p">,</span> <span class="n">year</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="s2">"Memento"</span><span class="p">,</span> <span class="s2">"Christopher Nolan"</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
</code></pre></div>

<p>在我们的循环中，我们只需要做同样的事情:</p>
<div class="codehilite"><pre><span/><code><span class="n">movies</span> <span class="o">=</span> <span class="p">[</span> <span class="o">...</span> <span class="p">]</span>

<span class="k">for</span> <span class="n">counter</span><span class="p">,</span> <span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">director</span><span class="p">,</span> <span class="n">year</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">movies</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">), by </span><span class="si">{</span><span class="n">director</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>

<p>注意这里的括号<strong>是</strong>真的很重要。如果我们写这个，</p>
<div class="codehilite"><pre><span/><code><span class="n">movies</span> <span class="o">=</span> <span class="p">[</span> <span class="o">...</span> <span class="p">]</span>

<span class="k">for</span> <span class="n">counter</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">director</span><span class="p">,</span> <span class="n">year</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">movies</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">), by </span><span class="si">{</span><span class="n">director</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>

<p>我们将得到一个<code>ValueError</code>，因为我们提供了四个名称，但只有两个值:计数器和电影元组。通过使用这些括号，我们指定我们希望将第二个值(元组)分解成三个独立的名称。</p>
<h2><code>zip</code>功能</h2>
<p>是一个非常强大和通用的函数，用于将两个或更多的可重复项合并成一个可重复项。</p>
<p>例如，假设我们有两个这样的列表:</p>
<div class="codehilite"><pre><span/><code><span class="n">pet_owners</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Paul"</span><span class="p">,</span> <span class="s2">"Andrea"</span><span class="p">,</span> <span class="s2">"Marta"</span><span class="p">]</span>
<span class="n">pets</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Fluffy"</span><span class="p">,</span> <span class="s2">"Bubbles"</span><span class="p">,</span> <span class="s2">"Captain Catsworth"</span><span class="p">]</span>
</code></pre></div>

<p><code>zip</code>将允许我们把它变成一个新的iterable，它包含以下内容:</p>
<div class="codehilite"><pre><span/><code><span class="p">(</span><span class="s2">"Paul"</span><span class="p">,</span> <span class="s2">"Fluffy"</span><span class="p">),</span> <span class="p">(</span><span class="s2">"Andrea"</span><span class="p">,</span> <span class="s2">"Bubbles"</span><span class="p">),</span> <span class="p">(</span><span class="s2">"Marta"</span><span class="p">,</span> <span class="s2">"Captain Catsworth"</span><span class="p">)</span>
</code></pre></div>

<p>本质上，它从每个iterable中取出第一项，并把它们放在一个tuple中。然后从每个iterable中取出第二个项目，依此类推，直到其中一个iterable的值用完。我们稍后会回到这一点，因为它真的很重要。</p>
<p>要使用<code>zip</code>，我们所要做的就是调用函数并传入我们想要压缩在一起的iterables。</p>
<div class="codehilite"><pre><span/><code><span class="n">pet_owners</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Paul"</span><span class="p">,</span> <span class="s2">"Andrea"</span><span class="p">,</span> <span class="s2">"Marta"</span><span class="p">]</span>
<span class="n">pets</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Fluffy"</span><span class="p">,</span> <span class="s2">"Bubbles"</span><span class="p">,</span> <span class="s2">"Captain Catsworth"</span><span class="p">]</span>

<span class="n">pets_and_owners</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pet_owners</span><span class="p">,</span> <span class="n">pets</span><span class="p">)</span>
</code></pre></div>

<p>如果我们想把三个甚至更多的iterables压缩在一起，我们可以在调用它的时候把越来越多的iterables传递给<code>zip</code>。</p>
<p>与<code>range</code>非常相似，<code>zip</code>是懒惰的，这意味着它只在我们请求它的时候计算下一个值。因此我们不能直接打印它，但是如果我们想看到输出，我们可以把它转换成类似列表的东西:</p>
<div class="codehilite"><pre><span/><code><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">pets_and_owners</span><span class="p">))</span>

<span class="c1"># [('Paul', 'Fluffy'), ('Andrea', 'Bubbles'), ('Marta', 'Captain Catsworth')]</span>
</code></pre></div>

<h2>在循环中使用<code>zip</code></h2>
<p>另一种使用<code>zip</code>的常见方式是在for循环中一次迭代两个或更多的iterables。</p>
<p>让我们回到宠物主人的例子，但是现在我想打印一些描述谁拥有哪只宠物的输出。</p>
<p>我们可以使用<code>zip</code>和一点析构来以一种非常清晰的方式做到这一点，因为我们可以在循环中使用清晰的变量名:</p>
<div class="codehilite"><pre><span/><code><span class="n">pet_owners</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Paul"</span><span class="p">,</span> <span class="s2">"Andrea"</span><span class="p">,</span> <span class="s2">"Marta"</span><span class="p">]</span>
<span class="n">pets</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Fluffy"</span><span class="p">,</span> <span class="s2">"Bubbles"</span><span class="p">,</span> <span class="s2">"Captain Catsworth"</span><span class="p">]</span>

<span class="k">for</span> <span class="n">owner</span><span class="p">,</span> <span class="n">pet</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pet_owners</span><span class="p">,</span> <span class="n">pets</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">owner</span><span class="si">}</span><span class="s2"> owns </span><span class="si">{</span><span class="n">pet</span><span class="si">}</span><span class="s2">."</span><span class="p">)</span>
</code></pre></div>

<p>使用<code>zip</code>的常见替代方式是我们前面看到的使用<code>enumerate</code>的讨厌的<code>range</code> + <code>len</code>模式。我建议不惜一切代价避免这种情况！</p>
<h2>使用<code>enumerate</code>和<code>zip</code>时的注意事项</h2>
<p>当涉及到<code>enumerate</code>和<code>zip</code>时，你应该知道的一件事是，当我们对它们进行迭代时，它们被消耗掉了。当我们在循环中直接使用它们时，这通常不是问题，但当新开发人员将<code>zip</code>或<code>enumerate</code>对象赋给变量时，这有时会出错。</p>
<p>这里有一个例子，我们将调用<code>zip</code>的结果赋给一个变量:</p>
<div class="codehilite"><pre><span/><code><span class="n">movie_titles</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">"Forrest Gump"</span><span class="p">,</span>
    <span class="s2">"Howl's Moving Castle"</span><span class="p">,</span>
    <span class="s2">"No Country for Old Men"</span>
<span class="p">]</span>

<span class="n">movie_directors</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">"Robert Zemeckis"</span><span class="p">,</span>
    <span class="s2">"Hayao Miyazaki"</span><span class="p">,</span>
    <span class="s2">"Joel and Ethan Coen"</span>
<span class="p">]</span>

<span class="n">movies</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">movie_titles</span><span class="p">,</span> <span class="n">movie_directors</span><span class="p">)</span>
</code></pre></div>

<p>我们可以毫无问题地迭代电影:</p>
<div class="codehilite"><pre><span/><code><span class="k">for</span> <span class="n">title</span><span class="p">,</span> <span class="n">director</span> <span class="ow">in</span> <span class="n">movies</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s2"> by </span><span class="si">{</span><span class="n">director</span><span class="si">}</span><span class="s2">."</span><span class="p">)</span>
</code></pre></div>

<p>然而，如果我们现在再次尝试使用<code>movies</code>，我们会发现它是空的。尝试运行下面的代码来查看这一点:</p>
<div class="codehilite"><pre><span/><code><span class="n">movie_titles</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">"Forrest Gump"</span><span class="p">,</span>
    <span class="s2">"Howl's Moving Castle"</span><span class="p">,</span>
    <span class="s2">"No Country for Old Men"</span>
<span class="p">]</span>

<span class="n">movie_directors</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">"Robert Zemeckis"</span><span class="p">,</span>
    <span class="s2">"Hayao Miyazaki"</span><span class="p">,</span>
    <span class="s2">"Joel and Ethan Coen"</span>
<span class="p">]</span>

<span class="n">movies</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">movie_titles</span><span class="p">,</span> <span class="n">movie_directors</span><span class="p">)</span>

<span class="k">for</span> <span class="n">title</span><span class="p">,</span> <span class="n">director</span> <span class="ow">in</span> <span class="n">movies</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s2"> by </span><span class="si">{</span><span class="n">director</span><span class="si">}</span><span class="s2">."</span><span class="p">)</span>

<span class="n">movies_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">movies</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">movies_list</span><span class="p">)</span><span class="si">}</span><span class="s2"> movies in the collection."</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"These are our movies: </span><span class="si">{</span><span class="n">movies_list</span><span class="si">}</span><span class="s2">."</span><span class="p">)</span>
</code></pre></div>

<p>如果您尝试在初始循环后迭代<code>movies</code>，您还会发现它不包含任何值。</p>
<p>发生这种情况的原因是因为<code>zip</code>和<code>enumerate</code>产生了一个叫做<em>迭代器</em>的东西。在本系列中，我们不会深入讨论迭代器，因为迭代器是一个高级主题，但是迭代器的一个关键特性是，当我们请求它们的值时，它们就被消耗掉了。这实际上是一个非常有用的特性，但是如果你不熟悉这种行为，这也是一个常见的错误来源。</p>
<p>绕过这个限制的一个简单方法是将迭代器转换成非迭代器集合，比如列表或元组。</p>
<div class="codehilite"><pre><span/><code><span class="n">movie_titles</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">"Forrest Gump"</span><span class="p">,</span>
    <span class="s2">"Howl's Moving Castle"</span><span class="p">,</span>
    <span class="s2">"No Country for Old Men"</span>
<span class="p">]</span>

<span class="n">movie_directors</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">"Robert Zemeckis"</span><span class="p">,</span>
    <span class="s2">"Hayao Miyazaki"</span><span class="p">,</span>
    <span class="s2">"Joel and Ethan Coen"</span>
<span class="p">]</span>

<span class="n">movies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">movie_titles</span><span class="p">,</span> <span class="n">movie_directors</span><span class="p">))</span>
</code></pre></div>

<p>现在我们可以任意多次访问<code>movies</code>中的值。</p>
<h2>练习</h2>
<p>1)以下是一些关于BoJack Horseman中角色的简单数据:</p>
<div class="codehilite"><pre><span/><code><span class="n">main_characters</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">"BoJack Horseman"</span><span class="p">,</span> <span class="s2">"Will Arnett"</span><span class="p">,</span> <span class="s2">"Horse"</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">"Princess Carolyn"</span><span class="p">,</span> <span class="s2">"Amy Sedaris"</span><span class="p">,</span> <span class="s2">"Cat"</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">"Diane Nguyen"</span><span class="p">,</span> <span class="s2">"Alison Brie"</span><span class="p">,</span> <span class="s2">"Human"</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">"Mr. Peanutbutter"</span><span class="p">,</span> <span class="s2">"Paul F. Tompkins"</span><span class="p">,</span> <span class="s2">"Dog"</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">"Todd Chavez"</span><span class="p">,</span> <span class="s2">"Aaron Paul"</span><span class="p">,</span> <span class="s2">"Human"</span><span class="p">)</span>
<span class="p">]</span>
</code></pre></div>

<p>这些数据包含角色的名字、配音演员和角色的种类。</p>
<p>编写一个使用析构的for循环，以便可以按以下格式打印每个元组:</p>
<div class="codehilite"><pre><span/><code><span class="n">BoJack</span> <span class="n">Horseman</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">horse</span> <span class="n">voiced</span> <span class="n">by</span> <span class="n">Will</span> <span class="n">Arnet</span><span class="o">.</span>
</code></pre></div>

<p>请注意，在打印时，您必须将物种信息改为小写。如果您需要一个关于如何做到这一点的提示，我们在第一周的第3天已经介绍过了。</p>
<p>2)将以下元组解包为4个变量:</p>
<div class="codehilite"><pre><span/><code><span class="p">(</span><span class="s2">"John Smith"</span><span class="p">,</span> <span class="mi">11743</span><span class="p">,</span> <span class="p">(</span><span class="s2">"Computer Science"</span><span class="p">,</span> <span class="s2">"Mathematics"</span><span class="p">))</span>
</code></pre></div>

<p>这些数据依次表示学生的姓名、学号以及主修和辅修科目。</p>
<p>3)调查当您尝试压缩两个不同长度的可重复项时会发生什么。例如，尝试压缩一个包含三项的列表和一个包含四项的元组。</p>
<p>你可以在这里找到我们的练习<a href="/30-days-of-python/python-30-day-9-exercise-solutions">的答案。</a></p>
<h2>项目</h2>
<p>一旦你完成了练习，我们今天会为你安排另一个项目。这次我们要写一个简短的程序来验证信用卡！</p>
<h2>额外资源</h2>
<p>如果你想了解更多关于拆包的知识，我们有一篇<a href="https://blog.teclado.com/destructuring-in-python/">博客文章，其中有更详细的内容</a>。</p>
<p>我们还有一篇关于<code>enumerate</code>的博文，你可以在这里找到<a href="https://blog.teclado.com/python-enumerate/">，还有一篇关于<code>zip</code>的博文，你可以在这里</a>看到<a href="https://blog.teclado.com/python-zip/">。</a></p>
<p>除了所有这些，我们有一个帖子谈论另一个叫做<code>zip_longest</code>的函数。这允许我们在不丢失数据的情况下压缩不同大小的集合，但是它需要一些我们还没有研究过的技术，比如从其他文件导入代码。如果你感兴趣，你可以在这里找到那个帖子。</p> 
                </article>
            
            </div>    
</body>
</html>