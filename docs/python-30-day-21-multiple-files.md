# 第 21 天:将代码分割成多个文件

> 原文：<https://blog.teclado.com/python-30-day-21-multiple-files/>

欢迎来到 Python 系列 [30 天的第 21 天！今天我们将学习如何(以及为什么)将我们的 Python 代码分割成多个文件。](https://blog.teclado.com/30-days-of-python/)

首先，我们将快速回顾一下 Python 中导入的工作原理。我们开始吧！

## Python 中的导入概述

在这种情况下，做一个快速的回顾是值得的，因为在开始为我们的程序创建大量文件之前，我们理解一些要点是很重要的！

如果你想要更全面的东西，请随意重读我们第一次讨论进口的 [day 18](/30-days-of-python/python-30-day-18-imports) 帖子。

### 导入会给`globals()`添加一个名称

如果您有一个 Python 文件，并键入以下内容:

```py
`import json

print(globals())` 
```

然后显示当前全局名称空间中的*名称*。模块名称将位于全局名称空间中，可供您使用。

### 导入允许我们访问导入模块的元素

导入后，我们可以像这样访问模块内部的内容:

```py
`import math

print(math.pi)  # 3.14` 
```

我们已经访问了`math`模块中的`pi` *名称*。在这种情况下，这是数学常数 pi 的值。

#### 其他导入方式

您可以使用`as`关键字在您的代码中给导入的模块一个不同的名称。我不建议你这样做，尽管你会不时地看到有人这样做！

您还可以使用`*`将*模块中的几乎所有*添加到您的全局名称空间中。这会“污染”全局名称空间，用变量填充它。大多数时候，这是强烈反对的。

## 为什么要把你的代码分成文件呢？

现在我们已经快速概括了导入的主题，让我们来讨论一下*为什么*我们可能想要将我们的代码分割成多个文件！

当我们开始讨论这个问题时，我们得到的第一个问题是:“将代码保存在一个文件中不是更容易吗？”。

毕竟那你就不用处理进口了！

将您的代码保存在一个文件中可能会更容易编写(首先！)，但随着你写得越来越多，阅读和修改会变得更加困难。

在编程中，可读性和可维护性胜过任何一天的写作速度！

### 分离关注点和易于组织

当我们将代码分离到文件中时，我们有理由将一些代码放在某个文件中是很重要的。通常，我们称*为*。做一件事情的代码放在一个文件中，做不同事情的代码放在不同的文件中。

例如，我们可能有一个文件用于用户交互(打印和输入)，另一个文件用于数据存储(保存和检索文件中的内容)。

目前，Python 应用程序的不同关注点对您来说可能并不明显。那很正常！随着时间的推移，你会对此了解更多。有了更多的经验，它会变得更加清晰，当事情将受益于得到分割成文件。

假设我们给文件取了一个好的名字，通过关注点来分离文件，也有助于我们更容易地找到代码。如果你有两个叫做`data_storage.py`和`user_menu.py`的文件，你知道你会在每个文件中找到什么！

使用文件和文件夹也能给组织带来奇迹。例如，您可以将与不同类型的数据存储相关的文件放入一个文件夹中。

### 提高可读性

随着文件的增长，它们开始变得越来越难以阅读。您可能有许多函数和变量，查找东西可能需要大量滚动。

现代编辑器有一些功能可以更容易地找到事物定义的位置，但这并不是一个完美的解决方案。

将代码分割成多个文件是生成更小、更集中的文件的好方法。浏览这些更小的文件会更容易，理解每个文件的内容也会更容易。

### 更容易重用代码

当您有多个较小的集中文件时，通过导入可以更容易地在多个其他文件中重用一个文件的内容。

#### 文件太多

也有可能是*的*文件太多！不要试图让你的文件越小越好。相反，让他们集中注意力。

如果每个文件都与应用程序的一个方面有关，并且每个文件都有一个好名字，那么导航您的项目将会很容易！

## 使用两个文件

让我们开始进入一个新的 Python 项目(或 [repl.it](http://repl.it) repl)并创建两个文件。姑且称之为`main.py`和`myfile.py`。

记住当你按下“运行”按钮时 [repl.it](http://repl.it) 将一直运行`main.py`，正如我们在 [day 0](/30-days-of-python/python-30-day-0-getting-set-up/) 帖子中提到的。

因为两个文件都在同一个文件夹中，所以您可以从另一个文件夹中导入一个文件。

让我们把它输入`main.py`:

注意我们没有导入`myfile.py`，只是导入了`myfile`。Python 完成了剩下的工作！

### 导入时会发生什么

当我们导入一个文件时，Python *运行*该文件。它必须这样做，以便确定哪些**的名字**存在于该文件中。

然后，它通过在全局名称空间中放置一个对该模块的引用，使该文件在`main.py`中对我们可用。

让我们在`myfile.py`中增加一个`print`:

myfile.py

```py
`print("Hello, world!")` 
```

还有一个在`main.py`:

main.py

```py
`import myfile

print("What's going on?")` 
```

试试看。

你会看到我们打印出了两样东西:

```py
`Hello, world!
What's going on?` 
```

那是因为执行了`myfile.py`文件。它包含了一个`print`调用，所以因此 Python 把东西打印了出来！

您很少会编写这样的代码。相反，你导入的文件通常会包含**变量**和**函数**，所以当你导入它们的时候，实际上什么都不会发生，直到你*真正使用*这些变量和函数。

让我们给`myfile.py`加一点更真实的东西。也许是这样的:

myfile.py

```py
`def get_user_age():
    return int(input("Enter your age: "))` 
```

现在在`main.py`中，我们可以使用在`myfile.py`中定义的`get_user_age`函数。

main.py

```py
`import myfile

try:
    myfile.get_user_age()
except ValueError:
    print("That's not a valid value for your age!")` 
```

太好了！

这就是它的要点:把东西分成文件，然后导入它们！

#### 用(不)什么来命名你的文件

不要给你的文件起和内置模块一样的名字。

举个例子，如果你创建了一个新文件，并把它命名为`json.py`，你就会遇到麻烦！

这是因为如果另一个文件试图`import json`，您将无法导入内置的`json`模块，该模块允许我们与 JSON 文件对话。你将导入你的`json.py`文件！

Python 总是在查看内置或已安装的包之前查看项目文件夹中的导入文件*。*

### 文件的工作方式与模块相同

我们可以用外部模块做的一切，我们可以用自己的文件来做:

*   用`import myfile`导入整个文件，然后用`myfile.x`引用东西。
*   用`from myfile import x`导入具体的东西。
*   别名导入。
*   我们可以做`from myfile mport *`(虽然不鼓励)。

### 使用文件和文件夹

如果你认为有助于组织，你可以为你的文件创建文件夹。根据我的经验，通常是这样的。

例如，在您的项目中创建一个名为`user_interactions`的文件夹，并将`myfile.py`移动到其中。现在，您的文件/文件夹结构将如下所示:

```py
`- main.py
- user_interactions/
    | - myfile.py` 
```

从`main.py`开始，您现在必须使用稍微不同的语法来导入`myfile.py`:

main.py

```py
`from user_interactions.myfile import get_user_age

try:
    get_user_age()
except ValueError:
    print("That's not a valid value for your age!")` 
```

导入时，点(`.`)表示类似“内部”的意思。

在上面的例子中，我们因此从 `user_interactions`内部的*导入`myfile`。*

如果您有多个子文件夹，您将需要使用多个`.`来分隔不同级别的文件夹和文件，如下所示:

```py
`from folder.subfolder.module import something_in_the_module` 
```

当你像这样导入时，你要么像我们一样导入特定的东西，要么使用别名导入。这两个都好(第一个一般更好):

*   `from user_interactions.myfile import get_user_age`
*   `import user_interactions.myfile as interactions`

您通常不会像下面的示例那样做任何事情，因为它可能需要很长时间才能完成:

```py
`import user_interactions.myfile

user_interactions.myfile.get_user_age()` 
```

当你想使用某个东西时，你需要参考完整的导入，所以你会在你的代码中输入很多`user_interactions.myfile`！

如果您不经常使用该文件，也可以这样做。

### 脚本模式与模块模式

当我们运行一个文件时(例如在 [repl.it](http://repl.it) 中，就是`main.py`)，我们说这个文件是在“脚本模式”下运行的。

当我们导入一个文件时，该文件以“模块模式”运行。

目前我们的项目结构是这样的:

```py
`- main.py
- user_interactions/
    | - myfile.py` 
```

我将删除这两个文件的内容，并将其放入`myfile.py`:

我将在`main.py`中这样做:

main.py

```py
`import user_interactions.myfile

print(__name__)` 
```

您将看到以下输出:

```py
`user_interactions.myfile
__main__` 
```

请记住，当我们导入时，我们运行文件。因此第一行输出属于`myfile.py`，第二行输出属于`main.py`。

我们运行的文件总是有一个值为`"__main__"`的`__name__`变量。这就是 Python 告诉我们*我们运行了那个文件*的简单方式。

任何不具有等于`"__main__"`的`__name__`的文件都被导入。

试着移动东西，看看由`myfile.py`创建的输出是如何变化的！

### 仅在脚本模式下运行代码

有时我们希望在文件中包含一些代码，但是我们只希望在直接执行该文件时运行这些代码，而不是在导入文件时运行。

因为我们知道对于已经运行的文件来说,`__name__`必须等于`"__main__"`,所以我们可以使用 if 语句。

我们可以在`myfile.py`中输入:

myfile.py

```py
`def get_user_age():
    return int(input("Enter your age: "))

if __name__ == "__main__":
    get_user_age()` 
```

这可以让我们运行`myfile.py`(如果没有一些额外的配置，我们不能在 [repl.it](http://repl.it) 中这样做)，然后看看`get_user_age()`函数是否工作。

这是这个构造的一个关键用例:当我们通常不希望文件运行时，帮助我们查看文件中的内容是否有效。

另一个用例是您自己通常不运行的文件。例如，有时你可能写一个文件供另一个程序使用。

使用这种结构将允许您运行您的文件进行测试，同时当它被另一个程序导入时不会影响它的功能。

## 练习

对于今天的(唯一的)练习，我们给你一堆代码，它们都在一个文件中。

在此访问代码[。](https://repl.it/@tecladocode/30DaysOfPython-Day21-Exercise)

您的任务是将代码分成多个文件。您可以选择要将代码拆分成多少个文件以及哪些文件，但是请想想为什么要将每一部分代码放在每个文件中！

然后，当你完成时，看看[我们的练习解决方案](/30-days-of-python/python-30-day-21-exercise-solutions)，看看我们是如何分割代码的，以及为什么。

## 项目

对于今天的项目，我们将使用 Python 库来创建一些图表！作为这个项目的一部分，你必须很好地组织你的代码，这样它才不会变成一团乱麻。

查看项目简介，了解关于今天项目的更多信息。