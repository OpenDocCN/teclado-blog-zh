<html>
<head>
<title>Python: how to use multiple decorators on one function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python:如何在一个函数上使用多个装饰器</h1>
<blockquote>原文：<a href="https://blog.teclado.com/python-how-to-use-multiple-decorators-on-one-function/">https://blog.teclado.com/python-how-to-use-multiple-decorators-on-one-function/</a></blockquote><div><div class="post-content">
<p>希望你已经学习了Python中的decorators！这篇博文将讨论当你在一个函数上使用多个装饰器时会发生什么。</p><p>例如:</p><pre><code class="language-python">@user_has_permission
@user_name_starts_with_j
def double_decorator():
    return 'I ran.'
</code></pre>
<p>装饰者最常用于扩展一个函数，在函数之前或之后添加一些东西。</p><p>装饰器内部发生的事情是它改变了它所装饰的功能。它改变该功能并将其转换成具有附加功能的新功能。</p><p>所以如果我们有这个:</p><pre><code class="language-python">@user_name_starts_with_j
def decorated_function():
    return 'I ran.'
</code></pre>
<p><code>decorated_function</code>不再仅仅是<code>return 'I ran.'</code>。现在它变成了装饰者返回的任何东西。希望装饰器返回使用<code>decorated_function</code>的东西，这样它仍然返回<code>'I ran.'</code>！</p><p>假设<code>user_name_starts_with_j</code>装饰器做两件事:</p><ol><li>它检查用户名(不管是什么)是否以字母<code>'j'</code>开头。</li><li>如果是，那么它调用<code>decorated_function</code>。否则，它会打印一个错误。</li></ol><p>从定义<code>decorated_function</code>的那一刻起，它就变成了一个做上述事情的函数。现在每当我们调用<code>decorated_function()</code>，如果用户名不是以<code>'j'</code>开头，我们就会得到一个错误。我们不用再用<code>user_name_starts_with_j</code>了。</p><h2 id="two-decorators">两个装修工</h2><p>当你有两个装修工时，同样的事情也适用。让我们以这段代码为例:</p><pre><code class="language-python">@user_has_permission
@user_name_starts_with_j
def double_decorator():
    return 'I ran.'
</code></pre>
<p>首先，<code>@user_name_starts_with_j</code>修改<code>double_decorator</code>函数。</p><p>然后，<code>@user_has_permission</code>修改上一次修改的结果。</p><p><code>double_decorator</code>现在已经变成了<code>user_has_permission</code>返回的函数。这是一个功能:</p><ol><li>检查用户是否有正确的权限。</li><li>如果有，调用原始函数。否则，打印一个错误。</li></ol><p>所以当我们调用<code>double_decorator()</code>的时候，上面的情况首先发生。如果用户有正确的权限，我们调用原始函数——这是前面转换的结果。</p><p>因此，我们检查用户名是否以j开头。如果是，我们调用原始函数(并返回<code>'I ran.'</code>)。否则，我们将打印另一个错误。</p><p>所以两个装饰者的检查顺序变成了:</p><ol><li>检查许可。</li><li>检查用户名以j开头。</li><li>运行原始功能。</li></ol><p>正如您所看到的，装饰器运行的顺序与它们用来装饰函数的顺序相反——这是因为它们内部的工作方式。</p><h2 id="a-code-example">代码示例</h2><p>下面你可以使用示例代码。我用不同的用户名和访问级别定义了几个<code>user</code>变量，你可以试试。您也可以在浏览器中运行这段代码来查看输出！</p><p>感谢阅读！如果你想让你的Python技能更上一层楼，请查看我们的<a href="https://go.tecla.do/complete-python-sale">完整Python课程</a>！</p>
</div>
</div>    
</body>
</html>