<html>
<head>
<title>Python Comprehensions with Conditionals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>带条件的Python理解</h1>
<blockquote>原文：<a href="https://blog.teclado.com/python-list-comprehensions-conditionals/">https://blog.teclado.com/python-list-comprehensions-conditionals/</a></blockquote><div><div class="post-content">
<p>在我们的<a href="https://blog.teclado.com/python-list-comprehensions/">上一篇文章</a>中，我们介绍了列表理解，但是还有更多的内容要介绍。我们还可以在我们的列表理解中包含条件子句，以过滤掉我们不想包含在新列表中的项目。</p><p>在列表理解中包含一个条件从句是非常简单的。我们只需在循环定义后使用if关键字:</p><pre><code class="language-python">names = ["Matthew", "John", "Helen", "Stephen", "Alexandra", "Rolf"]
short_names = [name for name in names if len(name) &lt; 6]

# ['John', 'Helen', 'Rolf']
</code></pre>
<p>这里我们过滤掉所有超过5个字符的名字。</p><p>人们常犯的一个错误是把一个条件放在列表理解的开始。这是合法的语法，但完全是另外一种意思。</p><pre><code class="language-python">names = ["Matthew", "John", "Helen", "Stephen", "Alexandra", "Rolf"]
short_names = [len(name) &lt; 6 for name in names]

# [False, True, True, False, False, True]
</code></pre>
<p>这里，列表理解为<code>names</code>中的每个<code>name</code>添加一个布尔值到新列表中。这在适当的情况下非常有用，但通常不是您想要的。</p><p>与for子句一样，列表理解允许多个if子句按顺序出现:</p><pre><code class="language-python">names = ["Matthew", "John", "Helen", "Stephen", "Alexandra", "Rolf"]
short_final_n = [name for name in names if len(name) &lt; 6 if name[-1] == "n"]

# ['John', 'Helen']
</code></pre>
<p>这里的名字只有在长度都少于6个字符并且以<code>n</code>结尾时才会出现在我们的新列表中。我不太喜欢在理解中像这样将条件链接在一起，但肯定有这样的情况，它将是完全可读和容易理解的。</p><h2 id="wrapping-up">包扎</h2><p>如果你有兴趣学习更多关于list comprehensions的知识，一定要查看官方文档，或者尝试我们的<a href="https://go.tecla.do/complete-python-sale">完整Python课程</a>！</p><p>下面我们也有一个表格来注册我们的邮件列表。我们定期为我们的订户发布折扣代码，因此这是确保您在我们的课程中始终获得最优惠的方式。</p>
</div>
</div>    
</body>
</html>