<html>
<head>
<title>Decimal vs float in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python中的十进制与浮点</h1>
<blockquote>原文：<a href="https://blog.teclado.com/decimal-vs-float-in-python/">https://blog.teclado.com/decimal-vs-float-in-python/</a></blockquote><div><div class="post-content">
<p>在Python中处理十进制数时，我们通常会求助于浮点数。对于大多数目的来说，比如简单的划分，Floats为我们提供了很好的服务，但是它们也有一些限制，对于某些用例来说，这些限制会成为难以置信的问题。他们只是不够精确。然而，浮点并不是我们唯一的选择，今天我们将看看<code>decimal</code>模块，以及为什么你可能会使用它。</p><h2 id="a-quick-look-at-binary">快速浏览二进制</h2><p>在我们能够正确理解浮点数的问题之前，我们需要快速回顾一下数字是如何用二进制表示的。</p><p>我们在日常生活中使用的数字系统是以10为基数的数字系统，也称为十进制数字系统。我们使用十个不同组合的独特数字来代表所有数字。另一方面，二进制是以2为基数的数字系统，只使用两个唯一的数字:通常是0和1。当数字存储在我们的计算机中时，它们是以二进制格式存储的。</p><p>二进制数可能看起来像这样:10101101，恰好是173。</p><p>那么我们如何从10101101中得到173呢？</p><p>二进制是2的幂，所以10101101中最右边的1代表1×2⁰.然后我们向左移动一步，在这里我们找到一个0。这个0代表0 x 2，也就是0 x 2。再向左移动一步，我们找到另一个1，这次代表1 x 2，也就是4。每向左移动一步，功率增加1。</p><p>总的来说，我们有这样的东西:</p><p>(1 × 2⁷) + (0 × 2⁶) + (1 × 2⁵) + (0 × 2⁴) + (1 × 2³) + (1 × 2²) + (0 × 2¹) + (1 × 2⁰)</p><p>那就是:</p><p>(1 x 128)+(0 x 64)+(1 x 32)+(0 x 16)+(1 x 8)+(1 x 4)+(0 x 2)+(1 x 1)</p><p>如果我们把这些都加起来，我们会得到173。如你所见，数字的二进制表示比十进制表示要长得多，但是我们最终可以用这种方式表示任何整数。</p><h3 id="fractions-in-binary">二进制分数</h3><p>我们已经快速复习了如何用二进制表示整数，但是分数呢？事实证明，它的工作方式是一样的，只是有负的力量。</p><p>例如，2⁻是，2⁻是，这意味着我们现在可以表示0.75、0.5和0.25。使用逐渐增大的负幂，我们可以表示所有形式的十进制数。</p><p>然而，正如有些数字我们不能用有限的十进制数来表示(例如⅓)，也有一些数字我们不能用二进制来表示。例如，数字0.1没有有限的二进制表示。</p><h2 id="floats-in-python">Python中的浮点数</h2><p>那么当我们用Python写<code>0.1</code>时会发生什么呢？让我们来看看:</p><pre><code class="language-python">print(f"{0.1:.20f}")  # 0.10000000000000000555
</code></pre>
<p>对于那些不熟悉上面语法的人来说，<code>:.20f</code>是一种告诉Python我们想要这个浮点数小数点后20位的方式。我们有一个帖子，你可以在下面看看:</p><p><a href="https://blog.teclado.com/python-formatting-numbers-for-printing/">https://blog . tecladocode . com/python-formatting-numbers-for-printing/</a></p><p>正如我们所见，我们实际上并没有得到<code>0.1</code>:我们得到的是<code>0.1</code>的近似值。不幸的是，有时一个接近的近似值还不够好。</p><p>这在进行比较时尤其普遍:</p><pre><code class="language-python">a = 10
b = a / 77
c = b * 77

if a != c:
    print("Things got weird...")

# Things got weird...
</code></pre>
<p>如果我们打印<code>a</code>和<code>c</code>，我们可以看到发生了什么:</p><pre><code class="language-python">print(f"{a:.20f}")  # 10.00000000000000000000
print(f"{c:.20f}")  #  9.99999999999999822364
</code></pre>
<p>这种近似误差会在一系列运算中变得非常复杂，这意味着我们实际上可能会在应该相同的数字之间产生非常显著的差异。</p><p>你可以在Python文档中读到更多关于这些问题的内容:<a href="https://docs.python.org/3/tutorial/floatingpoint.html">https://docs.python.org/3/tutorial/floatingpoint.html</a></p><h2 id="enter-decimal">输入<code>decimal</code></h2><p>正如本文开头提到的，Python确实有另一种处理十进制数的方法，那就是<code>decimal</code>模块。与浮点不同，<code>decimal</code>模块中定义的<code>Decimal</code>对象不容易丢失精度，因为它们不依赖于二进制分数。</p><h2 id="creating-decimal-objects">创建<code>Decimal</code>对象</h2><p>在我们深入研究<code>Decimal</code>对象之前，让我们看看如何定义它们。实际上有几种方法可以做到这一点。</p><h3 id="using-an-integer">使用整数</h3><p>创建一个<code>Decimal</code>对象的第一种方法是使用一个整数。在这种情况下，我们简单地将整数作为参数传递给<code>Decimal</code>构造函数:</p><pre><code class="language-python">import decimal

x = decimal.Decimal(34)  # 34
</code></pre>
<p>我们现在可以像使用任何其他数字一样使用<code>x</code>，并且在执行数学运算时，我们将获得一个<code>Decimal</code>对象:</p><pre><code class="language-python">x = decimal.Decimal(34)

print(x + 7)         # 41
print(type(x + 7))   # &lt;class 'decimal.Decimal'&gt;

print(x // 7)        # 4
print(type(x // 7))  # &lt;class 'decimal.Decimal'&gt;
</code></pre>
<h3 id="using-a-string">使用字符串</h3><p>可能有点令人惊讶的是，用分数成分制作<code>Decimal</code>对象的最简单方法之一是使用字符串。我们只需要将数字的字符串表示传递给<code>Decimal</code>，剩下的事情就交给它了:</p><pre><code class="language-python">x = decimal.Decimal("0.1")

print(x)            # 0.1
print(f"{x:.20f}")  # 0.10000000000000000000
</code></pre>
<p>正如我们所看到的，在这里将<code>x</code>打印到20个小数位得到了19个零:我们不会像使用float时那样，在末尾随机出现一些5。</p><p>如果您需要一个数字的精确十进制表示，使用字符串创建您的<code>Decimal</code>对象是一个非常简单的方法。</p><h3 id="using-a-float">使用浮动</h3><p>也可以从一个float创建一个<code>Decimal</code>对象，但是我一般不建议这样做。下面的例子应该清楚地说明了原因:</p><pre><code class="language-python">x = decimal.Decimal(0.1)
print(x)  # 0.1000000000000000055511151231257827021181583404541015625
</code></pre>
<p>从float直接转换会导致我们的<code>Decimal</code>对象继承我们最初试图避免的所有不精确性。可能有些情况下，出于某种原因，您希望保留这种不精确性，但大多数时候，情况并非如此。</p><h3 id="using-a-tuple">使用元组</h3><p>也许创建<code>Decimal</code>对象最复杂的方法是使用元组，这种方法让我们对<code>Decimal</code>对象如何工作有了一些了解。</p><p>我们提供给<code>Decimal</code>的元组有三个部分。元组中的第一个元素要么是数字<code>0</code>要么是<code>1</code>，这代表数字的符号(无论它是正数还是负数)。第一个位置的0表示正数，而1表示负数。</p><p>元组中的第二项是另一个元组，它包含结果数中的所有数字。例如，数字<code>1.3042</code>有数字<code>(1, 3, 0, 4, 2)</code>。</p><p>元组中的第三个也是最后一个项目是指数。这告诉<code>Decimal</code>对象我们需要将小数点周围的数字移动多少位。<code>-3</code>的指数将导致数字向右移动3个空格，得到<code>13.042</code>，而<code>2</code>的指数将得到<code>1304200</code>。</p><p>数字<code>-13.042</code>的完整示例如下:</p><pre><code class="language-python">x = decimal.Decimal((1, (1, 3, 0, 4, 2), -3))
print(x)  # -13.042
</code></pre>
<p>这里要注意的一件非常重要的事情是，我们确实需要外层元组周围的括号，因为<code>Decimal</code>期望这个元组作为单个参数。移除外部括号将导致错误。</p><p>虽然相对复杂，但是元组语法最适合以编程方式创建<code>Decimal</code>对象。</p><h2 id="the-context-object"><code>Context</code>物体</h2><p>关于<code>decimal</code>模块的一个很酷的事情是它允许我们以各种方式定义<code>Decimal</code>对象的行为。我们可以指定精确度、指数极限，甚至舍入规则。</p><p>为了做到这一点，我们通常会使用<code>getcontext</code>函数，它允许我们查看和修改当前线程的<code>Context</code>对象。</p><p>让我们来看看默认的<code>Context</code>对象是什么样子的:</p><pre><code class="language-python">import decimal

print(decimal.getcontext())
# Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])
</code></pre>
<p>如您所见，我们可以设置各种属性来更改<code>Decimal</code>对象的工作方式。</p><p>例如，我们可能决定需要10个有效数字的精度，我们可以这样设置:</p><pre><code class="language-python">import decimal

decimal.getcontext().prec = 10
x = decimal.Decimal(1) / decimal.Decimal(7)

print(x)  # 0.1428571429
</code></pre>
<p>请注意，这个新的精度仅在数学运算期间相关。我们可以用任意精度定义一个<code>Decimal</code>对象，即使我们使用<code>getcontext</code>设置了较低的精度。</p><pre><code class="language-python">import decimal

decimal.getcontext().prec = 10

x = decimal.Decimal("1.045753453457657657")
y = decimal.Decimal(7)

print(x)      # 1.045753453457657657
print(y)      # 7
print(x / y)  # 0.1493933505
</code></pre>
<p>正如我前面提到的，我们还可以定义如何对<code>Decimal</code>对象进行舍入，这非常有用。默认情况下，Python使用银行家舍入法，这与我们在学校学到的舍入法有些不同。</p><p>如果你不熟悉的话，我们在这里讨论银行家的四舍五入:<a href="https://blog.teclado.com/rounding-in-python/">https://blog.tecladocode.com/rounding-in-python/</a></p><p>使用<code>getcontext</code>,我们可能会改变Python的舍入行为，使以<code>5</code>结尾的小数总是远离<code>0</code>,这就是我们在日常生活中的舍入方式:</p><pre><code class="language-python">import decimal

decimal.getcontext().prec = 1

x = decimal.Decimal(5)
y = decimal.Decimal(2)

print(x / y)  # 2

decimal.getcontext().rounding = decimal.ROUND_HALF_UP

print(x / y)  # 3
</code></pre>
<p>使用常量在<code>decimal</code>模块中定义了许多不同的舍入行为。您可以在这里了解更多可用选项:<a href="https://docs.python.org/3.7/library/decimal.html#module-decimal">https://docs . python . org/3.7/library/decimal . html # module-decimal</a></p><h2 id="some-useful-decimal-methods">一些有用的<code>decimal</code>方法</h2><p><code>decimal</code>模块提供了许多处理<code>Decimal</code>对象的简便方法。这里有一些你可能想看看。</p><h3 id="sqrt"><code>sqrt</code></h3><p><code>sqrt</code>方法允许我们以指定的精度获得任意<code>Decimal</code>的平方根。</p><pre><code class="language-python">import decimal

decimal.getcontext().prec = 15
x = decimal.Decimal(2).sqrt()

print(x)  # 1.41421356237310
</code></pre>
<h3 id="quantize"><code>quantize</code></h3><p><code>quantize</code>方法用于将<code>Decimal</code>对象更改为新的指数。例如，假设我们有一个数字<code>1.41421356</code>，我们想改变这个数字来匹配模式<code>1.000</code>，我们可以写如下:</p><pre><code class="language-python">import decimal

x = decimal.Decimal("1.41421356")
y = x.quantize(decimal.Decimal("1.000"))

print(y)  # 1.414
</code></pre>
<p>使用<code>quantize</code>方法需要注意的一点是，如果最终值超过了定义的精度级别，它将引发一个<code>InvalidOperation</code>异常。</p><pre><code class="language-python">import decimal

decimal.getcontext().prec = 1

x = decimal.Decimal("1.41421356")
y = x.quantize(decimal.Decimal("1.000"))

# decimal.InvalidOperation: [&lt;class 'decimal.InvalidOperation'&gt;]
</code></pre>
<h3 id="as_tuple"><code>as_tuple</code></h3><p><code>as_tuple</code>方法给了我们一个<code>Decimal</code>对象的元组表示，就像我们使用元组语法创建一个对象一样。</p><pre><code class="language-python">import decimal

x = decimal.Decimal("1.41421356")
print(x.as_tuple())

# DecimalTuple(sign=0, digits=(1, 4, 1, 4, 2, 1, 3, 5, 6), exponent=-8)
</code></pre>
<p>对于<code>Decimal</code>对象，还有许多其他方法可用，我建议看看文档的这一部分以了解更多:<a href="https://docs.python.org/3.7/library/decimal.html#decimal-objects">https://docs . python . org/3.7/library/decimal . html # decimal-objects</a></p><h2 id="so-should-we-just-use-decimal">那么，我们是不是应该直接用<code>decimal</code>？</h2><p>不一定。虽然<code>decimal</code>模块确实非常简洁，并且它具有绝对精度的优势，但是这种精度是有代价的。在这种情况下，成本是双重的。</p><p>首先，使用<code>decimal</code>模块比使用floats要困难得多。当我们看上面的<code>DecimalTuple</code>对象时，这一点就很明显了，而且在此之上我们还需要考虑上下文之类的东西。你只需要知道更多就可以使用这个模块。</p><p>然而，第二个问题可能更紧迫，这取决于性能。<code>decimal</code>操作可能比使用浮点的操作慢3倍左右，所以如果你正在处理应用程序中对性能敏感的部分，绝对精度并不重要，你可能想要避开<code>decimal</code>。如果您仍然在使用Python 2，这一点尤其正确，因为操作可能会慢几百倍！</p><p>模块是我们工具箱中的一个很好的工具，但是我们应该始终意识到我们是否真的需要它来用于特定的应用。</p><h2 id="wrapping-up">包扎</h2><p>这就是这篇关于浮点数和小数的文章。肯定还有很多东西需要学习，所以再一次看看文档吧！模块文档可能有点吓人，但希望我们在这里讨论的内容能让你做好充分的准备，一头扎进去。</p><p>如果你喜欢我们的帖子，并且想让你的Python更上一层楼，一定要看看我们的<a href="https://go.tecla.do/complete-python-sale">完整Python课程</a>。</p>
</div>
</div>    
</body>
</html>