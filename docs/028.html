<html>
<head>
<title>Advanced configuration of Flask-JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>烧瓶的高级配置-JWT</h1>
<blockquote>原文：<a href="https://blog.teclado.com/learn-python-advanced-configuration-of-flask-jwt/">https://blog.teclado.com/learn-python-advanced-configuration-of-flask-jwt/</a></blockquote><div><div class="post-content">
<p>烧瓶-JWT增加了JWT功能的烧瓶在一个易于使用的方式。它为您提供了许多现成的功能，但有时我们希望修改一些配置。本文档介绍了如何:</p>
<ul>
<li>更改认证端点(默认为<code>/auth</code>)；</li>
<li>更改令牌过期时间(默认为<code>5 minutes</code>)；</li>
<li>更改认证密钥名称(默认为<code>username</code>)；</li>
<li>更改认证响应体(默认只包含<code>access_token</code>)；</li>
<li>更改错误处理程序。</li>
</ul>
<p>此外，它还介绍了如何从我们的Flask应用程序端点检索当前登录的用户的<strong>。</strong></p>
<p>本教程假设你已经听完了讲座，并且已经建立了Flask-JWT！如果您还没有这样做，请查看我的课程的第5部分。</p>
<h2 id="beforewestart">开始之前</h2>
<p>首先，让我们看看这里已经有什么。在我们的app.py文件中，我们应该已经使用下面的代码设置了JWT:</p>
<pre><code class="language-python">from flask_jwt import JWT
from security import authenticate, identity

jwt = JWT(app, authenticate, identity)  # /auth
</code></pre>
<p>在我们的security.py文件中，我们应该有这样的内容:</p>
<pre><code class="language-python">from werkzeug.security import safe_str_cmp
from models.user import UserModel

def authenticate(username, password):
    user = UserModel.find_by_username(username)
    if user and safe_str_cmp(user.password, password):
        return user

def identity(payload):
    user_id = payload['identity']
    return UserModel.find_by_id(user_id)
</code></pre>
<h2 id="configuration">配置</h2>
<h3 id="authenticationurl">认证URL</h3>
<p>例如，如果我们想要更改身份验证端点的url，我们想要使用<code>/login</code>而不是<code>/auth</code>，我们可以这样做:</p>
<pre><code class="language-python">app.config['JWT_AUTH_URL_RULE'] = '/login'
jwt = JWT(app, authenticate, identity)
</code></pre>
<p><strong>重要的</strong>:我们添加了第二行代码来强调，在创建<code>JWT</code>实例之前，我们必须首先更改JWT认证URL<strong>。否则，我们的配置不会生效。然而，它仅在配置auth URL时需要，在请求<code>JWT</code>实例后，以下配置仍然有效。</strong></p>
<h3 id="tokenexpirationtime">令牌过期时间</h3>
<pre><code class="language-python"># config JWT to expire within half an hour
app.config['JWT_EXPIRATION_DELTA'] = timedelta(seconds=1800)
</code></pre>
<h3 id="authenticationkeyname">认证密钥名称</h3>
<pre><code class="language-python"># config JWT auth key name to be 'email' instead of default 'username'
app.config['JWT_AUTH_USERNAME_KEY'] = 'email'
</code></pre>
<h3 id="authenticationresponsehandler">认证响应处理程序</h3>
<p>有时我们可能希望在认证响应体中包含更多信息，而不仅仅是<code>access_token</code>。例如，我们可能还想在响应正文中包含用户的ID。在这种情况下，我们可以这样做:</p>
<pre><code class="language-python"># customize JWT auth response, include user_id in response body
from flask import jsonify
from flask_jwt import JWT

from security import authenticate, identity as identity_function
jwt = JWT(app, authenticate, identity_function)

@jwt.auth_response_handler
def customized_response_handler(access_token, identity):
    return jsonify({
                        'access_token': access_token.decode('utf-8'),
                        'user_id': identity.id
                   })
</code></pre>
<p>记住，<code>identity</code>应该是由<code>authenticate()</code>函数返回的，在我们的例子中，它是一个包含字段<code>id</code>的<code>UserModel</code>对象。确保只访问您的<code>identity</code>模型中的有效字段！</p>
<p>此外，一般不建议在<code>access_token</code>中包含加密的信息，因为这可能会带来安全问题。</p>
<h3 id="errorhandler">错误处理程序</h3>
<p>默认情况下，当任何处理程序中出现错误时(例如，在认证、标识或创建响应期间)，Flask-JWT会引发<code>JWTError</code>。在某些情况下，我们可能想要定制当这样的错误发生时我们的Flask应用程序做什么。我们可以这样做:</p>
<pre><code class="language-python"># customize JWT auth response, include user_id in response body
from flask import jsonify
from flask_jwt import JWT

from security import authenticate, identity as identity_function
jwt = JWT(app, authenticate, identity_function)

@jwt.error_handler
def customized_error_handler(error):
    return jsonify({
                       'message': error.description,
                       'code': error.status_code
                   }), error.status_code
</code></pre>
<h3 id="otherconfigurations">其他配置</h3>
<p>你可以在这里找到更多的配置选项:<a href="https://pythonhosted.org/Flask-JWT/">https://pythonhosted.org/Flask-JWT/</a></p>
<p>请参考<configuration options="">部分。</configuration></p>
<h2 id="more">更大的</h2>
<h3 id="retrievinguserfromtoken">正在从令牌中检索用户</h3>
<p>另一个常见问题是:<em>我如何从访问令牌(JWT)中获取用户的身份？</em>因为在某些情况下，我们不仅希望保证只有我们的用户可以访问终端，而且我们可能还希望访问用户的数据。例如，如果您想将访问权限限制在某个用户组，而不是每个用户。在这种情况下，您可以这样做:</p>
<pre><code class="language-python">from flask_jwt import jwt_required, current_identity


class User(Resource):

    @jwt_required()
    def get(self):   # view all users
        user = current_identity
        # then implement admin auth method
        ...
</code></pre>
<p>现在这个端点受到JWT的保护。您可以从JWT使用<code>current_identity</code>访问与该端点交互的用户的身份。</p>

</div>
</div>    
</body>
</html>