# 第 18 天:进口

> 原文：<https://blog.teclado.com/python-30-day-18-imports/>

欢迎来到 Python 系列 [30 天的第 18 天！今天我们将谈论进口这个非常**进口**蚂蚁的话题。](https://blog.teclado.com/30-days-of-python/)

到目前为止，我们一直在使用核心 Python 语法，并且一直在使用所谓的[内置函数](https://docs.python.org/3/library/functions.html#built-in-functions)。然而，[Python 标准库](https://docs.python.org/3/library/)不仅仅是这些函数，还有更多的东西，但是为了访问它，我们需要能够导入这个功能。

导入还将允许我们使用第三方库，这一点我们将在本系列的后面介绍。

## 基本进口

我们将从导入`math`模块开始，顾名思义，该模块包含许多用于执行数学运算的有用工具。它还包括几个有用的常数。你可以在这里找到文档[。](https://docs.python.org/3/library/math.html)

要导入一个模块，我们需要编写`import`关键字，后跟我们想要导入的模块的名称。为了导入`math`模块，我们将把它写在代码的顶部:

就这样，我们可以访问在`math`模块中定义的所有功能。为了使用这些函数和变量，我们只需要在函数或变量名称前加上`math.`。这告诉 Python 我们正在请求位于`math`模块中的东西。

让我们通过一个例子来看看这一点。

回到系列的第一天，我们有以下练习题:

计算并打印半径为 5 个单位的圆的面积。

这将是对`math`模块的完美应用，因为我们可以利用`math`模块的`pi`常数:

```py
`import math

print(math.pi * 5**2)  # 78.53981633974483` 
```

这比我最初的解决方案要精确得多，我最初的解决方案使用`3.141`作为圆周率的值。

现在让我们尝试一个函数。`math`模块有一个名为`fsum`的函数，用于将浮点数相加。您当然可以使用常规的老式`sum`来实现这一点，但是对于某些值来说，事情会变得有点奇怪，因为浮点数中存在固有的不精确性。

举以下例子:

```py
`numbers = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]
print(sum(numbers))  # 0.9999999999999999` 
```

没错。加十手`0.1`不是`1`。如果你试着一遍又一遍地添加`0.2`，你会得到同样不可靠的结果。

然而，如果我们使用`fsum`函数，数学就会回归正常:

```py
`import math

numbers = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]
print(math.fsum(numbers))  # 1.0` 
```

如果你有兴趣知道为什么`0.1`会产生这个不寻常的结果，我推荐你看看[我在十进制模块](https://blog.teclado.com/decimal-vs-float-in-python/)上的帖子。开始时，我谈到了十进制数在计算机中是如何表示的，以及为什么这会导致浮点数的问题。

### 风格注释

确保总是将您的导入放在文件的顶部！这不仅是好的风格，也有很好的实际原因，我们很快就会谈到。

在完成导入后，放置一个空格将它们与代码的其余部分分开也是一个好主意。

## 从模块中导入特定的东西

假设我们正在进行一个项目，我真的只需要来自`math`模块的`pi`常量，我计划在我的代码中广泛使用它。使用`import math`然后使用`math.pi`引用常量并没有什么实际问题，但是这会变得有点乏味。

在这种情况下，如果我们可以在代码中使用`pi`会好很多，我们可以通过从`math`模块中导入`pi`常量来做到这一点。其语法如下:

通过用逗号分隔名称，我们可以从一个模块中导入几个东西。假设我也想要τ常数 T1:

现在我们可以直接引用`pi`或`tau`而不是使用`math.pi`和`math.tau`。然而，我们不再能够使用这种方法访问剩余的`math`模块，所以我们不能调用`math.fsum`，除非我们也导入`math`。

在一些模块中，有些东西我们只能通过这个特定的导入语法来访问。

例如，假设我们想要使用`tkinter`，因为我们已经决定要制作一个具有图形用户界面(GUI)的应用程序。

`tkinter`库包括一组我们可以在应用程序中使用的主题小部件，但是为了使用它们，我们必须从 tkinter 模块导入`ttk`。

## 模块和命名空间

既然我们已经看到了两种不同类型的导入，那么就有必要讨论一下当我们导入一个模块时会发生什么，以及为什么我们会根据导入的方式以不同的方式访问它们。比如，为什么一种方式导入时我们需要把这个`math.`放在`pi`前面，而另一种方式不需要？

让我们使用与第 13 天相同的技术，看看当我们使用两种不同的导入方法时，在全局范围内定义了什么。

首先，我们来试试`import math`。我们可以看到全局名称空间中的内容如下:

```py
`import math

print(globals())` 
```

我们得到的是这样的字典:

```py
`{
    '__name__': '__main__',
    '__doc__': None,
    '__package__': None,
    '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7f23b99febb0>,
    '__spec__': None,
    '__annotations__': {},
    '__builtins__': <module 'builtins' (built-in)>,
    '__file__': 'main.py',
    '__cached__': None,
    'math': <module 'math' from '/usr/local/lib/python3.8/lib-dynload/math.cpython-38-x86_64-linux-gnu.so'>
}` 
```

就像之前一样，当我们开始程序的时候，我们在这里定义了很多东西，但是在程序的最后，我们有一个名字叫做`math`。与这个名字`math`相关的是一个叫做模块对象的东西，在这个例子中我们可以看到`Python`已经在我们的 Python 安装中找到了这个模块的代码。

当我们导入一个模块时，Python 运行这个模块并创建这个模块对象，这样我们就可以访问它里面的东西。为了表明我们想对模块做些什么，我们必须首先使用分配给它的名字(在本例中是`math`)来访问模块，然后我们可以使用点符号来访问里面的东西。

现在让我们看看当我们从`math`模块导入特定的项目时会发生什么。我将再次使用`pi`和`tau`常量，所以现在我们的代码看起来像这样

```py
`from math import pi, tau

print(globals())` 
```

我们得到以下输出:

```py
`{
    '__name__': '__main__',
    '__doc__': None,
    '__package__': None,
    '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7fda798e3bb0>,
    '__spec__': None,
    '__annotations__': {},
    '__builtins__': <module 'builtins' (built-in)>,
    '__file__': 'main.py',
    '__cached__': None,
    'pi': 3.141592653589793,
    'tau': 6.283185307179586
}` 
```

需要注意的一点是，我们不再有这个`math`模块对象，并且在全局作用域中没有给名称`math`赋值。这就是为什么我们不再能够使用像`math.fsum`这样的东西来访问像`fsum`这样的东西。

我们有两个新名字，`pi`和`tau`，这些名字被赋予长浮点值。这就是我们使用`pi`和`tau`这两个名字时所指的。它们只是普通的变量，是 Python 在我们导入常量时为我们定义的。

### 重要的

正如我在本节中提到的，当我们导入一个模块时，Python 必须运行该模块。这很有意义，因为一些值或函数可能依赖于模块中的其他值。无论我们使用什么风格的导入，Python *总是*必须运行模块。

许多 Python 开发人员错误地认为使用这样的导入:

在某种程度上更有效，因为我们只获取几个值，因此 Python 不必运行该模块。事实并非如此，所以请不要试图使用这种特定的导入语法，因为您想让模块加载更有效。

然而，上面的语法有一个重要的方法可以帮助提高效率，那就是引用值。如果你在应用程序的性能敏感部分多次使用一个名字，直接引用`pi`会比`math.pi`稍微快一点。不过，这很少是你需要担心的事情，速度上的差异非常小。你需要数以百万计的参考资料，才会有明显的差异。

## 别名进口

有时模块名相当长，或者我们不得不多次引用它们，当我们调用模块中定义的函数时，包含模块名会变得有点麻烦。因此，我们可以在导入模块时使用别名。这允许我们使用这个别名而不是模块名来引用模块。

例如，假设我们正在做一些数据分析工作，我们决定使用`numpy`模块。

在导入 numpy 时，通常的惯例是使用名称`np`来导入它，我们可以使用`as`语法来完成。

我们在这里所做的是为`numpy`模块设置一个别名，这意味着我们已经请求 Python 允许我们用其他名称来引用它。在这种情况下，我们要求使用`np`来引用它。

在这种情况下，让我们打印出最终出现在全局名称空间中的内容:

```py
`import numpy as np

print(globals())` 
```

如果你在 [repl.it](http://repl.it/) 上运行这段代码，你会得到类似下面的输出。如果您在本地 Python 安装中运行这个，代码可能不工作，因为`numpy`是第三方模块，必须安装。

```py
`{
    '__name__': '__main__',
    '__doc__': None,
    '__package__': None,
    '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7fa4ee853bb0>,
    '__spec__': None,
    '__annotations__': {},
    '__builtins__': <module 'builtins' (built-in)>,
    '__file__': 'main.py',
    '__cached__': None,
    'np': <module 'numpy' from '/home/runner/.local/share/virtualenvs/python3/lib/python3.8/site-packages/numpy/__init__.py'>
}` 
```

我们可以看到，我们又一次得到了一个`module`对象，模块的名字是`'numpy'`，但是 Python 已经把这个模块赋予了名字`np`。

这意味着我们可以使用`np.`访问`numpy`模块中的东西，比如数组类型。我们可以通过输入`np.array`来实现。

## 使用`*`导入

除了我们到目前为止所看到的导入语法之外，我们还可以编写如下内容:

这个语法本质上意味着，“给我`math`模块中的所有内容”。我们没有得到*所有的*，因为我们仍然不能访问需要特定导入的模块内容，就像从`tkinter`导入`ttk`一样。

我想事先说明，这不是你应该在代码中 99%的时间里使用的导入风格。这样做的原因是，我们正在导入的模块中定义的所有名称都将被添加到全局名称空间中。

如果您想亲自查看，请运行下面的代码。

```py
`from math import *

print(globals())` 
```

这是一个大问题，因为它很容易导致名称冲突。例如，我们可能不小心使用了在我们导入的模块中定义的名称，然后我们覆盖了从该模块中获得的值。如果不同的模块也使用相同的值名，我们也会遇到一个模块覆盖另一个模块的问题。

例如，`math`和`numpy`都定义了一个名为`pi`的值，但是在我们的全局名称空间中，只能给名称`pi`分配一个值。

如果使用这种风格的导入是个坏主意，那么它为什么会存在呢？它主要是为了方便快速测试。如果我们不是在一个严肃的应用程序上工作，使用`*`导入可以节省我们大量的输入，我们不需要担心最佳实践。

只是不要在你写的任何严肃的应用程序中使用它，除非你有一个真正的用例，并且你知道你在做什么。

## 练习

1)导入`fractions`模块，并从浮点型`2.25`创建一个`Fraction`。你可以在文档中找到如何创建分数[的信息。](https://docs.python.org/3/library/fractions.html#fractions.Fraction)

2)仅从`math`模块导入`fsum`函数，并使用它来计算以下浮点序列的总和:

```py
`numbers = [1.43, 1.1, 5.32, 87.032, 0.2, 23.4]` 
```

3)使用别名导入`random`模块，并使用`randint`函数在`1`和`100`之间找到一个随机数。你可以在这里找到这个函数[的文档。](https://docs.python.org/3/library/random.html#random.randint)

4)使用上面练习中的`randint`函数创建我们在第 8 天制作的猜谜游戏的新版本。这一次程序应该生成一个随机数，你应该告诉用户他们的猜测是太高还是太低，直到他们得到正确的数字。

你可以在这里找到我们的练习[的答案。](/30-days-of-python/python-30-day-18-exercise-solutions/)

## 额外资源

如果你想学习更多关于 GUI 开发的知识，我们在 Udemy 上有一门专门的课程，在我们的博客上也有[一些帖子。](https://blog.teclado.com/tag/gui-development/)

我们没有关于`numpy`的任何内容，但是如果你想了解更多关于这个模块的内容，在`numpy`文档中有一个很好的[快速入门教程页面](https://numpy.org/devdocs/user/quickstart.html)。

如果你对浮点数的问题以及这些问题的解决方案感兴趣，你可以看看[我们的帖子](https://blog.teclado.com/decimal-vs-float-in-python/)比较浮点数和`decimal`对象。