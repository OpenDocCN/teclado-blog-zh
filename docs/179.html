<html>
<head>
<title>Dictionary Merge and Update Operators in Python 3.9</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python 3.9中的字典合并和更新运算符</h1>
<blockquote>原文：<a href="https://blog.teclado.com/python-dictionary-merge-update-operators/">https://blog.teclado.com/python-dictionary-merge-update-operators/</a></blockquote><div><div class="post-content">
<h1 id="introduction">介绍</h1>
<p>Python 3.9于2020年10月5日发布，它引入了一些简洁的功能和优化，包括PEP 584，内置类<code>dict</code>中的Union运算符；所谓的字典合并和更新操作符。</p>
<p>在这篇博文中，我们将讨论新的操作符，看看与早期的合并和更新字典的方法相比，使用它们有什么优点或缺点。</p>
<h1 id="thedictionarymergeoperator">字典合并运算符</h1>
<p>给定两本或更多的字典，我们把它们合并成一本。</p>
<p>让我们从一个简短的例子开始，展示合并两个字典的老方法:</p>
<pre><code class="language-python">x = {"key1": "value1 from x", "key2": "value2 from x"}
y = {"key2": "value2 from y", "key3": "value3 from y"}

z = {**x, **y}
print(z)
# {'key1': 'value1 from x', 'key2': 'value2 from y', 'key3': 'value3 from y'}
</code></pre>
<p>这种合并创建了一个全新的<code>dict</code>对象<code>z</code>，在这里我们解包来自<code>x</code>和<code>y</code>的每个值。这种合并两本词典的方式感觉不自然，也不明显。如果两个字典有相同的关键字，字典<code>x</code>的值会被字典<code>y</code>的值覆盖。</p>
<p><a href="https://mail.python.org/archives/list/python-ideas@python.org/message/K4IC74IXE23K4KEL7OUFK3VBC62HGGVF/">据圭多:</a></p>
<blockquote>
<p><em>“我为PEP 448感到抱歉，但即使你在更简单的<br/>上下文中了解d，如果你问一个典型的Python用户如何将两个dicts <br/>合并成一个新的，我怀疑许多人会想到<code>{**d1, **d2}</code>。我知道当这个帖子开始的时候，我<br/>自己已经忘记了！如果你问<br/>一个学过一些东西(比如序列连接)的新手，他们<br/>更有可能会猜d1+d2。</em></p>
</blockquote>
<p>下面的例子演示了新的字典合并操作符，<code>|</code>:</p>
<pre><code class="language-python">x = {"key1": "value1 from x", "key2": "value2 from x"}
y = {"key2": "value2 from y", "key3": "value3 from y"}

z = x | y
print(z)
# {'key1': 'value1 from x', 'key2': 'value2 from y', 'key3': 'value3 from y'}
</code></pre>
<p>但是请记住，merge操作符创建新的字典，并保持两个合并的字典不变:</p>
<pre><code class="language-python"># before merging
x = {"key1": "value1 from x", "key2": "value2 from x"}
y = {"key2": "value2 from y", "key3": "value3 from y"}
print(id(x))  # 2670466407744
print(id(y))  # 2670466407808

# after merging
x | y
print(id(x))  # 2670466407744
print(id(y))  # 2670466407808

# assigning the expression to the variable `z`
z = x | y
print(id(z))  # 2670466542912
print(z is x)  # False
print(z is y)  # False
</code></pre>
<p>如果表达式没有赋给变量，它将会丢失。</p>
<p>相同的概念适用于遗留合并方法:</p>
<pre><code class="language-python"># before merging
x = {"key1": "value1 from x", "key2": "value2 from x"}
y = {"key2": "value2 from y", "key3": "value3 from y"}
print(id(x))  # 2670466407744
print(id(y))  # 2670466407808

# after merging
{**x, **y}
print(id(x))  # 2670466407744
print(id(y))  # 2670466407808

# assigning the expression to the variable `z`
z = {**x, **y}
print(id(z))  # 2670466553600
print(z is x)  # False
print(z is y)  # False
</code></pre>
<p>所以我们已经看到它们有相似的行为，使用合并操作符<code>|</code>允许我们写更干净的代码，但是除此之外，它有什么好处呢？</p>
<p>这些操作符也已经在其他几个标准库包中实现，比如<code>collections</code>。</p>
<p>为了演示合并操作符<code>|</code>的用处，让我们看看下面这个使用<a href="https://blog.teclado.com/python-30-day-26-standard-library/"> defaultdict </a>的例子:</p>
<pre><code class="language-python">from collections import defaultdict

user_not_found_message = 'Could not find any user matching the specified user id.'

ceo = defaultdict(
    lambda: user_not_found_message,
    {'id': 1, 'name': 'Jose', 'title': 'Instructor'}
)

author = defaultdict(
      lambda: user_not_found_message,
      {'id': 2, 'name': 'Vlad', 'title': 'Teaching Assistant'}
)
</code></pre>
<p>通过使用双星号<code>**</code>，可以合并两个字典，但是该方法不知道类对象，所以我们将使用传统的字典:</p>
<pre><code class="language-python">print({**author, **ceo})
# {'id': 2, 'name': 'Jose', 'title': 'Author', 'title': 'Instructor'}

print({**ceo, **author})
# {'id': 1, 'name': 'Vlad', 'title': 'Teaching Assistant'}
</code></pre>
<p>合并操作符<code>|</code>的强大之处在于它知道类对象。因此，将返回一个<code>defaultdict</code>:</p>
<pre><code class="language-python">print(author | ceo)
# defaultdict(&lt;function &lt;lambda&gt; at 0x000002212125DE50&gt;, {'id': 2, 'name': 'Jose', 'title': 'Instructor'})

print(ceo | author)
# defaultdict(&lt;function &lt;lambda&gt; at 0x000002212127A3A0&gt;, {'id': 1, 'name': 'Vlad', 'title': 'Teaching Assistant'})
</code></pre>
<p>注意:操作数的顺序非常重要，因为根据它们的排列顺序，它们的行为会有所不同。在上面的例子中，我们使用了两种布局，所以后面的键和值会覆盖前面的。</p>
<p>使用新的字典合并操作符<code>|</code>的另一个优点是有遵循这个语法的链式表达式:<code>dict4 = dict1 | dict2 | dict3</code>，相当于<code>dict4 = {**dict1, **dict2, **dict3}</code>。</p>
<p>让我们展示一个实际的例子:</p>
<pre><code class="language-python">basic_data = {'id': 1, 'name': 'Vlad'}
get_role = {'title': 'Teaching Assistant'}
details = {'country': 'Denmark', 'active': True}

vlad_info = basic_data | get_role | details
print(vlad_info)
# {'id': 1, 'name': 'Vlad', 'title': 'Teaching Assistant', 'country': 'Denmark', 'active': True}
</code></pre>
<h1 id="thedictionaryupdateoperator">字典更新操作符</h1>
<p>在下面的例子中，字典<code>y</code>正在更新字典<code>x</code>，演示了<code>.update()</code>方法:</p>
<pre><code class="language-python">x = {"key1": "value1 from x", "key2": "value2 from x"}
y = {"key2": "value2 from y", "key3": "value3 from y"}

print(x.update(y))
# None

print(x)
# {'key1': 'value1 from x', 'key2': 'value2 from y', 'key3': 'value3 from y'}
</code></pre>
<p>字典<code>x</code>被更新，由于内置<code>.update()</code>方法设计的本质，它就地操作<a href="https://blog.teclado.com/python-updating-dictionaries/">。字典得到更新，但是方法返回<code>None</code>。</a></p>
<p>使用<strong>更新操作符</strong>、<code>|=</code>，我们可以用更简洁的语法实现相同的功能:</p>
<pre><code class="language-python">x = {"key1": "value1 from x", "key2": "value2 from x"}
y = {"key2": "value2 from y", "key3": "value3 from y"}

print(x |= y)
# SyntaxError: invalid syntax

print(x)
# {'key1': 'value1 from x', 'key2': 'value2 from x'}

x |= y
print(x)
# {'key1': 'value1 from x', 'key2': 'value2 from y', 'key3': 'value3 from y'}
</code></pre>
<p>然而，与传统的<code>.update()</code>方法相比，新的字典<strong>更新操作符</strong>有助于防止误用，如果我们在print语句中使用它，字典不会得到更新。在下一行中，按照所需的语法，字典被成功更新。</p>
<p>让我们看看如何用遗留的<code>.update()</code>方法或者用<strong>更新操作符</strong> <code>|=</code>更新字典，既不改变对象的<strong> id </strong>，也不创建一个新的:</p>
<pre><code class="language-python"># before update
x = {"key1": "value1 from x", "key2": "value2 from x"}
y = {"key2": "value2 from y", "key3": "value3 from y"}
print(id(x))  # 2627652603136
print(id(y))  # 2627652603200

# after update
x |= y
print(id(x))  # 2627652603136
print(id(y))  # 2627652603200

# after legacy update
x.update(y)
print(id(x))  # 2627652603136
print(id(y))  # 2627652603200
</code></pre>
<p>另一个例子是通过使用<strong>更新操作符</strong> <code>|=</code>来扩展具有元组列表的字典:</p>
<pre><code class="language-python">author = {'id': 1, 'name': 'Vlad'}
author |= [('title', 'Teaching Assistant')]

print(author)
# {'id': 1, 'name': 'Vlad', 'title': 'Teaching Assistant'}
</code></pre>
<p>上面的例子是遗留<code>.update()</code>方法的语法糖:</p>
<pre><code class="language-python">author = {'id': 1, 'name': 'Vlad'}
new_key = dict([('title', 'Teaching Assistant')])
author.update(new_key)

print(author)
# {'id': 1, 'name': 'Vlad', 'title': 'Teaching Assistant'}
</code></pre>
<p>除了新的字典更新操作符<code>|=</code>提供的更好的语法之外，使用它的另一个好处是更安全的字典更新，当在<code>print</code>中使用它时，抛出一个<code>SyntaxError</code>而不是<code>None</code>。</p>
<p><strong>旧版本</strong> <br/>字典更新操作符<code>|=</code>和合并操作符<code>|</code>是Python 3.9中的新特性，所以如果你试图在早期版本中使用它们，你会遇到类似这样的错误，所以一定要更新到最新版本:</p>
<pre><code class="language-python">Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for |=: 'dict' and 'dict'
</code></pre>
<h3 id="summary">摘要</h3>
<p>新的操作符并不是要取代现有的合并和更新方式，而是对它们进行补充。一些主要的要点是:</p>
<ul>
<li><strong>合并操作符</strong>，<code>|</code>，是类感知的，提供了更好的语法，它创建了一个新的对象。</li>
<li><strong>更新操作符</strong>、<code>|=</code>，就地操作<a href="https://blog.teclado.com/python-updating-dictionaries/">、</a>，在常见错误发生之前捕捉它们，并且不创建新对象。</li>
<li>运算符是Python 3.9中的新特性</li>
</ul>
<p>如果你正在学习Python，并且对这类内容感兴趣，一定要在<a href="https://twitter.com/tecladocode"> Twitter </a>上关注我们，或者注册我们的邮件列表，以获得所有最新内容。如果你感兴趣，在这一页的底部有一个表格。</p>
<p>我们也刚刚对我们的<a href="https://www.udemy.com/course/the-complete-python-course/">完整Python课程</a>进行了一次大的更新，所以如果你有兴趣达到Python的高级水平，可以去看看。我们有一个30天的退款保证，所以你真的没有什么损失，尝试一下。我们很希望你能来！</p>

</div>
</div>    
</body>
</html>