# 第 6 天项目:嘶嘶作响| Teclado

> 原文：<https://blog.teclado.com/python-30-day-6-project/>

欢迎来到蟒蛇系列[30 天](https://blog.teclado.com/30-days-of-python/)[第 6](/30-days-of-python/python-30-day-6-project) 天项目。今天的项目其实是一个很常见的面试问题，围绕着一个叫做 Fizz Buzz 的童年计数游戏展开。

如果你不熟悉这个游戏，它是这样的:

*   一名玩家开始说数字`1`。
*   然后每个玩家轮流说出下一个数字，一次数一个。
*   如果数字能被`3`整除，玩家应该说“Fizz”，而不是说数字。
*   如果数字能被`5`整除，玩家应该说“嗡嗡”，而不是说数字。
*   如果数字能被`3` **和** `5`整除，玩家应该说“Fizz Buzz”，而不是说数字。
*   如果你犯了一个错误，你通常会从游戏中被淘汰，游戏继续进行，直到只剩下一个玩家。

如果没有错误，Fizz Buzz 的前 15 轮应该是这样的:

```py
`1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
Fizz Buzz` 
```

下面你会发现一个简短的解释，说明我们的版本该做什么，你还会发现一个附有解释的模型解决方案。我真的建议你在查看我们的版本之前先自己尝试一下。

就像第三天的项目一样，回顾过去 6 天的内容，或者参考你的笔记没有任何问题。你也不应该担心你的解决方案是否与我们的略有不同，因为有很多很多方法可以解决这个特殊的问题。

## 案情摘要

对于我们的版本，我们只有一个播放器，电脑，它会自己播放前 100 轮的嘶嘶声。换句话说，我们需要打印出序列中的前 100 项，从`1`开始。

为了完成这个练习，您将需要使用循环，并且您可以使用`range`生成您的数字列表。你还将需要条件句，并且你将需要能够检查某物是否能被`3`或`5`整除。

对于最后一部分，您可以使用一个叫做 modulo 的操作符，它使用百分号(`%`)。模运算会给你一个除法的余数，所以如果一个数能被`3`整除，`number % 3`的值就是`0`。

如果你想更详细地了解模数，我们有一个[帖子，你可以看看](https://blog.teclado.com/pythons-modulo-operator-and-floor-division/)。

您可以使用的另一种方法是`is_integer`方法。我们可以在 float 上调用这个函数来检查它是否是一个整数。例如，我们可以这样写:

```py
`(2.0).is_integer()  # True
(3.7).is_integer()  # False` 
```

我们可以这样测试除法的结果:

```py
`(12 / 4).is_integer()  # True
(12 / 5).is_integer()  # False` 
```

祝你好运！

## 解决方案演练

就像我们对第三天项目所做的那样，我们将把项目分成更小的块。这将使我们更容易早期发现错误，也将使项目不那么令人生畏。

如果你更喜欢观看这个项目的视频演示，请点击查看[。](https://youtu.be/Y0nnQ4j7pqM)

我认为好的第一步是获取我们的数字范围。我们可以用`range`函数来实现，我们需要传入两个参数:一个起始值和一个终止值。我们需要一个起始值，因为默认情况下`range`将从`0`开始。

不要忘记`range`的停止值是不包含的，所以我们需要指定一个从`1`到`101`的范围:

我们可以通过把它转换成一个列表并打印出来来检查我们是否拥有了所有需要的东西。记住我们不能直接打印`range`，因为`range`很懒，直到我们要求时才会计算它的值。

```py
`numbers = list(range(1, 101))

print(numbers)` 
```

假设我们没有任何问题，我认为下一个合乎逻辑的步骤是使用循环打印数字。此时，我们可以去掉列表和`numbers`变量，直接将`range`放入循环中:

```py
`for number in range(1, 101):
    print(number)` 
```

这将把`1`到`100`打印到控制台上，每个数字在不同的行上。

现在我们需要开始从这个输出中过滤掉我们不想打印的数字。让我们从计算 Fizz 数开始:那些能被`3`整除的数。

使用模方法，我们可以这样做:

```py
`for number in range(1, 101):
    if number % 3 == 0:
        print("Fizz")
    else:
        print(number)` 
```

这里我们检查一个数是否能被`3`整除。如果是，我们打印`"Fizz"`；否则，我们打印数字本身。我们已经见过几次条件句了，所以希望在这一点上相对简单。

如果我们想使用`is_integer`方法，解决方案看起来非常相似:

```py
 `for number in range(1, 101):
    if (number / 3).is_integer():
        print("Fizz")
    else:
        print(number)` 
```

好了，现在我们已经处理了 Fizz 数，让我们扩展我们的条件来考虑 Buzz。

过程非常相似，我们只需添加一个`elif`子句来检查第二个条件。那个条件就是这个数是否能被`5`整除。

```py
`for number in range(1, 101):
    if number % 3 == 0:
        print("Fizz")
    elif number % 5 == 0:
        print("Buzz")
    else:
        print(number)` 
```

这个台阶是人们经常绊倒的地方。如果我们不使用一个`elif`子句，而是使用一个新的`if`语句，我们最终会遇到这样的情况:对于许多数字，我们有两批输出。

让我们看一个不正确的版本，并思考发生了什么:

```py
`for number in range(1, 101):
    if number % 3 == 0:
        print("Fizz")
    if number % 5 == 0:
        print("Buzz")
    else:
        print(number)` 
```

如果一个数能被`3`整除，我们触发第一个条件。然后我们检查第二个条件。如果这个数字能被`5`整除，那么我们最终也会在下一行打印出`"Buzz"`。虽然我们希望发生这种情况，但我们希望它们都在同一行上，我们将为此使用另一个步骤。如果这个数字不能被`5`整除，我们最终打印出`"Fizz"` **和**这个数字。一定不要掉进这个陷阱。

现在我们已经完成了`"Fizz"`和`"Buzz"`，我们需要考虑`"Fizz Buzz"`。这是人们经常犯错的另一个地方，因为条件的顺序很重要。你马上就会明白我的意思。

首先，让我们看看如何使用嵌套条件来实现这一点:

```py
`for number in range(1, 101):
    if number % 3 == 0:
        if number % 5 == 0:
            print("Fizz Buzz")
        else:
            print("Fizz")
    elif number % 5 == 0:
        print("Buzz")
    else:
        print(number)` 
```

这个解决方案之所以有效，是因为对于任何能被`3`整除的数字，我们都要进行第二次检查。如果这个数字也被`5`整除，我们知道`"Fizz Buzz"`的条件已经满足，所以我们可以将它打印到控制台。如果第二个条件不满足，我们知道这个数字只能被`3`整除，所以我们可以打印`"Fizz"`。

这个解决方案很好，但是不使用这些嵌套条件的解决方案怎么样呢？我们有两个主要选项，但我们将把第二个选项留到最后作为奖励内容。

这里我们可以使用的选项是检查某物是否能被`15`整除。这是因为任何能被`3`和`5`整除的数也能被`15`整除。正如我已经提到的，我们把这个条件放在哪里非常重要。例如，如果我们尝试下面的方法，我们不会得到我们想要的输出:

```py
`for number in range(1, 101):
    if number % 3 == 0:
        print("Fizz")
    elif number % 5 == 0:
        print("Buzz")
    elif number % 15 == 0:
        print("Fizz Buzz")
    else:
        print(number)` 
```

这是因为 Python 只会检查条件，直到发现一个条件为真。任何能被`15`整除的数也能被`3`整除，所以第一个条件在我们到达第三个分支之前捕捉这些数。因此，我们在预期的地方打印了`"Fizz"`。

要纠正这一点，我们需要把更具体的条件放在第一位。在这种情况下，被`3`整除是比被`15`整除更广泛的条件，因为被`15`整除的数字是被`3`整除的数字的一个更小的子集。因此，`15`检查可分性的条件需要放在第一位。

```py
`for number in range(1, 101):
    if number % 15 == 0:
        print("Fizz Buzz")
    elif number % 3 == 0:
        print("Fizz")
    elif number % 5 == 0:
        print("Buzz")
    else:
        print(number)` 
```

这样，我们的两个解决方案都有效，我们就完成了！

## 奖励材料

除以`15`是一个巧妙的技巧，可以将解保持在单个条件块内，但可能对一些人来说这并不十分清楚发生了什么。如果我们能直截了当地说出我们在这里检查的内容，也许会更好。

我们实际上可以使用一对特殊的布尔运算符`and`和`or`来计算多个表达式。在这种情况下，它们的用法相对简单易懂:

```py
`for number in range(1, 101):
    if number % 3 == 0 and number % 5 == 0:
        print("Fizz Buzz")
    elif number % 3 == 0:
        print("Fizz")
    elif number % 5 == 0:
        print("Buzz")
    else:
        print(number)` 
```

然而，有一些关于`and`和`or`如何工作的重要细节，所以如果你对使用这些操作符感兴趣，你应该阅读[我们关于这个主题](https://blog.teclado.com/logical-comparisons-in-python-and-or/)的帖子。

在另一篇文章中，我们也有一些额外的解决方法。如果你有兴趣看看这些替代方法，你可以在这里找到它们。