# 第五天:条件句和布尔值

> 原文：<https://blog.teclado.com/python-30-day-5-conditionals-booleans/>

欢迎来到 Python 系列 [30 天的第 5 天！在这篇文章中，我们将讨论条件句。这是我们编程旅程中的一大步，因为我们将第一次能够在程序中做决定。](https://blog.teclado.com/30-days-of-python/)

如果你错过了[第 4 天](/30-days-of-python/python-30-day-4-lists-tuples)，如果你对以下任何一点都不舒服，我建议你检查一下:

*   定义列表和元组
*   按索引访问序列中的项目
*   嵌套集合
*   修改列表(添加和删除项目)

## 布尔运算

在我们看条件句之前，首先我们需要了解一种叫做布尔的新类型。布尔以数学家乔治·布尔的名字命名，他定义了一个确定逻辑表达式真值的代数系统。

每一种现代编程语言都有一些布尔值的表示，因为我们经常需要能够声明某事是或不是这种情况。

我们只有两个布尔值，在 Python 中这些值是单词`True`和`False`。这里大写很重要:`True`是布尔值，而`TRUE`和`true`不是。

重要的是，`True`和字符串`"True"`也不是一回事。

我们可以像目前为止在 Python 中使用的任何其他值一样使用这些布尔值。我们可以把它们赋给变量，我们可以把布尔放在元组和列表中。

例如，我们可能想在用户的观看列表中存储一些电影的信息。我们可以用一个元组来表示每部电影，我们可以用一个布尔值来表示这部电影是否被这个用户看过:

```
`movies = [
    ("Inside Out", 2015, True),
    ("Toy Story 4", 2019, False),
    ("Up", 2009, True)
]` 
```

在上面的例子中，`movies`列表包含三部电影。在这三部电影中，用户看过《从里到外》和《向上》，但没有看过《玩具总动员 4》。

我们也可以打印布尔值，输出只是适当的`True`或者`False`。

```
`print(True)   # True
print(False)  # False` 
```

## 真理价值观

Python 中的每个值都有一些关联的真值。一开始想起来可能会有点奇怪。不太直观的是，`"Hello"`与`True`或`False`有某种联系，但是这很有用，我们很快就会看到。

我们可以通过将值传递给`bool`函数来找到 Python 中任何值的真值。`bool`将返回`True`或`False`，这取决于我们传入内容的真值。

`bool`返回`True`的值通常被称为真值，而`bool`返回`False`的值通常被称为假值。

举个例子，如果我们将字符串`"Hello"`传递给`bool`，函数调用的结果将是`True`。`"Hello"`因此是一个真值。

```
`print(bool("Hello"))  # True` 
```

让我们看看其他一些例子:

```
`print(bool(0))              # False
print(bool(6))              # True

print(bool("Caterpillar"))  # True
print(bool(""))             # False

print(bool([]))             # False
print(bool([0, 1, 2, 3]))   # True

print(bool(True))           # True
print(bool(False))          # False` 
```

正如我们所看到的，将`True`或`False`传递给`bool`会分别给我们`True`和`False`，但是当涉及到其他值时，似乎没有太多的规律或原因。

虽然看起来基本上是随机的，但实际上是有规律的。Python 中只有少数值是假的，如下所示:

*   零的任何数字表示。这包括整数`0`、浮点数`0.0`以及其他数字类型的零表示。
*   值`False`和`None`。我们还没有看到`None`，但是`None`代表了一个值的有意缺失。
*   空序列和其他集合。这包括空字符串、空元组、空列表以及我们在这个阶段还没有涉及到的几种类型。

我们也有可能定义自己的类型，如果我们愿意，我们可以在某些情况下让它们变得虚假。然而，这是一个高级主题，不是我们在本系列中要讨论的内容。

除了这些值，Python 中的其他东西都是真实的。

## 比较运算符

除了`bool`函数，我们还有许多产生布尔值的比较操作符。我们总共有八个，其中五个你们可能在数学课上见过。

首先，我们有`<`(小于)和`>`(大于)运算符。在`<`的情况下，如果第一个操作数*小于第二个操作数*，则运算符产生值`True`；对于`>`，如果第一个操作数*大于第二个操作数*，则运算符产生`True`。

一般来说，这个操作符将用于比较两个数值类型，但是我们实际上也可以比较其他值。例如，我们可以比较字符串，在这种情况下，字符的 [ASCII 码用于确定哪个值大于另一个值。](https://www.computerhope.com/jargon/a/ascii.htm)

```
`print(5 < 10)     # True
print(5 > 10)     # False
print(10 > 10)    # False
print("A" < "a")  # True

# The ASCII code for A is 65, while a is 97` 
```

与这些运算符非常相似，我们有`<=`(小于或等于)和`>=`(大于或等于)。这些操作与`<`和`>`的工作方式相同，但是如果操作数的值相等，我们会返回`True`而不是`False`。

```
`print(10 > 10)   # False
print(10 >= 10)  # True` 
```

我们经常想要明确地检查两个值是否相等。在这种情况下，我们可以使用`==`操作符。如果两个值相同，`==`产生`True`，在所有其他情况下产生`False`。

这里我们必须要小心一点，记住像`"0"`这样的东西和`0`不一样。Python 足够聪明，能够理解像`7`和`7.0`这样的东西是等价的。

```
`print(0 == "0")                # False
print(0 == 0)                  # True
print(7 == 7.0)                # True
print("Hello" == "Hello!")     # False
print([1, 2, 3] == [1, 2, 3])  # True` 
```

如果我们想检查两个值是否*不*相等，我们也有这样的操作符，看起来像这样`!=`。这个感叹号，有时读作“砰”，常用来表示“不是”。所以`!=`简单来说就是“不相等”。

```
`print(0 != "0")         # True
print(0 != 0)           # False
print("Hello" != "Hi")  # True` 
```

我们要看的最后两个稍微复杂一点，因为它们不比较值，*本身*。这最后两个操作符是`is`和`is not`。

你的第一反应可能是假设`is`和`==`是相同的东西，`is not`和`!=`也是如此。他们实际上是非常不同的，并且执行非常不同的工作。

首先让我们看一个例子:

```
`a = [1, 2, 3]
b = [1, 2, 3]

print(a == b)  # True
print(a is b)  # False` 
```

这里我们有两个包含相同值的列表。因此，我们可以说这两个列表是相同的，当我们比较这两个列表时,`==`操作符给出了`True`。然而，`is`操作员给了我们`False`。

我们得到这个差异的原因是因为`is`实际上检查两个列表是完全相同的列表。不是说它们有相同的价值观，而是它们是完全一样的东西。

打个现实世界的比方，我们可能有两个相同的碗，每个碗都装有相同排列的彩球。`==`操作员正在检查两个碗是否包含相同排列的彩球，而`is`正在检查我们是否在谈论完全相同的碗。

当我们讨论在 Python 中什么是完全相同的东西时，我们真正关心的是，我们比较的东西是否存储在内存中的相同位置。

我们可以使用一个名为`id`的函数来找出某个东西被存储在哪里，用一长串数字来表示。这一长串数字是一个引用内存中某个位置的地址。我们可以打印这些内存地址来验证这两个列表实际上并不相同:

```
`a = [1, 2, 3]
b = [1, 2, 3]

print(id(a))  # 139806639351360
print(id(b))  # 139806638418944

print(a == b)  # True
print(a is b)  # False` 
```

对于每个列表，你会得到不同的数字，每次程序运行时，都会得到不同的数字，但重要的是这两个数字是不一样的。

我们可以做一个小小的改动，让两个列表相同。不要在分配给`b`时定义这个新的相同列表，让我们只参考我们分配给`a`的列表:

```
`a = [1, 2, 3]
b = a

print(id(a))  # 139685763327296
print(id(b))  # 139685763327296

print(a == b)  # True
print(a is b)  # True` 
```

现在我们两个的内存地址是相同的，因此，当我们比较`a`和`b`时，`is`操作符产生了`True`。

### 重要的

重要的是要注意，在一些复杂的情况下，当我们比较两个看起来占用相同内存地址的东西时，`is`会产生`False`。换句话说，有两个项目看起来有相同的`id`，但是`is`仍然表明这两个对象不是同一个。

当内存地址被重用时，就会发生这种情况。

这不是你在整个课程中需要担心的事情，也可能在很长一段时间内不会，但这至少是你需要意识到的事情。

## 操作顺序

最后一个重要注意事项是这些比较运算符如何与我们之前学习的算术运算符交互。

比较运算符的优先级始终低于算术运算符。例如，如果我们写一个这样的表达式:

这种比较实际上是:

那就是:

## 条件语句

现在我们知道了如何使用这些比较操作符，我们可以使用这些比较的结果来控制应用程序的流程。我们使用条件语句来做到这一点。最基本的条件语句使用一个关键字:`if`。

当且仅当满足某些条件时，条件语句允许我们在代码上运行一些块。我们可以使用这种结构来控制我们的应用程序的流程，基于事情是否是这样的。例如，我们可能只允许输入正确凭证的用户登录网站。

让我们写一个简单的调酒师程序。我们将询问用户的年龄，然后检查他们是否小于 18 岁。如果他们未满 18 岁，我们会打印一条消息，声明他们未成年。

```
`age = int(input("How old are you? "))

if age < 18:
      print("Sorry, we can't serve you.")` 
```

对于条件本身，我们以这个`if`关键字开始，然后我们有一些表达式，后跟一个冒号。在这一行下面，我们有一些代码块，如果我们写的表达式计算为真值，我们希望运行这些代码块。

如果满足条件，我们要运行的这段代码在行首有四个缩进空间。这个缩进非常重要。如果你不这样做，Python 将会抛出一个异常。

```
`File "main.py", line 4
    print("Sorry, we can't serve you.")
    ^
IndentationError: expected an indented block` 
```

我们需要这样缩进的原因是，我们需要某种方式向 Python 发出信号，说明在这种情况下应该捆绑哪些代码。我们希望依赖于满足这个条件的所有内容都应该缩进到相同的缩进级别。

让我们稍微扩展一下我们的调酒师计划。一旦我们验证了用户确实超过 18 岁，我希望能够提示用户选择饮料。

我们还有另一个条件关键字叫做`else`,如果我们检查的条件没有满足，它允许我们做一些事情。`else`不能单独使用，需要附着在另一个结构上。在这种情况下，我们将它与一个`if`语句结合起来，但是还有一些其他有趣的选项，我们将在以后的帖子中讨论。

以下是我们的更新计划:

```
`age = int(input("How old are you? "))

if age < 18:
      print("Sorry, we can't serve you.")
else:
    chosen_drink = input("What can I get for you? ")` 
```

现在，如果用户未满 18 岁，他们将被告知我们不能为他们服务，但任何在初始提示中输入 18 岁或以上的人都将被询问他们想喝什么。

我们也可以这样写这个条件块:

```
`age = int(input("How old are you? "))

if age >= 18:
    chosen_drink = input("What can I get for you? ")
else:
    print("Sorry, we can't serve you.")` 
```

我们现在检查允许用户继续的条件，这是更常见的。

有时我们甚至需要更细的粒度，在这种情况下，我们会使用一个`elif`子句。`elif`和`if`很相似，我们需要指定一个表达式来测试。很像`else`，它不能独立存在:我们必须将它与`if`语句结合起来。

当我们像这样包含多个条件时，Python 将一次检查一个条件，直到发现一个条件为真。一旦发现一个真条件，它就执行与该条件相关联的代码，之后不再为这个`if`语句检查进一步的条件。如果没有发现任何条件为真，Python 将执行在`else`子句下缩进的代码。

Python 不需要检查所有的条件，这一点很重要，因为有几个原因。首先，这意味着只有一个条件的代码会运行。其次，这意味着我们的条件的顺序很重要，因为 Python 将只运行与第一个*匹配条件相关的代码。*

让我们稍微切换一下例子，看看一个`elif`子句的作用。我们将再次询问用户的年龄，但这一次我们将使用一个条件语句来对他们收取不同的车票价格。16 岁以下的人将享受儿童优惠价，60 岁以上的人将享受老年退休金。其他人将支付标准票价。

我们可能会这样写:

```
`age = int(input("How old are you? "))

if age < 16:
      print("You are eligible for the child rate of 80p.")
elif age >= 60:
      print("You are eligible for the OAP rate of £1.")
else:
      print("You must pay the standard rate of £1.50.")` 
```

如果我们愿意，我们可以包含越来越多的 elif 语句，这将允许我们对应用程序流进行更精细的控制。

## 真值和条件语句

我们不仅限于在条件语句中使用比较运算符。例如，我们可以利用任何值的真值作为条件。这就是真值真正有用的地方，因为它们允许我们简单地检查集合是否为空。

例如，当我们请求一些输入时，我们可以检查用户是否实际输入了任何内容:

```
`name = input("Please enter your name: ")

if name:  # Checks the truth value of name by calling bool
      print(f"You entered {name}")
else:
      print("You didn't type anything")` 
```

我们将在接下来的文章中回顾这种模式，所以如果现在有一点混乱，请不要担心。

## 练习

1)尝试使用`==`模拟`is`操作员的行为。记住我们有`id`函数来寻找给定值的内存地址，我们可以比较内存地址来检查同一性。

2)尝试使用`is`运算符或`id`函数来研究这两者之间的区别:

```
`numbers = [1, 2, 3, 4]
new_numbers = numbers + [5]` 
```

还有这个:

```
`numbers = [1, 2, 3, 4]
numbers.append(5)` 
```

`new_numbers`和`numbers`是一回事吗？我们追加`5`前后的`numbers`呢？

3)要求用户输入一个数字。告诉用户数字是正数、负数还是零。

4)编写一个程序来确定员工是否应该加班。您应该询问用户该员工本周工作了多少小时，以及该员工的时薪。

如果员工工作超过 40 个小时，你应该打印一条消息，说明该员工应该得到一些额外的工资，以及应得的金额。所欠的额外金额是雇员在 40 小时工作时间内每小时工资的 10%。实际上，员工加班可以得到每小时工资的 110%。

你可以在这里找到这些练习的答案[。](/30-days-of-python/python-30-day-5-exercise-solutions)