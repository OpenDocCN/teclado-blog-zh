<html>
<head>
<title>Day 9: Exercise Solutions | Teclado</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>第9天:锻炼解决方案| Teclado</h1>
<blockquote>原文：<a href="https://blog.teclado.com/python-30-day-9-exercise-solutions/">https://blog.teclado.com/python-30-day-9-exercise-solutions/</a></blockquote><div><article class="pb-12 prose prose-p:font-copy col-start-2 dark:prose-invert">
                    
                    <p>以下是我们为<a href="https://blog.teclado.com/30-days-of-python/"> 30天Python </a>系列中的<a href="/30-days-of-python/python-30-day-9-enumerate-zip">第9天练习</a>提供的解决方案。在检查解决方案之前，请确保您亲自尝试了这些练习！</p>
<h3>1)下面是一些关于BoJack Horseman中角色的简单数据。编写一个使用析构的for循环，以便可以打印每个元组。</h3>
<div class="codehilite"><pre><span/><code><span class="n">main_characters</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">"BoJack Horseman"</span><span class="p">,</span> <span class="s2">"Will Arnett"</span><span class="p">,</span> <span class="s2">"Horse"</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">"Princess Carolyn"</span><span class="p">,</span> <span class="s2">"Amy Sedaris"</span><span class="p">,</span> <span class="s2">"Cat"</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">"Diane Nguyen"</span><span class="p">,</span> <span class="s2">"Alison Brie"</span><span class="p">,</span> <span class="s2">"Human"</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">"Mr. Peanutbutter"</span><span class="p">,</span> <span class="s2">"Paul F. Tompkins"</span><span class="p">,</span> <span class="s2">"Dog"</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">"Todd Chavez"</span><span class="p">,</span> <span class="s2">"Aaron Paul"</span><span class="p">,</span> <span class="s2">"Human"</span><span class="p">)</span>
<span class="p">]</span>
</code></pre></div>

<p>对于本练习，预期的输出应该是这样的:</p>
<div class="codehilite"><pre><span/><code><span class="n">BoJack</span> <span class="n">Horseman</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">horse</span> <span class="n">voiced</span> <span class="n">by</span> <span class="n">Will</span> <span class="n">Arnet</span><span class="o">.</span>
</code></pre></div>

<p>让我们从不进行析构开始。在这个阶段，这应该变得相当常规。我们只是迭代一个集合，并通过索引访问值。</p>
<div class="codehilite"><pre><span/><code><span class="k">for</span> <span class="n">character</span> <span class="ow">in</span> <span class="n">main_characters</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">character</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> is a </span><span class="si">{</span><span class="n">character</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2"> voiced by </span><span class="si">{</span><span class="n">character</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">."</span><span class="p">)</span>
</code></pre></div>

<p>不要忘记为角色的种类改变大小写。在原始数据中，第一个字母是大写的，但是我们希望输出时是小写的。</p>
<p>现在让我们转换我们的循环来使用析构。我们在每个元组中有三个值，所以我们的循环需要三个变量来分配这些值。我将使用<code>character</code>、<code>actor</code>和<code>species</code>。</p>
<div class="codehilite"><pre><span/><code><span class="k">for</span> <span class="n">character</span><span class="p">,</span> <span class="n">actor</span><span class="p">,</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">main_characters</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">character</span><span class="si">}</span><span class="s2"> is a </span><span class="si">{</span><span class="n">species</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2"> voiced by </span><span class="si">{</span><span class="n">actor</span><span class="si">}</span><span class="s2">."</span><span class="p">)</span>
</code></pre></div>

<p>我认为做出这种改变强调了这种析构方法的可读性。</p>
<h3>2)将以下元组解包为4个变量。</h3>
<div class="codehilite"><pre><span/><code><span class="p">(</span><span class="s2">"John Smith"</span><span class="p">,</span> <span class="mi">11743</span><span class="p">,</span> <span class="p">(</span><span class="s2">"Computer Science"</span><span class="p">,</span> <span class="s2">"Mathematics"</span><span class="p">))</span>
</code></pre></div>

<p>这里我们在一个元组中有四段数据。学生的姓名、学生证号、主修科目和辅修科目。这些主题存储在主元组中的第二个元组中，所以我们在析构集合时必须考虑到这一点。</p>
<p>记住，要析构嵌套的集合，我们只需要匹配我们要解包的集合的结构。</p>
<div class="codehilite"><pre><span/><code><span class="n">name</span><span class="p">,</span> <span class="n">id_number</span><span class="p">,</span> <span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"John Smith"</span><span class="p">,</span> <span class="mi">11743</span><span class="p">,</span> <span class="p">(</span><span class="s2">"Computer Science"</span><span class="p">,</span> <span class="s2">"Mathematics"</span><span class="p">))</span>
</code></pre></div>

<p>如果元组存储在变量中，则工作方式相同:</p>
<div class="codehilite"><pre><span/><code><span class="n">student</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"John Smith"</span><span class="p">,</span> <span class="mi">11743</span><span class="p">,</span> <span class="p">(</span><span class="s2">"Computer Science"</span><span class="p">,</span> <span class="s2">"Mathematics"</span><span class="p">))</span>

<span class="n">name</span><span class="p">,</span> <span class="n">id_number</span><span class="p">,</span> <span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">)</span> <span class="o">=</span> <span class="n">student</span>
</code></pre></div>

<h3>3)调查当您尝试压缩两个不同长度的可重复项时会发生什么。</h3>
<p>让我们用一对列表来尝试一下。我们使用的iterable类型并不重要，所以选择你所看到的。</p>
<p>我要有一个三个字母的列表，和一个两个数字的列表。</p>
<div class="codehilite"><pre><span/><code><span class="n">letters</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">"b"</span><span class="p">,</span> <span class="s2">"c"</span><span class="p">]</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div>

<p>现在让我们看看当我们将这两个列表传递给<code>zip</code>时会发生什么。记住<code>zip</code>是懒惰的，所以我们必须将结果转换成列表或元组来打印任何有意义的输出。</p>
<div class="codehilite"><pre><span/><code><span class="n">letters</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">"b"</span><span class="p">,</span> <span class="s2">"c"</span><span class="p">]</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">letters</span><span class="p">,</span> <span class="n">numbers</span><span class="p">)))</span>
</code></pre></div>

<p>我们在终端中得到的是:</p>


<p>我们可以看到，一旦我们到达最短集合的末尾，<code>zip</code>就停止了。如果我们有三个不同长度的集合，同样的事情也会发生。</p>
<p>这是一个需要记住的非常重要的细节，因为如果你不小心的话，它会导致意外的数据丢失。</p>
<p>如果你需要确保所有的值都出现在结果iterable中，我们有一些选择，在今天帖子的附加资源部分讨论。</p> 
                </article>
            
            </div>    
</body>
</html>