<html>
<head>
<title>Handling the next URL when logging in with Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Flask登录时处理下一个URL</h1>
<blockquote>原文：<a href="https://blog.teclado.com/handling-the-next-url-when-logging-in-with-flask/">https://blog.teclado.com/handling-the-next-url-when-logging-in-with-flask/</a></blockquote><div><div class="post-content">
<p>当一个注销的用户想要访问一个受保护的页面时，我们通常会将他们重定向到应用程序中的登录页面。然而，在登录后，许多应用程序会将用户发送到他们的“个人资料”或“仪表板”页面，而不是他们最初想去的地方。</p><p>这可能非常令人沮丧，所以让我们学习如何在使用我们的页面时为用户提供更好的体验。</p><h2 id="prerequisites">先决条件</h2><p>对于这篇博文，您需要一个具有登录功能的Flask应用程序，但是它还不能正确处理这个流。</p><p>此外，你应该阅读我们之前的系列博客文章“通过要求登录保护Flask应用中的端点”。在那里，我们介绍了如何编写装饰器，我们将在这篇文章中修改它。</p><p>如果你手边没有样品瓶应用程序，我为你编写了一个。你可以在这里访问它<a href="https://github.com/tecladocode/simple-flask-template-app/tree/feature/login_decorator">。为了测试这个流，启动应用程序并:</a></p><ol><li>访问<code>/profile</code>端点。此端点已被配置为需要登录，并将您重定向到登录页面。</li><li>使用测试用户详细信息<code>jose</code>和<code>1234</code>登录。</li><li>注意，现在你在<code>/</code>结束，而不是在<code>/profile</code>结束。这就是我们在这篇博文中要解决的问题。</li></ol><h2 id="telling-the-login-endpoint-where-to-send-users-next">告诉登录端点接下来将用户发送到哪里</h2><p>为了让我们的应用程序能够将用户重定向到正确的地方，<code>/login</code>端点必须知道那个地方是什么。因此，当用户登录时，我们需要能够告诉它他们想要在哪里结束。</p><p>类似地，为了让<code>/login</code>页面知道用户想要到达哪里，<em> it </em>必须被告知最终目的地是哪里。</p><p>因此，数据流将是这样的:</p><ol><li>用户想要访问<code>/profile</code>。这是受保护的，所以我们将用户重定向到<code>/login</code>页面以及最终目的地。</li><li>用户登录，因此他们提交登录表单，在提交中我们包括最终目的地。</li><li>我们在Python代码中处理登录，不是将用户重定向到默认目的地，而是将他们重定向到他们想要的目的地。</li></ol><p>让我们从做第一步开始:告诉<code>/login</code>页面最终目的地是哪里。为此，我们将修改<code>login_required</code>装饰器。</p><p>此刻，装饰者看起来像这样:</p><pre><code class="language-python">def login_required(func):
    @functools.wraps(func)
    def secure_function(*args, **kwargs):
        if "email" not in session:
            return redirect(url_for("login"))
        return func(*args, **kwargs)

    return secure_function
</code></pre>
<p>但是我们想添加一段数据发送到<code>/login</code>页面:</p><pre><code class="language-python">def login_required(func):
    @functools.wraps(func)
    def secure_function(*args, **kwargs):
        if "email" not in session:
            return redirect(url_for("login", next=request.url))
        return func(*args, **kwargs)

    return secure_function
</code></pre>
<p>这意味着当我们将用户重定向到登录页面时，我们会将他们发送到<code>/login?next=/profile</code>，而不是发送到<code>/login</code>。因为我们将这些数据包含在URL中，这意味着页面本身可以在呈现时访问这些信息。</p><h2 id="passing-that-information-when-a-user-logs-in">当用户登录时传递该信息</h2><p>但是当用户提交表单时，我们的Python代码将不再能够访问<code>?next=/profile</code>。我们必须将该信息传递到表单中。</p><p>唯一的方法是在表单中包含一个字段，将最终目的地作为文本。这有点粗糙，但是我们可以通过在表单中添加一个隐藏字段来做到这一点，而不会干扰用户流。</p><p>让我们修改我们的登录表单，并将该字段包含在其中:</p><pre><code class="language-html">&lt;input
    type="hidden"
    name="next"
    value="{{ request.args.get('next', '') }}"
/&gt;
</code></pre>
<p>它从查询字符串参数中读取<code>next</code>参数，并将其值包含在一个隐藏字段中。当我们提交表单时，我们将能够在Python代码中访问这个字段，并且能够使用它的值来重定向用户。</p><p>注意该字段不需要标签，因为它是隐藏的，所以用户在页面上看不到它。</p><h2 id="using-the-hidden-field-to-redirect-the-user">使用隐藏字段重定向用户</h2><p>最后，当我们收到隐藏字段值时，我们必须使用它将用户重定向到他们最终的目的地。</p><p>请记住，如果用户没有尝试访问某个特定的站点，这个字段可能为空，所以我们只希望在这个字段有值的情况下将用户重定向到这个位置——否则我们仍然会重定向到默认的目的地(目前是<code>/</code>)。</p><p>目前，我们的登录处理程序代码如下所示:</p><pre><code class="language-python">@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")

        if username in users and users[username][1] == password:
            session["username"] = username
            return redirect(url_for("profile"))
    return render_template("login.html")
</code></pre>
<p>我们将把它改成这样:</p><pre><code class="language-python">@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")
        next_url = request.form.get("next")

        if username in users and users[username][1] == password:
            session["username"] = username
            if next_url:
                return redirect(next_url)
            return redirect(url_for("profile"))
    return render_template("login.html")
</code></pre>
<p>这样做的目的是读取隐藏字段的内容，并使用它来重定向用户。</p><p>注意，我们不需要用<code>next_url</code>调用<code>url_for</code>，因为它已经是我们应用程序中的一个URL，而不是一个端点处理程序。</p><h2 id="recap">概述</h2><p>概括地说，为了将用户重定向到他们的预期目的地，而不是默认的“登录”页面，我们必须:</p><ol><li>将最终目的地传递给登录页面。</li><li>从那里，将最终目的地传递给登录处理程序。</li><li>使用它来重定向用户，而不是将他们发送到默认的目标页面。</li></ol><p>尽管如此，这似乎是显而易见的——但要记住每个端点都是完全独立的，每当我们想要进行这种类型的通信时，我们都需要通过用户的浏览器传递数据，这一点总是很棘手。</p><p>如果你想在这篇博文之后查看最终的完整代码，请使用<a href="https://github.com/tecladocode/simple-flask-template-app/tree/feature/login_next">这个链接</a>！</p><p>如果你想阅读以前关于这个主题的帖子，这些帖子涉及Flask web应用程序开发的更多基础元素，请在这里阅读:</p><h2 id="wrapping-up">包扎</h2><p>感谢您的阅读！我希望你觉得这篇文章有趣并且有用。</p><p>如果你想了解更多关于使用Flask进行web开发的知识，请查看我们的<a href="https://www.udemy.com/the-complete-python-web-course-learn-by-building-8-apps/?couponCode=BLOGGER">完整Python Web课程</a>。如果您是Python的新手，并且想要更完整地理解基础知识(包括装饰器！)，查看我们的<a href="https://udemy.com/the-complete-python-course/?couponCode=BLOGGER">完整Python课程</a>。</p><p>您可能也想注册下面的邮件列表，因为我们每个月都会向我们的订户发送博客文章更新和折扣代码！</p><p>感谢阅读，我们下次再见！</p>
</div>
</div>    
</body>
</html>