<html>
<head>
<title>How to upload files to Backblaze B2 using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何使用Python将文件上传到Backblaze B2</h1>
<blockquote>原文：<a href="https://blog.teclado.com/python-file-upload-backblaze-b2/">https://blog.teclado.com/python-file-upload-backblaze-b2/</a></blockquote><div><div class="post-content">
<p>如果您的应用程序接收用户上传的文件，那么您将面临许多令人头痛的问题。将文件存储在服务器中很难扩展，存储在数据库中通常会很慢(而且很贵！).最好的选择是将文件存储在专门为此设计的web服务中。</p>
<p>在本文中，我们来谈谈Backblaze B2，这是一个文件存储解决方案，具有超级<a href="https://b2-sdk-python.readthedocs.io/en/master/quick_start.html">易用的API </a>和慷慨的免费层。另外，它通过<a href="https://boto3.amazonaws.com/v1/documentation/api/latest/guide/quickstart.html"> boto3 </a>与AWS S3 API完全兼容。</p>
<p>今天我将向你展示如何使用<code>b2-sdk-python</code>，他们的内部API，而不是<code>boto3</code>。</p>
<h2 id="setting-up-your-b2-account">设置您的B2帐户</h2>
<p>首先，<a href="https://www.backblaze.com/b2/sign-up.html?referrer=nopref">通过他们的门户网站注册</a>。</p>
<p>一旦完成，进入你的<a href="https://secure.backblaze.com/b2_buckets.htm"> B2云存储桶</a>，并创建一个。将文件设为私有，禁用加密(目前)，并禁用对象锁。</p>
<p><img src="../Images/068fdd8af872adf9857bcc6759553bb2.png" alt="Creating a bucket using B2, with the name teclado-b2-upload, private files, disabled encryption and disabled object lock" loading="lazy" data-original-src="https://res-4.cloudinary.com/teclado/image/upload/q_auto/v1/blog/b2-create-bucket.png"/></p>
<p>现在让我们用Python上传一个文件。之后，我将向您展示如何将上传到B2与您的Flask应用程序集成在一起。</p>
<h2 id="upload-to-backblaze-b2-using-python">使用Python上传到Backblaze B2</h2>
<p>上传文件到Backblaze B2需要几个步骤:</p>
<ol>
<li>授权您的帐户。</li>
<li>打开你的桶。</li>
<li>弄清楚你上传的是什么。</li>
<li>实际上传文件。</li>
</ol>
<h3 id="account-authorization-with-backblaze-b2-and-python">使用Backblaze B2和Python进行帐户授权</h3>
<p>为此，你需要你的应用密钥。请访问网站上“帐户”下的“应用程序密钥”部分获取应用程序密钥:</p>
<p><img src="../Images/1b49c33508eee12f7f8af18832944b0a.png" alt="The B2 menu in the sidebar showing app keys selected" loading="lazy" data-original-src="https://res-5.cloudinary.com/teclado/image/upload/q_auto/v1/blog/b2-app-keys-menu.png"/></p>
<p>然后，滚动到底部，点击“添加新的应用程序密钥”。</p>
<p>在这里，您会想要:</p>
<ul>
<li>为应用程序密钥命名。</li>
<li>只允许访问您希望在应用程序中使用的存储桶(如果您希望访问多个存储桶，则允许访问更多存储桶)。</li>
<li>使它“只写”，因为这个应用程序将允许文件上传，但它不允许我们读取文件。</li>
</ul>
<p><img src="../Images/c25157d6b62db42cd6132e86a46d52ae.png" alt="Creating an App Key with the name teclado-uploads-key, access to the teclado-b2-upload bucket, and write only selected" loading="lazy" data-original-src="https://res-2.cloudinary.com/teclado/image/upload/q_auto/v1/blog/b2-create-app-key.png"/></p>
<p>然后，您会想要保存<code>keyID</code>和<code>applicationKey</code>。为此，在您的项目目录中创建一个<code>.env</code>文件，并将值放在那里(我的是假值):</p>
<pre><code class="language-text">B2_KEY_ID=045f47eaec1gfgg94100002
B2_APPLICATION_KEY=J131s4ffbaq6i41SR+Hk131k1kj1jak+ZI
</code></pre>
<p>现在我们已经在这里得到了这些文件，如果您打算使用Git来做这件事，许多人肯定会将<code>.env</code>添加到您的<code>.gitignore</code>中:</p>
<pre><code class="language-text">.env
*.pyc
.DS_Store
.venv
# Other things you want to ignore
</code></pre>
<p>好了，现在让我们安装Backblaze B2 Python SDK。</p>
<p>首先让我们创建一个名为<code>requirements.txt</code>的文件，其中包含以下内容:</p>
<pre><code>b2sdk
python-dotenv
</code></pre>
<p><code>python-dotenv</code>库将用于读取我们的<code>.env</code>文件的内容，并将它们放入环境变量中。然后，我将创建一个虚拟环境，激活它，并安装两个库:</p>
<pre><code class="language-bash">$ pyenv local 3.10.7
$ pyenv exec python -m venv .venv
$ source .venv/bin/activate  # different on Windows
$ pip install -r requirements.txt
</code></pre>
<p>接下来，为实际的文件上传创建一个Python文件，比如<code>app.py</code>。此时，最好找到一个文件或图像来测试上传，并把它放在你的项目文件夹中！</p>
<pre><code class="language-python">import os
import b2sdk.v2 as b2
from dotenv import load_dotenv

load_dotenv()

info = b2.InMemoryAccountInfo()
b2_api = b2.B2Api(info)

application_key_id = os.getenv("B2_KEY_ID")
application_key = os.getenv("B2_APPLICATION_KEY")

b2_api.authorize_account("production", application_key_id, application_key)
</code></pre>
<p>上面的<code>"production"</code>就是境界。不幸的是<a href="https://b2-sdk-python.readthedocs.io/en/master/api/api.html#b2sdk.v2.B2Api.authorize_account">没有太多信息</a>关于这意味着什么。</p>
<h3 id="access-your-bucket-with-the-sdk">使用SDK访问您的存储桶</h3>
<p>这个很简单:</p>
<pre><code class="language-python">bucket = b2_api.get_bucket_by_name("teclado-b2-upload")
</code></pre>

<p>现在，我们必须找到想要上传的文件，并确定想要添加到图像中的任何元数据。</p>
<p>用最简单的话来说，就是这样做:</p>
<pre><code class="language-py">from pathlib import Path

file_name = "sample.png"
local_file = Path(file_name).resolve()
metadata = {"key": "value"}
</code></pre>
<p>这里我使用了<code>pathlib</code>,虽然这并不是绝对必要的，这样以后如果你想开始把东西放在子目录中，这样做更容易一些。</p>
<h3 id="actually-process-the-upload-with-the-sdk">用SDK实际处理上传</h3>
<p>最后，要将文件推送到B2存储桶，请执行以下操作:</p>
<pre><code class="language-python">uploaded_file = bucket.upload_local_file(
    local_file=local_file,
    file_name=file_name,
    file_infos=metadata,
)

print(b2_api.get_download_url_for_fileid(uploaded_file.id_))
</code></pre>
<p>这样做上传你的文件，并给你一个网址，你可以看到你的文件...如果在创建存储桶时将文件设置为“public”。因为我们将它们设置为“private ”,所以在访问该URL时会出现401未授权错误。</p>
<h3 id="how-to-see-the-uploaded-file-through-the-web-portal">如何通过web门户查看上传的文件</h3>
<p>虽然文件在桶中，但你可以通过B2门户网站进入桶中看到它。首先访问您的存储桶:</p>
<p><img src="../Images/9f78f1590205a7d74631518a5e002c5a.png" alt="Screenshot showing Browse Files and the available buckets in your account" loading="lazy" data-original-src="https://res-1.cloudinary.com/teclado/image/upload/q_auto/v1/blog/b2-browse-files.png"/></p>
<p>然后你会看到那里的图像！</p>
<p><img src="../Images/588ad7e950dc59357af24833efa63b00.png" alt="Screenshot showing the available images, in this case sample.png, in your bucket" loading="lazy" data-original-src="https://res-3.cloudinary.com/teclado/image/upload/q_auto/v1/blog/b2-files-sample.png"/></p>
<p>如果你点击图片，你可以看到它的样子，你也可以在“文件信息”下看到你的图片的存储信息:</p>
<p><img src="../Images/adaaa799fb79ca5199ad03aec571406a.png" alt="Screenshot showing the image modal window with information about it in B2" loading="lazy" data-original-src="https://res-3.cloudinary.com/teclado/image/upload/q_auto/v1/blog/b2-sample-image-modal.png"/></p>
<h2 id="final-code">最终代码</h2>
<p>这是我的<code>app.py</code>上传文件到Backblaze B2的代码！</p>
<pre><code class="language-py">import os
import b2sdk.v2 as b2
from dotenv import load_dotenv
from pathlib import Path

load_dotenv()

info = b2.InMemoryAccountInfo()
b2_api = b2.B2Api(info)

application_key_id = os.getenv("B2_KEY_ID")
application_key = os.getenv("B2_APPLICATION_KEY")

b2_api.authorize_account("production", application_key_id, application_key)

bucket = b2_api.get_bucket_by_name("teclado-b2-upload")

file_name = "sample.png"
local_file = Path(file_name).resolve()
metadata = {"key": "value"}

uploaded_file = bucket.upload_local_file(
    local_file=local_file,
    file_name=file_name,
    file_infos=metadata,
)

print(b2_api.get_download_url_for_fileid(uploaded_file.id_))
</code></pre>
<h2 id="integrate-b2-uploads-with-your-flask-app">整合B2上传与你的烧瓶应用程序</h2>
<p>在最近的Flask博客文章中，我们提到了图片上传，但是我们留下了一个关键问题:如何处理上传的文件。</p>
<p>让我们将Backblaze B2上传与该项目相结合。如果您忘记了，该项目有一个Flask应用程序，它有两个路径:一个用于提供带有文件上传表单的页面，另一个用于接受文件“块”。每个块都是上传文件的一部分。分块是由库“Dropzone.js”完成的，这使得非常大的文件不会完全阻塞Flask应用程序。</p>
<p>我们的<code>requirements.txt</code>:</p>
<pre><code class="language-text">flask
</code></pre>
<p>我们的<code>app.py</code>:</p>
<pre><code class="language-python">import os
from pathlib import Path

from flask import Flask, render_template, request
from werkzeug.utils import secure_filename

app = Flask(__name__)


@app.get("/")
def index():
    return render_template("index.html")


@app.post("/upload")
def upload_chunk():
    file = request.files["file"]
    file_uuid = request.form["dzuuid"]
    # Generate a unique filename to avoid overwriting using 8 chars of uuid before filename.
    filename = f"{file_uuid[:8]}_{secure_filename(file.filename)}"
    save_path = Path("static", "img", filename)
    current_chunk = int(request.form["dzchunkindex"])

    try:
        with open(save_path, "ab") as f:
            f.seek(int(request.form["dzchunkbyteoffset"]))
            f.write(file.stream.read())
    except OSError:
        return (
            "Error saving file.",
            500,
        )  # 400 and 500 error codes show up in Dropzone as errors

    total_chunks = int(request.form["dztotalchunkcount"])

    if current_chunk + 1 == total_chunks:
        # This was the last chunk, the file should be complete and the size we expect
        if os.path.getsize(save_path) != int(request.form["dztotalfilesize"]):
            return "Size mismatch.", 500

    return "Chunk upload successful.", 200
</code></pre>
<p>我们的<code>index.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;script src="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="98fceaf7e8e2f7f6fdd8ad">[email protected]</a>/dist/min/dropzone.min.js"&gt;&lt;/script&gt;
    &lt;link rel="stylesheet" href="https://unpkg.com/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6a0e18051a1005040f2a5f">[email protected]</a>/dist/min/dropzone.min.css" type="text/css" /&gt;
    &lt;title&gt;File Upload with Dropzone.js&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form
        method="POST"
        action="/upload"
        class="dropzone dz-clickable"
        id="dropper"
        enctype="multipart/form-data"
    &gt;
    &lt;/form&gt;

    &lt;script type="application/javascript"&gt;
        Dropzone.options.dropper = {
            paramName: "file",
            chunking: true,
            forceChunking: true,
            url: "/upload",
            maxFilesize: 1025, // megabytes
            chunkSize: 10000 // bytes
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>要将B2集成到这个应用程序中，我们所要做的就是连接到我们的应用程序并获取我们的bucket，然后当我们接收完所有的文件块后，将完成的文件上传到B2。</p>
<p>我们确实需要将文件<em>存储在某个地方</em>几秒钟，因为我们的上传方法要求文件在上传到B2之前在磁盘中。</p>
<p>我们的应用程序已经在这样做了，所以没有太多要添加的。概括一下:</p>
<ol>
<li>用你的<code>B2_KEY_ID</code>和<code>B2_APPLICATION_KEY</code>创建你的<code>.env</code>文件。</li>
<li>授权您的帐户。</li>
<li>去拿你的桶。</li>
<li>上传您的文件。</li>
</ol>
<h3 id="authorise-your-b2-account-and-get-the-bucket-when-creating-the-app">授权您的B2帐户，并在创建应用程序时获得桶</h3>
<p>在文件的顶部，创建应用程序后，我将添加我们已经看到的代码来授权帐户。我已经在已经存在的行上留下了评论。</p>
<pre><code class="language-python">import os  # existing code
import b2sdk.v2 as b2
from pathlib import Path  # existing code

from flask import Flask, render_template, request  # existing code
from werkzeug.utils import secure_filename  # existing code
from dotenv import load_dotenv

load_dotenv()

app = Flask(__name__)  # existing code

info = b2.InMemoryAccountInfo()
b2_api = b2.B2Api(info)

application_key_id = os.getenv("B2_KEY_ID")
application_key = os.getenv("B2_APPLICATION_KEY")

b2_api.authorize_account("production", application_key_id, application_key)

bucket = b2_api.get_bucket_by_name("teclado-b2-upload")
</code></pre>
<h3 id="upload-the-file-when-you-receive-the-last-chunk">当您收到最后一块时，请上传文件</h3>
<p>目前，我们的上传端点中有这组if语句:</p>
<pre><code class="language-python">if current_chunk + 1 == total_chunks:
    # This was the last chunk, the file should be complete and the size we expect
    if os.path.getsize(save_path) != int(request.form["dztotalfilesize"]):
        return "Size mismatch.", 500
</code></pre>
<p>我们正在检查我们已经完成了文件的上传，我们正在检查是否有错误。</p>
<p>我们可以在内部if语句中添加一个<code>else</code>分支，当上传成功时它将运行。在那里，我们将进行上传！记住文件应该已经在<code>./static/img/{filename}</code>了。还要记住从本地磁盘上删除文件，这样它们就不会永远存在了:</p>
<pre><code class="language-python">if current_chunk + 1 == total_chunks:
    # This was the last chunk, the file should be complete and the size we expect
    if os.path.getsize(save_path) != int(request.form["dztotalfilesize"]):
        return "Size mismatch.", 500
    else:
        # Upload successful, so let's put the file in B2
        uploaded_file = bucket.upload_local_file(
            local_file=save_path.resolve(),
            file_name=filename
        )
        os.remove(save_path)  # Delete file so they don't stick around forever

        print(b2_api.get_download_url_for_fileid(uploaded_file.id_))
</code></pre>
<p>就是这样！这应该上传你的文件(用一个独特的名字)到Backblaze B2。</p>
<p>在这篇文章中，我们学习了如何使用Python将文件上传到Backblaze B2，以及如何使用Dropzone.js将文件上传集成到Flask应用程序中。我希望你喜欢它！</p>
<p>如果您想了解更多关于使用Flask和Python进行web开发的知识，包括HTML、CSS、设计web应用程序、交互性等等，请考虑参加我们的<a href="https://go.tecla.do/web-dev-course-sale"> Web开发者训练营Flask和Python </a>！</p>

</div>
</div>    
</body>
</html>