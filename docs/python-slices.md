# Python 切片

> 原文：<https://blog.teclado.com/python-slices/>

在这篇文章中，我想告诉你一些关于 Python 切片的事情。切片是一个强大的工具，但是如果不小心的话也很容易出错。

那么，切片到底是什么？切片是从现有序列的某个部分创建新序列的过程。这实际上是一个非常直观的概念，非常类似于切蛋糕以获得整体的一部分。

我们可以对 Python 中的任何*序列类型*进行切片。这包括字符串、列表、元组、字节对象和字节数组。

因为切片依赖于项在序列中的位置，所以它不能用于像集合这样不保持顺序的东西。更重要的是，它们不是由连续的非负整数索引的，这就是为什么字典也不能切片，尽管在现代 Python 中有可靠的排序。

## 创建切片

让我们定义我们的第一个切片。

```py
slice_instance = slice(0, 2) 
```

虽然`slice`在这里看起来像一个函数，但它实际上是一个类。因此，我们只是将`slice_instance`绑定到某个`slice`对象上。

如果我们打印出`slice_instance`的类型，我们可以看到这一点:

```py
print(type(slice_instance))  # <class 'slice'> 
```

到目前为止一切顺利。那么当我们创建 slice 对象时，我们传递给 slice 的那些数字是什么呢？

如果我们看一下 slice 类的[文档](https://docs.python.org/3/library/functions.html#slice)，我们会看到 slice 有三个参数:

> 切片(开始，停止[，步进])

如果您不熟悉文档中的参数符号，方括号中的项目是可选的。

很好，所以我们传入了参数`start`和`stop`。我们一会儿再回来。这些`start`和`stop`值表示某个尚未指定的序列中的索引。

那么我们如何使用这个切片对象呢？好吧，我们需要一些序列来试验一下。

让我们从一个简单的列表开始:

```py
x = [1, 2, 3, 4, 5] 
```

我们可以使用下标语法获得序列的一部分:

```py
x_slice = x[slice_instance]
print(x_slice)  # [1, 2] 
```

因为我们的`slice_instance`从索引 0 到索引 2，所以我们只得到了`x`列表的那一部分。

这里有几点需要注意:

1.  `x_slice`属于列表类型。
2.  `x`的索引 2 处的项目不包含在`x_slice`中。

这让我们想到了关于切片的第一个警告:我们为 stop 参数提供的索引是**而不是**。

### 分割其他序列类型

分割其他序列类型使用完全相同的语法。

我们可以定义一个切片对象，然后将其用于任何序列类型，如下所示:

```py
s = slice(1, 4)

t = (1, 2, 3, 4, 5)  # tuple
l = [1, 2, 3, 4, 5]  # list
c = "12345"          # string

print(t[s])  # (2, 3, 4)
print(l[s])  # [2, 3, 4]
print(c[s])  # 234 
```

从上面的例子中你可能已经注意到了，对一个序列进行切片会得到一个相同类型的序列。

请记住，字符串只是字符序列，因此是切片的完美候选！

### 内联定义切片对象

我们可以这样做，而不是定义一个 slice 对象，将其绑定到一个变量，然后将该变量名作为下标语法的一部分:

```py
t = (1, 2, 3, 4, 5)
print(t[slice(1, 4)])  # (2, 3, 4) 
```

然而，还有一种更快的方法，我们将在接下来讨论。

## 更快的方法

Python 有一种替代语法，可以直接在方括号中定义切片，我们将它作为下标语法的一部分。

让我们定义与上面使用的相同的切片对象，但是使用新的语法:

```py
t = (1, 2, 3, 4, 5)
print(t[1:4])  # (2, 3, 4) 
```

您可能知道，第一个数字是我们的起始索引，然后我们提供一个冒号来分隔我们的值，第二个值是停止索引。就像之前一样，这个停止指数并不具有包容性。

这种新语法对所有序列类型都起相同的作用。

### 将一些值留空

可能会让您感到惊讶的是，以下每一项都是有效的语法:

```py
print(t[:4])
print(t[1:])
print(t[:]) 
```

那么，这些到底是什么意思呢？

当我们错过起始索引时，这意味着“从序列的开始处开始”。

当我们错过停止索引时，这意味着“在序列的末尾停止”。

在后一种情况下，最后一个元素包含在新的切片中。

把这些放在一起，我们就能猜出最后一个例子的意思:“把整个序列给我”。当你错过了开始和结束的指标，你得到了一切。

## 使用步长值

在这篇文章的开始，我提到我们也可以在创建切片对象时提供一个可选的步长值。这允许我们通过提供大于`1`的步长来跳过值。

例如:

```py
t = (1, 2, 3, 4, 5)
print(t[1:4:2])  # (2, 4) 
```

我们从索引`1`处的项目开始，然后直接进入索引`3`处的项目。

### 负阶跃值

步长值不需要为正，这实际上是一个非常有用的属性。当一个步长值为负时，我们像往常一样从起始索引开始，但是然后沿着序列反向移动。

例如，我们可能希望从索引`4`开始，在索引`2`停止，并以`-1`的步长移动。

```py
t = (1, 2, 3, 4, 5)
print(t[4:2:-1]  # (5, 4) 
```

注意，结果以与原始元组相反的顺序返回。这是因为首先遇到的是元组末尾的值，我们一直向元组的开头前进。

使用扩展切片，我们仍然可以使用下面的语法获得一个完整的列表:`[::]`。看起来有点晦涩难懂，但它只是表示从序列的开头开始，在结尾停止，使用默认的步长值:`1`。

结合负阶跃值。我们可以使用这样的语法来检查一个序列是否是一个[回文](https://en.wikipedia.org/wiki/Palindrome)，例如:

```py
def palindrome_check(word):
	if word == word[::-1]:  # check against full sequence in reverse order
		return True
	return False

print(palindrome_check("kayak"))  # True
print(palindrome_check("lemon"))  # False 
```

### 关于负步长值的警告

关于切片的一个问题是，很容易得到一个空切片，尤其是当负值出现时。

例如，我们可以尝试对一个旧切片使用负阶跃:

```py
t = (1, 2, 3, 4, 5)
print(t[1:4:-1])  # ()  <- Empty tuple 
```

但是上面的例子将返回一个空的元组。这是因为不可能按照`-1`的步骤从索引`1`到达索引`4`。应该写的是`t[4:1:-1]`，从比我们结束的地方更高的索引开始，它应该打印`(5, 4, 3)`。

## 负指数

除了提供负的步长值，我们还可以为索引提供负数。

当使用负索引时，我们从序列的末尾开始倒计数。在我们上面的元组`t`中，索引`-1`与索引`4`相同。换句话说，元组中的最后一项。

`t`中索引`0`处的项目也在索引`-5`处。因此，我们可以这样写一个切片:

```py
t = (1, 2, 3, 4, 5)
print(t[-1:-5:-1])  # (5, 4, 3, 2) 
```

我选择这个例子有一个特殊的原因，因为它强调了使用切片时容易陷入的另一个陷阱。当使用负指数时，止损值仍然是**而不是**。为了包含索引`0`处的项目，我们必须编写:

```py
t[-1:-6:-1] 
```

## 概述

*   切片可用于从另一个序列的某个部分创建序列。
*   只有*序列类型*可以切片，因为切片依赖于非负索引索引的项目。
*   我们可以定义一个 slice 对象，创建一个`slice`类的实例，它有三个参数:起始索引、停止索引和可选的步长值。请记住，给定序列的停止索引处的项目是包含在切片中的**而不是**。
*   我们可以创建一个特定序列的切片，方法是将一个切片对象直接传递到该序列后面的一对方括号中，例如`some_sequence[slice(1, 2)]`。我们还可以在这些方括号中使用特殊的 slice 语法，这样就不需要使用来显式创建一个 slice 对象，例如`some_sequence[1:2]`。
*   索引值和步长值都可以是负值，但是在使用负值时我们必须小心，因为很容易得到一个不包含任何内容的切片。否定步骤的一个用例是快速反转一个序列，如下所示:`some_sequence[::-1]`。

我希望你学到了新的东西，如果你想进一步提升你的 Python 技能，你可能想试试我们的[完整 Python 课程](https://www.udemy.com/the-complete-python-course/?couponCode=BLOGGER)。

请务必查看下周的帖子，我们将在那里更深入地讨论切片技术。