<html>
<head>
<title>Introduction to Object-Oriented Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python中面向对象编程的介绍</h1>
<blockquote>原文：<a href="https://blog.teclado.com/introduction-to-object-oriented-programming-in-python/">https://blog.teclado.com/introduction-to-object-oriented-programming-in-python/</a></blockquote><div><div class="post-content">
<p>在这篇文章中，我们将讨论面向对象编程(OOP)。这篇文章是针对初学者的，但是如果你是一个有经验的开发人员，你也可以从中找到一些有用的信息。</p>
<p>我们将从名称空间和作用域的概念开始，因为这是理解类如何工作的良好起点。然后，我们将讨论Python中的类、对象和不同类型的方法。</p>
<p>读完这篇文章后，你将能够回答以下问题:</p>
<ul>
<li>什么是名称空间和范围？</li>
<li>什么是类、对象、方法和属性？</li>
<li>类属性和实例属性有什么不同？</li>
<li>什么是特殊方法？</li>
<li><code>__init__</code>方法是做什么的？</li>
<li>有哪些<code>__repr__</code>和<code>__str__</code>的方法？</li>
</ul>
<p>我们还将简要讨论使用面向对象编程来代替函数式编程。</p>
<h1 id="pythonnamespacesandscopes">Python名称空间和范围</h1>
<h2 id="whatisanamespace">什么是名称空间？</h2>
<p>在Python中，每当我们创建变量、函数或类时，我们都会给它们命名。这些允许我们在后面的代码中引用相关的值。</p>
<p>例如:</p>
<pre><code class="language-python">name = "Lincoln State Bank"
net_income = [7480, 1983, 7799, 4466, 4672]

def print_info():
    return f"{name}'s net income is ${sum(net_income)}."
</code></pre>
<p>这里我们创建了三个名字:<code>name</code>、<code>net_income</code>和<code>print_info</code>。</p>
<p>名称空间是名称到它们的值的映射。</p>
<p>当您输入一个函数定义时，会创建一个新的名称空间，每个函数都有一个不同的名称空间。函数内部定义的名字是函数命名空间的一部分。</p>
<p>您创建的每个模块也有自己的名称空间。模块是一个Python文件，包含函数、类或<a href="https://www.ionos.com/digitalguide/websites/web-development/imperative-programming/">命令代码</a>形式的源代码。</p>
<p>您可以通过使用内置函数<code>dir()</code>来查看模块名称空间中的名称:</p>
<pre><code class="language-python">import math

print(dir(math))
</code></pre>
<p>该示例的输出如下所示:</p>
<pre><code class="language-python">['acos', 'acosh', 'asin', 'asinh', 'atan', 'log' ..., ...]
</code></pre>
<p>您可以通过在模块和名称之间使用点<code>.</code>符号进行关联来访问模块名称空间中的每个名称。在这种情况下，<code>math</code>和<code>log</code>:</p>
<pre><code class="language-python">import math

x = 5
log_of_x = math.log(x)
print(log_of_x)
</code></pre>
<p>如果您运行上面的代码，您的输出应该如下所示:</p>
<pre><code>1.6094379124341003
</code></pre>
<p><em>注意:<code>dir()</code>不能保证在给定的名称空间中提供详尽的名称列表。点击了解更多<a href="https://docs.python.org/3/library/functions.html#dir">。</a></em></p>
<p>Python有很多名称空间。例如，<code>requests</code>模块和<code>dict</code>对象都有一个<code>get()</code>方法。但是因为它们在不同的名称空间中，所以不会互相干扰。</p>
<p>“名称空间”这个词已经告诉我们，它是Python存储名称的空间。这些名称是我们在创建变量、函数、类或其他任何东西时分配给几乎所有Python值的名称。</p>
<h2 id="whatisthescope">范围是什么？</h2>
<p><em>作用域</em>被定义为程序的一个给定部分，其中一个名称空间是可直接访问的。换句话说，作用域指向程序中可以访问和使用元素的位置。</p>
<p>文件顶层的变量是该文件全局范围的一部分。在文件的任何地方都可以访问它们。在下面的文件中，变量名<code>x</code>的作用域是全局的:</p>
<pre><code class="language-python">import math

x = 5


def get_log_of_x():
    log_of_x = math.log(x)
    print(log_of_x)


print(x)  # 5
get_log_of_x()  # 1.6094379124341003
</code></pre>
<p>在赋值的情况下，变量作用域从函数级开始。函数中的变量是局部的，它们只对程序的给定部分可见。局部范围通常指当前函数的局部命名空间:</p>
<pre><code class="language-python">import math


def get_log_of_x():
    x = 5
    log_of_x = math.log(x)
    print(log_of_x)


print(x)  # NameError: name 'x' is not defined
get_log_of_x()  # 1.6094379124341003
</code></pre>
<p>这里的<code>x</code>是函数局部作用域的一部分，所以它在函数外部是不可访问的。</p>
<p>如果我们试图在定义变量之前使用它，Python将会引发一个运行时错误:</p>
<pre><code class="language-python">import math


def get_log_of_x():
    log_of_x = math.log(x)
    x = 5

    print(log_of_x)


get_log_of_x()
# UnboundLocalError: local variable 'x' referenced before assignment
# Process finished with exit code 1
</code></pre>
<p>不同命名空间中的名称没有关系。在下面的例子中，我们在两个不同的函数中使用了变量名<code>x</code>。因为每个函数都有自己的名称空间，所以使用相同的变量名不会导致任何范围问题。在每个函数中，变量<code>x</code>是局部范围的一部分:</p>
<pre><code class="language-python">import math


def get_log_of_x():
    x = 5
    log_of_x = math.log(x)
    print(log_of_x)


get_log_of_x()  # 1.6094379124341003


def square_root_x():
    x = 21
    sqrt = math.sqrt(x)
    print(sqrt)


square_root_x() # 4.58257569495584
</code></pre>
<p>如果你调用一个函数，解释器将按照特定的顺序寻找关联:局部、封闭、全局和内置(从内向外)。</p>
<p>在下图中，您可以看到一个嵌套函数(一个函数在另一个函数内):</p>
<p><img src="../Images/26e34bff67beabe85d9e0e60978f77b7.png" alt="Local, Enclosing, Global, and Built-in Namespace Diagram" loading="lazy" data-original-src="https://i.ibb.co/Cwb4KtP/diagram.png"/></p>
<p><small>如果您想查看该图的完整展示，请点击<a href="https://i.ibb.co/qp18HnK/diagram-full.png">此处</a>。</small></p>
<p>如果解释器在最里面的(局部)作用域中没有找到变量名<code>discount</code>，它将向上移动到下一个(封闭)作用域，到倒数第二个(全局)作用域，直到最外面的(内置)作用域。如果它没有找到它，它将引发一个错误。</p>
<p>如果您想了解更多关于名称空间的知识，请访问这篇文章。</p>
<p>现在，让我们继续讨论面向对象编程。</p>
<h1 id="pythonclasses">Python类</h1>
<p>当您将数据和功能结合在一起时，您就创建了一个<code>class</code>。这是一个新的<em>类型</em>的对象，允许产生其<em>类型</em>的新实例。实例可以用某些特征来维护它的状态，比如<strong>属性</strong>。您可以通过使用类中定义的<strong>方法</strong>来改变实例的状态。</p>
<p>让我们在下面的部分中分解上面提到的新概念。</p>
<h2 id="introduction">介绍</h2>
<p>下面的例子以字典的形式展示了两个银行。两者都试图解决同一个问题:当<code>net_income</code>值改变时更新<code>average_income</code>值。</p>
<pre><code class="language-python">bank_1 = {
    'name': 'Lincoln State Bank',
    'net_income': [7480, 1983, 7799, 4466, 4672],
    'average_income': 0
}

bank_2 = {
    'name': 'Rock Canyon Bank',
    'net_income': [3901, 1118, 1979, 6349, 5843],
    'average_income': 0
}
</code></pre>
<p>要解决这个问题，你可以这样做:</p>
<pre><code class="language-python">def average(bank):
    bank['average_income'] = sum(bank['net_income']) / len(bank['net_income'])
    return bank['average_income']


print(average(bank_1))
print(average(bank_2))

print(bank_1)
print(bank_2)
</code></pre>
<p>上面代码的一些问题:</p>
<ul>
<li><code>bank</code>必须是一个字典，并且必须有特定的键，因为函数依赖于它们。</li>
<li>创建许多类似的字典会非常冗长，因为我们必须定义每个字典中的键。</li>
<li>银行和平均函数之间没有依赖关系。在生产环境中，它们可能位于不同的文件中。在这种情况下，很难确定这里应该使用<code>average</code>函数。</li>
</ul>
<p>字典中最好有一些返回该银行的<code>average_income</code>的内容。这个函数将和它所使用的数据放在同一个地方，这样更容易使用。</p>
<p>例如:</p>
<pre><code class="language-python">bank_1 = {
    'name': 'Lincoln State Bank',
    'net_income': [7480, 1983, 7799, 4466, 4672],
    'average_income': sum(bank_1['net_income']) / len(bank_1['net_income'])
}
</code></pre>
<p>不幸的是，这段代码不起作用，因为我们在<code>bank_1</code>的定义中使用了<code>bank_1</code>。此外，即使它工作了，当<code>net_income</code>值改变时，它也不会自动更新<code>average_income</code>键。为此，您必须使用类。</p>
<h2 id="whatisaclass">什么是课？</h2>
<p>下面是一个名为<code>Bank</code>的类的例子:</p>
<pre><code class="language-python">class Bank:
    pass
</code></pre>
<p>用关键字<code>class</code>和类名声明一个类。尽管它现在什么都不做，我还是创建了一个类。关键字<code>pass</code>是未来代码的占位符。</p>
<p>每当您输入一个类定义时，都会创建一个新的命名空间。变量赋值和函数定义放在这个新的名称空间中。在类内部，<strong>变量</strong>变成了<strong>属性</strong>。</p>
<p>从长远来看，一个类就像一个蓝图，从这个蓝图中你可以创建多个<strong>对象</strong>。</p>
<h1 id="pythonobjects">Python对象</h1>
<p>可以对一个类执行两种类型的操作:<strong>实例化</strong>和<strong>属性引用</strong>。</p>
<h2 id="instantiation">实例化</h2>
<p>实例化是指创建新的<strong>类实例</strong>(称为对象)。这个过程非常类似于调用函数:一个类是一个孤立的代码块，只在“调用”时执行。</p>
<p>下面是一个名为<code>lincoln_state_bank</code>的对象的例子:</p>
<pre><code class="language-python">class Bank:
    pass


lincoln_state_bank = Bank()
</code></pre>
<p>在上面的例子中，我们创建了一个新的<code>Bank</code>类实例(我们称之为对象),并将它赋给变量<code>lincoln_state_bank</code>,这就是它的名字。在这个类中，你可以拥有任意数量的属性，比如<code>name</code>和<code>net_income</code>:</p>
<pre><code class="language-python">class Bank:
    name = 'Lincoln State Bank'
    net_income = [7480, 1983, 7799, 4466, 4672]

    
lincoln_state_bank = Bank()
print(lincoln_state_bank)
</code></pre>
<p>如果您运行代码，您可能会得到如下奇怪的输出:</p>
<pre><code>&lt;__main__.Bank object at 0x000001FC48AE4FD0&gt;
</code></pre>
<p>要获得有意义的输出，您需要引用print语句中的属性。下一节再说吧。</p>
<h2 id="attributereference">属性引用</h2>
<p>属性引用对本文第一部分讨论的名称关联使用标准的点<code>.</code>符号。引用<code>Bank.name</code>将返回<code>name</code>属性的值，即<code>'Lincoln State Bank'</code>:</p>
<pre><code class="language-python">class Bank:
    name = 'Lincoln State Bank'
    net_income = [7480, 1983, 7799, 4466, 4672]
    average_income = None


print(Bank.name)  # Lincoln State Bank
</code></pre>
<p>属性有两种:<strong>类属性</strong>和<strong>实例属性</strong>。到目前为止，你看到的是类属性。来说说他们吧。</p>
<h3 id="classattributes">类别属性</h3>
<p>类属性是类的名称空间中的变量名。它们在所有类实例中都可见:</p>
<pre><code class="language-python">class Bank:
    bank_type = 'Central Bank'


lincoln_state_bank = Bank()
rock_canyon_bank = Bank()

print(lincoln_state_bank.bank_type)  # Central Bank
print(rock_canyon_bank.bank_type)  # Central Bank
</code></pre>
<p>因此，每个对象的数据保存在属性中，如<code>name</code>、<code>net_income</code>和<code>average_income</code>:</p>
<pre><code class="language-python">class Bank:
    name = 'Lincoln State Bank'
    net_income = [7480, 1983, 7799, 4466, 4672]
    average_income = None


lincoln_state_bank = Bank()
rock_canyon_bank = Bank()

print(lincoln_state_bank.name)  # Lincoln State Bank
print(rock_canyon_bank.name)  # Lincoln State Bank
</code></pre>
<p>然而，这并不理想。我们需要两个具有不同属性值的对象。因此可以创建<strong>实例属性</strong>。</p>
<h3 id="instanceattributes">实例属性</h3>
<p>实例属性是存储在像<code>lincoln_state_bank</code>和<code>rock_canyon_bank</code>这样的对象中的名称。在这种情况下，属性是<code>name</code>:</p>
<pre><code class="language-python">class Bank:
    pass

lincoln_state_bank = Bank()
rock_canyon_bank = Bank()

lincoln_state_bank.name = "Lincoln State Bank"
rock_canyon_bank.name = "Rock Canyon Bank"
</code></pre>
<p>每个类实例的实例属性都是唯一的。它们在方法中定义，通常在名为<code>__init__</code>的特殊方法中定义:</p>
<pre><code class="language-python">class Bank:
    def __init__(self):
        pass
</code></pre>
<p><code>self</code>的值是Python给每个方法调用的，所以你不必为它提供值。因此，当你创建对象时，你必须<strong>而不是</strong>为<code>self</code>提供任何参数:</p>
<pre><code class="language-python">class Bank:
    def __init__(self):
        pass

lincoln_state_bank = Bank()
</code></pre>
<p><code>self.name</code>和<code>self.net_income</code>定义了两个将被绑定到唯一对象的实例属性。然后，它分配我们创建对象时提供的值:</p>
<pre><code class="language-python">class Bank:
    def __init__(self, name, net_income):
        self.name = name
        self.net_income = net_income


lincoln_state_bank = Bank(name='Lincoln State Bank', net_income=[7480, 1983, 7799, 4466, 4672])
rock_canyon_bank = Bank(name='Rock Canyon Bank', net_income=[3901, 1118, 1979, 6349, 5843])

print(rock_canyon_bank.name)  # Rock Canyon Bank
print(lincoln_state_bank.name)  # Lincoln State Bank
</code></pre>
<p>认为<code>self.name</code>和<code>self.net_income</code>是物体自身的属性(self)。每个对象可能有自己的一组属性值不同的属性。</p>
<p>每当您创建一个类的新实例时，Python都会为您调用特殊的方法<code>__init__</code>。例如，当我创建<code>lincoln_state_bank</code>实例时，Python解释器调用了特殊方法<code>__init__</code>。</p>
<p>在上面的例子中，我们创建了两个对象。它们是从同一个类中创建的，非常像一个蓝图。两者都是<code>Bank</code>类的实例，但是它们是不同的对象:</p>
<pre><code class="language-python"># same type
print(isinstance(lincoln_state_bank, Bank))  # True
print(isinstance(rock_canyon_bank, Bank))  # True

# different objects
print(id(lincoln_state_bank))  # 21515952681152
print(id(rock_canyon_bank))  # 2162583515524
</code></pre>
<p><code>isinstance()</code>函数的语法是<code>isinstance(object, type)</code>。如果第一个参数是第二个参数指定的类型，则返回<code>True</code>；否则，返回<code>False</code>。</p>
<p><code>id()</code>函数返回一个整数形式的对象标识。如果id不同，这意味着对象不同。</p>
<p>下面的例子展示了从一个类中创建的两个对象，这两个对象同时具有<em>类属性和</em>实例属性:</p>
<pre><code class="language-python">class Bank:
    bank_type = 'Central bank'  # class attribute
    
    def __init__(self, name, net_income):
        self.name = name  # instance attribute
        self.net_income = net_income  # instance attribute


lincoln_state_bank = Bank(name='Lincoln State Bank', net_income=[7480, 1983, 7799, 4466, 4672])  # object 1
rock_canyon_bank = Bank(name='Rock Canyon Bank', net_income=[3901, 1118, 1979, 6349, 5843])  # object 2
</code></pre>
<p>两个对象使用相同的<code>bank_type</code>属性，但是每个对象都有自己的<code>name</code>和<code>net_income</code>。</p>
<p>上面的例子使用对象重新创建了银行字典。现在，平均函数看起来像这样:</p>
<pre><code class="language-python">def average(bank):
        return sum(bank.net_income) / len(bank.net_income)

average(lincoln_state_bank)
</code></pre>
<p>但是，我们可以将这个函数移到类内部，并将其作为一个方法来使用。然后，您应该使用<code>self</code>,而不是将<code>Bank</code>对象传递给函数的参数:</p>
<pre><code class="language-python">class Bank:
    def __init__(self, name, net_income):
        self.name = name
        self.net_income = net_income

    def average(self):
        return sum(self.net_income) / len(self.net_income)


lincoln_state_bank = Bank(name='Lincoln State Bank', net_income=[7480, 1983, 7799, 4466, 4672])
rock_canyon_bank = Bank(name='Rock Canyon Bank', net_income=[3901, 1118, 1979, 6349, 5843])

print(lincoln_state_bank.average())  # 5280.0
print(rock_canyon_bank.average())  # 3838.0
</code></pre>
<p>注意，<code>average</code>方法也使用特殊参数<code>self</code>。现在，当您更新实例属性<code>net_income</code>时，您应该得到一个新的平均值:</p>
<pre><code class="language-python">lincoln_state_bank.net_income.append(591000)

print(lincoln_state_bank.average())  # 102900.0
print(rock_canyon_bank.average())  # 3838.0
</code></pre>
<p>即使我们修改了第一个对象的实例属性<code>net_income</code>，第二个对象仍然保持不变。让我们继续讨论Python方法。</p>
<h1 id="pythonmethods">Python方法</h1>
<p>把方法想象成一个类中的标准函数。在Python中，我们有三类方法:<strong>实例方法</strong>、<strong>静态方法</strong>和<strong>类方法</strong>。</p>
<p>我们只讨论了实例方法(<code>__init__</code>和<code>average</code>)。实例方法是最常见的，也是默认的方法类型。你可以在这里了解更多关于其他类型的Python方法<a href="https://blog.teclado.com/python-methods-instance-static-class/">。</a></p>
<h1 id="pythonspecialmethods">Python特殊方法</h1>
<p>特殊方法在分数下被<strong>d</strong>double<strong>包围，这就是为什么它们通常被称为dunder方法。你也可能会遇到称之为神奇方法的人。然而，在<a href="https://docs.python.org/3/reference/datamodel.html#special-method-names">官方Python文档</a>中，并没有提到这样的术语。</strong></p>
<p>我们已经看到了<code>__init__</code>特殊方法，但是还有更多不同的方法。让我们给你看看最受欢迎的。</p>
<p>Python有两种输出信息的特殊方法:</p>
<ul>
<li><code>__str__</code>通常用于以漂亮的格式向用户显示数据。</li>
<li><code>__repr__</code>用于开发人员的调试、记录或输出。</li>
</ul>
<p>这些特殊的方法允许您在不访问任何is属性的情况下打印对象。</p>
<p>正常情况下，在没有定义<code>__str__</code>或<code>__repr__</code>的情况下打印对象，会得到对象的内存地址:<code>&lt;__main__.Bank object at 0x0000024211E5DFA1&gt;</code>:</p>
<pre><code class="language-python">class Bank:
    def __init__(self, name, net_income):
        self.name = name
        self.net_income = net_income

    def average(self):
        return sum(self.net_income) / len(self.net_income)


rock_canyon_bank = Bank(name='Rock Canyon Bank', net_income=[3901, 1118, 1979, 6349, 5843])

print(rock_canyon_bank)  # &lt;__main__.Bank object at 0x0000024211E5DFA1&gt;
</code></pre>
<p>在这个例子中，你可以看到<code>__str__</code>和<code>__repr__</code>是如何帮助用户和开发者的:</p>
<pre><code class="language-python">class Bank:
    def __init__(self, name, net_income):
        self.name = name
        self.net_income = net_income

    def __str__(self):
        return f"{self.name}. Net income: {self.net_income}"

    def average(self):
        return sum(self.net_income) / len(self.net_income)


lincoln_state_bank = Bank(name='Lincoln State Bank', net_income=[7480, 1983, 7799, 4466, 4672])
rock_canyon_bank = Bank(name='Rock Canyon Bank', net_income=[3901, 1118, 1979, 6349, 5843])

print(lincoln_state_bank)  # Lincoln State Bank. Net income: [7480, 1983, 7799, 4466, 4672]
print(rock_canyon_bank)  # Rock Canyon Bank. Net income: [3901, 1118, 1979, 6349, 5843]
</code></pre>
<p><code>__repr__</code>特殊方法的工作方式类似:</p>
<pre><code class="language-python">def __repr__(self):
    return f"Bank({self.name!r}, {self.net_income!r})"
</code></pre>
<p>请记住，如果您同时定义了<code>__str__</code>和<code>__repr__</code>，它们都将被使用，但是在不同的情况下:</p>
<ul>
<li>当你<code>print()</code>一个对象或者用这个对象作为参数调用<code>str()</code>函数时，会用到<code>__str__</code>。</li>
<li>当您以对象作为参数调用<code>repr()</code>函数时，将使用<code>__repr__</code>。大多数调试器这样做是为了显示关于对象的信息。</li>
</ul>
<p>这里有一个例子:</p>
<pre><code class="language-python">print(repr(lincoln_state_bank))  # Bank("Lincoln State Bank", 15)
</code></pre>
<p>尽管两者都可以使用，但大多数情况下，你最终会使用其中一个。记住——使用<code>__str__</code>是为了美观，使用<code>__repr__</code>是为了开发。</p>
<h1 id="objectorientedprogrammingvsfunctionalprogramming">面向对象编程与函数式编程</h1>
<p>OOP的一个主要好处是使用数据的动作(或函数)与数据本身一起存储。这种共存可以简化事情。此外，我们经常谈论对象<em>执行</em>动作。这种思维方式可以让编码在某些场景下更有直观感。</p>
<pre><code class="language-python">bank_income = [9048, 1581, 9811, 5150, 5191]


class Bank:
    def __init__(self, name, net_income):
        self.name = name
        self.net_income = net_income

    def average(self):
        return sum(self.net_income) / len(self.net_income)


lincoln_state_bank = Bank(name='Lincoln State Bank', net_income=past_years_income)

print(lincoln_state_bank.average())  # 6156.2
</code></pre>
<p>现在来看看用一个函数重新创建相同代码的尝试:</p>
<pre><code class="language-python">bank_income = [9048, 1581, 9811, 5150, 5191]


def average_year_income(incomes):
    return sum(incomes) / len(incomes)


print(f"Lincoln State Bank: {average_year_income(bank_income)}")
# Lincoln State Bank: 6156.2
</code></pre>
<p>绝对更短的代码！毫无疑问，如果这是你编码的范围，你应该选择函数式方法。</p>
<p>但是这里有两个场景，OOP可能会给你带来一些好处:</p>
<h2 id="extendingtheclasses">扩展类</h2>
<p>比方说，你希望你的银行能够做得更多。例如，提供贷款。</p>
<p>我们需要记录每家银行贷出了多少钱，我们需要确保它不会超过银行的总收入。</p>
<p>使用OOP，相对简单:</p>
<pre><code class="language-python">class Bank:
    def __init__(self, name, net_income):
        self.name = name
        self.net_income = net_income
        self.loan_value = 0

    def average(self):
        return sum(self.net_income) / len(self.net_income)
    
    def offer_loan(self, amount):
        if self.loan_value + amount &gt; sum(self.net_income):
            raise ValueError(f"{self.name} can't offer a loan for {amount}. Not enough money.")
        self.loan_value += amount
        return amount
</code></pre>
<p>使用函数方法也是可行的，但是它开始变得更加复杂:</p>
<pre><code class="language-python">bank = {
    "name": "Lincoln State Bank"
    "income": [9048, 1581, 9811, 5150, 5191],
    "loan_amount": 0
}

def average_year_income(incomes):
    return sum(incomes) / len(incomes)

def offer_loan(bank, amount):
    if bank["loan_amount"] + amount &gt; sum(bank["income"]):
        raise ValueError(f"{bank["name"]} can't offer a loan for {amount}. Not enough money.")
    bank["loan_amount"] += amount
    return amount
</code></pre>
<p>随着我们添加更多的功能，功能方法的好处会有所减少:</p>
<ul>
<li>在我们应用程序的不同部分，如果我们想要使用它(和我们制作的其他函数)，我们需要导入<code>offer_loan</code>函数。</li>
<li>我们可能需要跟踪多个银行字典，如果我们犯了一个错误，一些可能会丢失一些必需的属性。</li>
</ul>
<p>相比之下，使用OOP:</p>
<ul>
<li>使用了<code>Bank</code>对象的应用程序的所有部分都可以在这些对象上使用<code>offer_loan</code>方法。不需要导入更多的函数并将它们保存在名称空间中。</li>
<li>不可能有缺少某些关键属性的对象，因为这些属性是在<code>__init__</code>方法中定义的。</li>
</ul>
<p>除此之外，使用OOP方法，我们可以说<strong>银行可以提供贷款</strong>，这很直观:</p>
<pre><code class="language-py">bank.offer_loan(500)
</code></pre>
<p>我认为这里的函数方法更难理解:</p>
<pre><code class="language-py">offer_loan(bank, 500)
</code></pre>
<p>然而，这在某种程度上也取决于个人偏好。</p>
<p>这个例子对于OOP来说并不是一个完美的例子，但是当你考虑使用哪种方法时，它绝对是一个值得考虑的问题。</p>
<h2 id="changingtheincomingdata">更改传入数据</h2>
<p>假设我们从一个API获取银行的收入数据。</p>
<p>有一天，API发生了变化，不再返回银行的收入列表，而是返回一个将收入分成几年的字典。比如这个:</p>
<pre><code class="language-python">past_years_income = {
    '2018': [7480, 1983, 7799, 4466, 4672],
    '2019': [8491, 8571, 8119, 8191, 5678],
    '2020': [9048, 1581, 9811, 5150, 5191]
}
</code></pre>
<p>如果您使用的是函数式方法，那么使用这些数据的每个函数都有可能发生变化。</p>
<p>这并不是世界末日，但是使用OOP可以节省一些工作。在<code>__init__</code>方法中，您可以修改传入的API数据，使其与旧的数据格式相匹配:</p>
<pre><code class="language-python">from itertools.chain import from_iterable

class Bank:
    def __init__(self, name, net_yearly):
        self.name = name
        self.net_yearly = net_yearly
        # Below: turns all dictionary values into a single list
        self.net_income = list(from_iterable(net_yearly.values()))
        self.loan_value = 0
</code></pre>
<p>现在这些方法都不需要改变，如果你想在其他方法中使用<code>self.net_yearly</code>,你仍然可以使用。</p>
<p>这是一个小例子，但是OOP的其他特性也是有用的。这些例子有<code>@classmethod</code>工厂、属性或使用抽象类。</p>
<p>所有这些，以及一般意义上的OOP，都应该在它简化你的代码并使之更容易使用的时候使用。很多时候，功能更简单、更快速或者更容易测试。在这种情况下，您应该坚持使用功能方法。</p>
<p>当你开始使用函数式和面向对象的方法时，你将发展出在不同的情况下做出正确决定的技能。</p>
<h1 id="conclusion">结论</h1>
<p>今天我们采用了一种不同的方法来解释面向对象编程，这与我们的其他帖子和课程不同。我希望你喜欢这本书，并且觉得它很有用！</p>
<p>如果你想学习更多关于Python的知识，可以考虑参加我们的<a href="https://go.tecla.do/complete-python-sale">完整Python课程</a>，它将带你从初级到高级(包括OOP、web开发、异步开发等等！).我们有一个<strong> 30天退款保证</strong>，所以你真的没有什么损失去尝试一下。我们很希望你能来！</p>
<small>Cover photo by <a href="https://unsplash.com/@arifriyanto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Arif Riyanto</a> on <a href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></small>
</div>
</div>    
</body>
</html>